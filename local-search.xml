<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>找工作該不該用獵頭</title>
    <link href="/2025/11/01/%E6%89%BE%E5%B7%A5%E4%BD%9C%E8%A9%B2%E4%B8%8D%E8%A9%B2%E7%94%A8%E7%8D%B5%E9%A0%AD/"/>
    <url>/2025/11/01/%E6%89%BE%E5%B7%A5%E4%BD%9C%E8%A9%B2%E4%B8%8D%E8%A9%B2%E7%94%A8%E7%8D%B5%E9%A0%AD/</url>
    
    <content type="html"><![CDATA[<p>【找工作，用不用獵頭？】<br>這是個好問題，特別對於你我有在使用Linkedin的人來說，我們跳脫了傳統的104而來到Linkedin，與獵頭的接觸也更加頻繁。但如何跟獵頭打交道、或是如何判斷獵頭品質，這類文章卻鮮少有人提及。<br>然而，很遺憾地，我並沒有經驗豐富到可以跟你們分享這些，但我可以以我這陣子與獵頭打交道得到的實際經驗，與你們做一些分享，主要關於一些可能你對獵頭的誤解。</p><p>獵頭在跟你聯繫後，會幫你找到合適你的職缺？<br>答：不一定，若你是對方想要經營的人脈的話，他可能會為了你這麼做，但陌生人忽然就發一個工作機會訊息給你的，你真的相信他會仔細看著你的履歷，找到你合適的職缺？</p><p>#我坦白說很多人連自己要什麼都不知道</p><p>獵頭受僱於獵頭公司與委託企業，你不思考自己想要什麼，就讓他的客戶與他自己的業績獎金幫你決定。</p><p>#請獵頭幫忙不代表你可以不思考自己的職涯</p><p>與獵頭打交道可以節省你的時間，更快找到理想職缺？<br>同理如上，當獵頭並沒有打算站在你的角度思考時，他只會基於自己的利益選出職缺然後丟給你，而你——我的朋友，可能得請個假陪他玩這種兒戲。</p><p>#獵頭不用承擔跟老闆請假的壓力但你必須要</p><p>獵頭因為與對方公司談過，比只透過JD看更清楚公司要什麼樣的人？<br>可能是，但不一定。舉我目前一陣子的經歷來說，我在跟獵頭談完，履歷表都寄出去了，對方才說公司需要找五年經驗的工程師，而我——從履歷上來，很明顯就知道不合適。</p><p>#跟你談的獵頭未必是與合作公司談的那一位</p><p>與獵頭聊天，了解自己的市場行情？<br>這應該是正確的，但你可能可以再想一想，只能夠透過獵頭的方式評估嗎？是不是可以直接丟你的理想職缺看看？</p><p>#使用獵頭不該是你疏於做功課的藉口</p><p>獵頭會幫你爭取更好的薪資條件？<br>額我沒遇過，倒是有遇到幫對面公司省預算來壓我薪水的，可能我不是臺大資工碩吧，呵呵</p><p>獵頭會幫你做職涯規劃的參考？</p><p>這一點要特別注意，因為我搞混過。<br>繼續重申我之前的論點，不要把獵頭當成你懶惰不做功課的藉口，如果你沒想法，就讓他的業績獎金來決定你的職涯。<br>正確的交流姿態是，已經做好的充足的準備後，最後跟獵頭確認一次有沒有少注意到的地方，而不是那種「欸你覺得工程師好不好，台積電是不是都年薪200萬啊」那樣的隨便態度。<br>職涯規劃師並不是在他的工作範圍內，所以就算他沒有為了自己業績獎金欺騙你，也不意味著他能為你做出正確的職涯規劃。他即使想也未必做得到，請尊重職涯規劃師的專業。然後——</p><p>#自己的未來方向請自己想謝謝</p><p>註：本文沒有任何一位台灣獵頭受到傷害，目前雷到我的都赴日獵頭</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>豐趣待一年多的感想</title>
    <link href="/2025/10/27/%E8%B1%90%E8%B6%A3%E5%BE%85%E4%B8%80%E5%B9%B4%E5%A4%9A%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <url>/2025/10/27/%E8%B1%90%E8%B6%A3%E5%BE%85%E4%B8%80%E5%B9%B4%E5%A4%9A%E7%9A%84%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>待了一年三個多月自請離職，我覺得我應該比面試過或是只短短待過一陣子的人要多一點資格評論這間公司。<br>先說結論，我不建議任何的技術者——不論你是擁有技術的技術者，或是自詡有技術的技術者，前來這間公司任職。<br>作為一個後端工程師，不論你的經驗如何、技能如何，老闆都傾向直接開給你統一薪資，這點就會造成許多人的不滿，另外公司最喜歡招轉職班出來的小朋友，開給他們還可以過下去的錢，用快樂職場的氣氛把人留在公司。<br>除此之外，工程師的管理制度也是一大問題，所有工程師與PM都直屬於技術長底下，然而技術長遲遲不想要去僱用人去分擔管理這一塊，這就導致主管對專案的集中力不足的前提下，又握有所有事物的管理權，大大小小的事情都要討論，你想想所有工程師與PM都要搶這個人的時間去討論會有多忙碌。<br>除了業務無法快速迭代這個缺點外，在考績上也同步影響考核，不時時跳出來表現老闆就當你什麼都沒有做，年終你就知道是什麼情況。<br>另外一個大問題是公司使用技術老舊，比方說後端宣稱使用的是Java，但進去才知道用的是Groovy，你以為是SpringBoot結果是早已經被時代淘汰的Grails，而且業務模式太過複雜，沒有核心人員支持重構根本動不了，此外綜合前面描述的你應該可以知道這不是件在人力上好推動的情境。</p><p>說完了壞處，那為了平衡一下觀感，我還是可以說一下他的好處：<br>女型比例較高，全公司人超過一半是女性，對於想要在有妹子支持你工作的環境的話是可以的。<br>整體業務飽和，簡單功能微調、改改樣式，工作內容是輕鬆且沒有太多壓力的，有些同事是家裡有礦，下凡來與俗人們體驗工程師文化的大仙。<br>有零食有咖啡，但是咖啡要錢一杯八塊<br>年終2個月，三節拋射全聯禮券，不時會有客戶送的一些東西，什麼翠玉白菜杯子之類的。</p><p>大概就分享到這邊，有興趣的在問我，就醬。</p>]]></content>
    
    
    
    <tags>
      
      <tag>心得 工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Review Python fundmentals after 3 years</title>
    <link href="/2025/09/11/Review-Python-fundmentals-after-3-years/"/>
    <url>/2025/09/11/Review-Python-fundmentals-after-3-years/</url>
    
    <content type="html"><![CDATA[<p>Hi, after many years I still find Python an attractive programming language even after I have worked as a Java engineer for pass three years.<br>It has plenty of modern features compared to Java language, and most importantly, many startups use Python or Go for their systems. So I’ve decided that it’s time for me to learn Python again.</p><h3 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h3><h4 id="int-string"><a href="#int-string" class="headerlink" title="int&amp;string"></a>int&amp;string</h4><ul><li>Immutable data type.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span><br>s = <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>Mutable data type. Use index to search element <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">party = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure></li></ul><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><ul><li>Immutable data type. often used in *args</li><li>unchange list<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">party = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>distinct element.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure></li></ul><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><ul><li>map structured data type.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">member_score = &#123;<span class="hljs-string">&quot;John&quot;</span>:<span class="hljs-number">98</span>,<span class="hljs-string">&quot;Helen&quot;</span>:<span class="hljs-number">78</span>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="using-Function"><a href="#using-Function" class="headerlink" title="using Function"></a>using Function</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">standard_arg</span>(<span class="hljs-params">arg</span>):<br>    <span class="hljs-built_in">print</span>(arg)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pos_only_arg</span>(<span class="hljs-params">arg, /</span>): <span class="hljs-comment"># only allow position</span><br>    <span class="hljs-built_in">print</span>(arg)<br>pos_only_arg(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kwd_only_arg</span>(<span class="hljs-params">*, arg</span>): <span class="hljs-comment"># only allow argument</span><br>    <span class="hljs-built_in">print</span>(arg)<br>kwd_only_arg(arg=<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combined_example</span>(<span class="hljs-params">pos_only, /, standard, *, kwd_only</span>):<br>    <span class="hljs-built_in">print</span>(pos_only, standard, kwd_only)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">error_foo</span>(<span class="hljs-params">name, **kwds</span>): <span class="hljs-comment"># kwds will collect argument into dict. may conflict with name&amp;kwds </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwds<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name, /, **kwds</span>): <span class="hljs-comment"># best practice. Avoid conflict between name&amp;&amp;kwds # kwds will collect argument into dict</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> kwds<br>foo(<span class="hljs-number">1</span>, **&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br><br><span class="hljs-comment"># import argument as tuple</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">boo</span>(<span class="hljs-params">*args</span>): <br>    <span class="hljs-built_in">print</span>(args)<br>boo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">ham: <span class="hljs-built_in">str</span>, eggs: <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;eggs&#x27;</span></span>) -&gt; <span class="hljs-built_in">str</span>: <span class="hljs-comment"># Comment in Function</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Annotations:&quot;</span>, f.__annotations__)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Arguments:&quot;</span>, ham, eggs)<br>    <span class="hljs-keyword">return</span> ham + <span class="hljs-string">&#x27; and &#x27;</span> + eggs<br></code></pre></td></tr></table></figure><h3 id="Python-lambda"><a href="#Python-lambda" class="headerlink" title="Python lambda"></a>Python lambda</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_incre</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: x + n<br>f = make_incre(<span class="hljs-number">1</span>)<br>g = make_incre(<span class="hljs-number">2</span>)<br>h = make_incre(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># using Function Composition</span><br>result = f(g(h(<span class="hljs-number">0</span>)))  <span class="hljs-comment"># 0 + 3 + 2 + 1</span><br><br>comb = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] <span class="hljs-keyword">if</span> x != y]<br>combs = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]:<br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]:<br>        <span class="hljs-keyword">if</span> x != y:<br>            combs.append((x, y))<br><br></code></pre></td></tr></table></figure><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>queue = deque([<span class="hljs-string">&quot;Eric&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Michael&quot;</span>])<br>queue.append(<span class="hljs-string">&quot;Terry&quot;</span>)           <span class="hljs-comment"># ([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;,&quot;Terry&quot;]</span><br>queue.append(<span class="hljs-string">&quot;Graham&quot;</span>)          <span class="hljs-comment"># ([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;,&quot;Terry&quot;,&quot;Graham&quot;]</span><br>queue.popleft() <span class="hljs-comment"># ([&quot;John&quot;, &quot;Michael&quot;,&quot;Terry&quot;,&quot;Graham&quot;]</span><br>queue.pop() <span class="hljs-comment"># ([&quot;John&quot;, &quot;Michael&quot;,&quot;Terry&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="Matrix-transpose-in-Python"><a href="#Matrix-transpose-in-Python" class="headerlink" title="Matrix transpose in Python"></a>Matrix transpose in Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">matrix = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>],<br>]<br><span class="hljs-comment"># 1.</span><br><span class="hljs-built_in">print</span>([[row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)])<br><span class="hljs-comment"># 2.</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*matrix))) <br></code></pre></td></tr></table></figure><h3 id="Techique-of-for-loop"><a href="#Techique-of-for-loop" class="headerlink" title="Techique of for loop"></a>Techique of for loop</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">knights = &#123;<span class="hljs-string">&#x27;gallahad&#x27;</span>: <span class="hljs-string">&#x27;the pure&#x27;</span>, <span class="hljs-string">&#x27;robin&#x27;</span>: <span class="hljs-string">&#x27;the brave&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> knights.items(): <span class="hljs-comment"># key &amp; value</span><br>    <span class="hljs-built_in">print</span>(k, v)<br>    <br><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;tic&#x27;</span>, <span class="hljs-string">&#x27;tac&#x27;</span>, <span class="hljs-string">&#x27;toe&#x27;</span>]): <span class="hljs-comment"># value with index</span><br>    <span class="hljs-built_in">print</span>(i, v)<br>    <br>questions = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;quest&#x27;</span>, <span class="hljs-string">&#x27;favorite color&#x27;</span>]<br>answers = [<span class="hljs-string">&#x27;lancelot&#x27;</span>, <span class="hljs-string">&#x27;the holy grail&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br><span class="hljs-keyword">for</span> q, a <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(questions, answers): <span class="hljs-comment"># composition</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(q, a))<br></code></pre></td></tr></table></figure><h3 id="Other-concept"><a href="#Other-concept" class="headerlink" title="Other concept"></a>Other concept</h3><ul><li>Use <code>json.dumps(x)</code> to serialize the object into json string</li><li>Use <code>json.loads(x)</code> to deserialize the jsonstring into specific object</li><li>When python interpreter boots, namespace will be created an never be deleted</li><li><code>namespace</code> is a space that python can store the variable, so even variable which has same name may stored in many space based on their scope.</li><li>python is no <code>private</code>, convently we use <code>__argument</code> as a private attribute and avoid accidently override by subclass or something else.<br><code>_age</code> use int protect attribute.</li><li>To increase the loading speed of the python module, python store their compile version into <code>＿_pycache__</code> and named <code>module.version.pyc</code></li></ul><h3 id="Use-inerator"><a href="#Use-inerator" class="headerlink" title="Use inerator"></a>Use inerator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;abc&#x27;</span><br>it = <span class="hljs-built_in">iter</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it)) <span class="hljs-comment">#a</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it)) <span class="hljs-comment">#b</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(it)) <span class="hljs-comment">#c</span><br></code></pre></td></tr></table></figure><h3 id="Use-generator"><a href="#Use-generator" class="headerlink" title="Use generator"></a>Use generator</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">yield</span> data[index] <span class="hljs-comment"># return part of element, to aviod resource over-occupied</span><br><span class="hljs-comment"># usage1</span><br>g = reverse(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-built_in">next</span>(g)<br><br><span class="hljs-comment"># usage2</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> reverse(<span class="hljs-string">&#x27;golf&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(char)<br></code></pre></td></tr></table></figure><h3 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">numbers</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(numbers, <span class="hljs-built_in">list</span>):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Input must be a list&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(numbers) / <span class="hljs-built_in">len</span>(numbers)<br><br><span class="hljs-keyword">import</span> unittest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStatisticalFunctions</span>(unittest.TestCase):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_average</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.assertEqual(average([<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>]), <span class="hljs-number">40.0</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-built_in">round</span>(average([<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]), <span class="hljs-number">1</span>), <span class="hljs-number">4.3</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(ZeroDivisionError):<br>            average([])<br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(TypeError):<br>            average(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>)<br></code></pre></td></tr></table></figure><h3 id="Multi-thread"><a href="#Multi-thread" class="headerlink" title="Multi-thread"></a>Multi-thread</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> queue<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># Build up a shared task queue</span><br>task_queue = queue.Queue()<br><br><span class="hljs-comment"># Define worker thread of what they&#x27;re doing</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        task = task_queue.get() <span class="hljs-comment"># Thread will be blocked in task_queue.get()，until queue exists value。</span><br>        <span class="hljs-keyword">if</span> task <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> 收到結束訊號，停止工作&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> 正在處理任務：<span class="hljs-subst">&#123;task&#125;</span>&quot;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># simulate the execution</span><br>        task_queue.task_done()<br><br><span class="hljs-comment"># Create the worker thread</span><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    t = threading.Thread(target=worker, args=(<span class="hljs-string">f&quot;工作者-<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>,))<br>    t.start() <span class="hljs-comment"># Let it execute worker function. These thread will waiting for the task in the background</span><br>    threads.append(t)<br><br><span class="hljs-comment"># Put task into main thread</span><br><span class="hljs-keyword">for</span> task_num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    task_queue.put(<span class="hljs-string">f&quot;任務-<span class="hljs-subst">&#123;task_num&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># wait until all task complete </span><br>task_queue.join()<br><br><span class="hljs-comment"># Notify end message to the worker</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> threads:<br>    task_queue.put(<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment"># Wait all worker complete</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All Task Complete!!!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Python-GIL"><a href="#Python-GIL" class="headerlink" title="Python GIL"></a>Python GIL</h3><p>&#x2F;&#x2F;TODO</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Remark Page</title>
    <link href="/2025/09/11/hello-world/"/>
    <url>/2025/09/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hexo 模板 資訊參考：<a href="https://hexo.fluid-dev.com/docs/guide/#%E9%85%8D%E7%BD%AE">https://hexo.fluid-dev.com/docs/guide/#%E9%85%8D%E7%BD%AE</a><br>如何更換Hexo主題 參考文件：<a href="https://s81679.github.io/2020/02/09/change-themes/">https://s81679.github.io/2020/02/09/change-themes/</a></p>]]></content>
    
    
    <categories>
      
      <category>UnCategory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>memo</tag>
      
      <tag>usage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>說明Java @Functionalinterface 的功用</title>
    <link href="/2025/02/02/%E8%AA%AA%E6%98%8EJava-Functionalinterface-%E7%9A%84%E5%8A%9F%E7%94%A8/"/>
    <url>/2025/02/02/%E8%AA%AA%E6%98%8EJava-Functionalinterface-%E7%9A%84%E5%8A%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Java──眾所皆知，這是一個非常OOP的語言，Java的萬物皆物件的概念使得Java無法像Python一樣寫出不依賴物件的方法，簡言之，Python可以寫出這樣的程式碼而Java不行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">printHello</span>():<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-built_in">print</span>(printHello() + <span class="hljs-string">&quot;Clark)</span><br></code></pre></td></tr></table></figure><p>因此，<code>Functional Programming</code>被不少人評價使用Java撰寫總是有點彆扭，也有一部分是這個原因。那在提到@Functionalinterface這個註解前，我們先來提一提Java的FP實作，也就是大家常用的Lambda吧。<br>Lambda可以將Function以參數的形式傳遞，恰好符合FP將Function作為一等公民的概念，在Java 8 引入Lambda之後，就可以在不使用物件的情形下使用方法，也就是匿名函式(anonymous function)。我們來看看幾個例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; nameMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>nameMap.put(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">100</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> nameMap.computeIfAbsent(<span class="hljs-string">&quot;John&quot;</span>, s -&gt; s.length());<br></code></pre></td></tr></table></figure><p>行3的作用是，假設nameMap中沒有名為John的Key的話，就執行方法中的匿名函式，也就是說將會回傳4這個值。寫法也可以改成方法參照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> nameMap.computeIfAbsent(<span class="hljs-string">&quot;John&quot;</span>, String::length);<br></code></pre></td></tr></table></figure><p>或是將方法提取出來，也就是說上面的方法可以改寫成以下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Integer&gt; nameMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>nameMap.put(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">100</span>);<br>Function&lt;String,Integer&gt; compute = String::length;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> nameMap.computeIfAbsent(<span class="hljs-string">&quot;John&quot;</span>, compute); <span class="hljs-comment">// Function介面 接收一個輸入與輸出參數</span><br></code></pre></td></tr></table></figure><p>另外Function也接受組合(Composition)，也就是說Function接續執行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Function&lt;String, String&gt; firstExecute = s -&gt; s + <span class="hljs-string">&quot;就只會&quot;</span>;<br>Function&lt;String, String&gt; secondExecute = s -&gt;  s + <span class="hljs-string">&quot;騙人&quot;</span>;<br>Function&lt;String, String&gt; quoteIntToString = secondExecute.compose(firstExecute);<br>assertEquals(<span class="hljs-string">&quot;初華就只會騙人&quot;</span>, quoteIntToString.apply(<span class="hljs-string">&quot;初華&quot;</span>));<br></code></pre></td></tr></table></figure><p>透過以上程式碼，傳入參數會先執行firstExecute，再執行secondExecute，最後我們使用斷言得出一個結論，那就是：初華就只會騙人。Q.E.D. 證明完畢</p><p>Function這個介面目前已經有不少Java得實作，以下介紹部分：</p><ol><li>Suppliers</li><li>Consumers</li><li>Predicates</li><li>Operators</li></ol><h4 id="Suppliers"><a href="#Suppliers" class="headerlink" title="Suppliers"></a>Suppliers</h4><p>不接受傳入，只會傳出一個值，通常用來延遲產生某個運算值，比方說以下程式碼，直到呼叫.get()之前Lambda都不會被執行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">squareLazy</span><span class="hljs-params">(Supplier&lt;String&gt; lazyValue)</span> &#123;<br>    <span class="hljs-keyword">return</span> lazyValue.get();<br>&#125;<br><br>Supplier&lt;String&gt; soyoriinWord = () -&gt; <span class="hljs-string">&quot;就由我來將它結束&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">valueSquared</span> <span class="hljs-operator">=</span> squareLazy(soyoriinWord);<br></code></pre></td></tr></table></figure><h4 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h4><p>與Supplier相反，接受一個或多個傳入，但不回傳任何數，下方案例我們可以印出<br><strong><code>從來不覺得, 玩樂團, 開心過,</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; template = name -&gt; System.out.println(name + <span class="hljs-string">&quot;,&quot;</span>);<br>List&lt;String&gt; sentenceList = Arrays.asList(<span class="hljs-string">&quot;從來不覺得&quot;</span>, <span class="hljs-string">&quot;玩樂團&quot;</span>, <span class="hljs-string">&quot;開心過&quot;</span>);<br>sentenceList.forEach(template);<br></code></pre></td></tr></table></figure><h4 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h4><p>Predicate的特性是接收值，但只回傳boolean，常用於 .stream()的 filter()當中。以下案例我們可以找出初華</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; findLiar = name -&gt; name.equals(<span class="hljs-string">&quot;初華&quot;</span>);<br>List&lt;String&gt; aveMujicaList = Arrays.asList(<span class="hljs-string">&quot;睦&quot;</span>, <span class="hljs-string">&quot;海鈴&quot;</span>, <span class="hljs-string">&quot;初華&quot;</span>, <span class="hljs-string">&quot;小祥&quot;</span>, <span class="hljs-string">&quot;破貓&quot;</span>);<br>List&lt;String&gt; liarMemberList = aveMujicaList.stream()<br>        .filter(findLiar)<br>        .toList();<br>System.out.println(liarMemberList);<br></code></pre></td></tr></table></figure><h4 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h4><p>Operator是用來處理值的變化，比方說以下程式碼會將每一個Array中的值轉為大寫。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">UnaryOperator&lt;String&gt; changeUppercase = String::toUpperCase;<br>List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;soyorin&quot;</span>, <span class="hljs-string">&quot;tomorin&quot;</span>, <span class="hljs-string">&quot;rikki&quot;</span>);<br>names.replaceAll(changeUppercase);<br></code></pre></td></tr></table></figure><p>最後@Functionalinteface這個註解是用來標示Function的，假設我們有多個lambda都需要實作一個功能，而你可以使用介面去掌控它，但這個介面只是單純用來做Functional的定義的，所以為了把他與一般的類別作區隔，於是就可以加入@Functionalinterface做為區隔。</p><p>以上就是解釋了，不知道看的人了不了解，希望各位除了知道初華就只會騙人之外，還可以學到更多Java的相關知識，連價最後一天，我要去繼續補Ave Mujica了，就這樣。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Functional Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HATEOAS 是什麼？</title>
    <link href="/2025/01/25/HATEOAS-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"/>
    <url>/2025/01/25/HATEOAS-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><code>Spring HATEOAS</code> 是開發 <code>REST</code> 應用程式中常出現的概念，這個名詞在我工作中並沒有出現過，但往往自學就是要接觸自己平時不熟悉的事物。在哭完 “我已經學不動啦！”之後，就讓我們一起來看看 <code>Spring HATEOAS</code>吧。</p><p><code>HATEOAS</code>是種規範，與我們常用的<code>JSON</code>概念相近， <code>HATEOAS</code> 的目的是，除了已簡潔的JSON格式回應客戶端請求外，另外告知客戶端如何取得下一步的資源，與 <code>JSON</code> 相似但不完全一致。為了好好的說明它，我們先介紹兩種http header 的 Content-Type</p><ul><li>application&#x2F;json</li><li>application&#x2F;hal+json</li></ul><p>第一種是傳統的 <code>JSON</code>格式，另一種則是傳統的 <code>JSON</code>加上 <strong><code>HAL</code></strong> 的支援。 <code>HAL</code> 就是實作 <code>HATEOAS</code> 的方法，不多說，直接SHOW YOU THE CODE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 這是基本的JSON結構</span><br>&#123;<br>  <span class="hljs-string">&quot;transactionNumber&quot;</span>: <span class="hljs-string">&quot;Fool001&quot;</span>,<br>  <span class="hljs-string">&quot;transactionResult&quot;</span>: <span class="hljs-string">&quot;SUCCESS&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 這是HATEOAS的結構</span><br>&#123;<br>  <span class="hljs-string">&quot;transactionConfigId&quot;</span>: <span class="hljs-string">&quot;013&quot;</span>,<br>  <span class="hljs-string">&quot;transactionNumber&quot;</span>: <span class="hljs-string">&quot;Fool001&quot;</span>,<br>  <span class="hljs-string">&quot;transactionId&quot;</span>: <span class="hljs-string">&quot;12673&quot;</span>,<br>  <span class="hljs-string">&quot;transactionResult&quot;</span>: <span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>  <span class="hljs-string">&quot;_links&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;self&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/transaction/12673&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;transactionConfig&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/transactionConfig/013&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>已上方的例子來說， <code>JSON</code>只會回應交易單號與交易結果，但使用 <code>HATEOAS</code> 不僅可以得到結果，還可以得知下一步想要取得資源的方式，這樣的做法有不少好處。</p><ul><li>幫助客戶端動態發現資源，若是 <code>JSON</code>客戶端必須要透過其他方式(比如說文件)，才能了解更多回應的資訊。</li><li>除了連結以外，也可以包含一些操作，比方說更新、刪除等等。</li><li>寫在response裡面，減少了API更新必須同步外部的困擾。</li></ul><p>如果是 <code>Spring</code> ，會使用 <code>Spring HATEOAS</code> 這個套件來實現，想要使用首先須引入套件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>引入之後就可以開始使用，以下是一個簡單的範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/payment&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;query/&#123;transactionId&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Transaction <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String transactionId)</span> &#123;<br>        <span class="hljs-comment">// 創建 Transaction 物件</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>        transaction.setTransactionConfigId(<span class="hljs-string">&quot;013&quot;</span>);<br>        transaction.setTransactionNumber(<span class="hljs-string">&quot;Fool001&quot;</span>);<br>        transaction.setTransactionId(transactionId);<br>        transaction.setTransactionResult(<span class="hljs-string">&quot;SUCCESS&quot;</span>);<br><br>        <span class="hljs-comment">// 添加 self 鏈接</span><br>        transaction.add(linkTo(methodOn(TransactionController.class).getTransaction(transactionId))<br>                .withSelfRel());<br><br>        <span class="hljs-comment">// 添加 鏈接</span><br>        transaction.add(Link.of(<span class="hljs-string">&quot;http://localhost:8080/payment/pay/&quot;</span> + transactionId)<br>                .withRel(<span class="hljs-string">&quot;pay&quot;</span>));<br><br>        transaction.add(Link.of(<span class="hljs-string">&quot;http://localhost:8080/payment/refund/&quot;</span> + transactionId)<br>                .withRel(<span class="hljs-string">&quot;refund&quot;</span>));<br><br>        transaction.add(Link.of(<span class="hljs-string">&quot;http://localhost:8080/payment/reverse/&quot;</span> + transactionId)<br>                .withRel(<span class="hljs-string">&quot;reverse&quot;</span>));<br><br>        transaction.add(Link.of(<span class="hljs-string">&quot;http://localhost:8080/payment/settle/&quot;</span> + transactionId)<br>                .withRel(<span class="hljs-string">&quot;settle&quot;</span>));<br><br>        <span class="hljs-keyword">return</span> transaction;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RepresentationModel</span>&lt;Transaction&gt; &#123;<br>    <span class="hljs-keyword">private</span> String transactionConfigId;<br>    <span class="hljs-keyword">private</span> String transactionNumber;<br>    <span class="hljs-keyword">private</span> String transactionId;<br>    <span class="hljs-keyword">private</span> String transactionResult;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTransactionConfigId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> transactionConfigId;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTransactionConfigId</span><span class="hljs-params">(String transactionConfigId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transactionConfigId = transactionConfigId;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTransactionNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> transactionNumber;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTransactionNumber</span><span class="hljs-params">(String transactionNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transactionNumber = transactionNumber;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTransactionId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> transactionId;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTransactionId</span><span class="hljs-params">(String transactionId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transactionId = transactionId;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTransactionResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> transactionResult;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTransactionResult</span><span class="hljs-params">(String transactionResult)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transactionResult = transactionResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Transaction是一個物件，我建立了一個查詢交易的API，當客戶端查詢或是工程師們使用Postman進行測試時，會收到以下回應：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">GET http:<span class="hljs-comment">//localhost:8080/payment/query/Test001</span><br><br>&#123;<br>    <span class="hljs-string">&quot;transactionConfigId&quot;</span>: <span class="hljs-string">&quot;013&quot;</span>,<br>    <span class="hljs-string">&quot;transactionNumber&quot;</span>: <span class="hljs-string">&quot;Fool001&quot;</span>,<br>    <span class="hljs-string">&quot;transactionId&quot;</span>: $&#123;你輸入的訂單編號&#125;,<br>    <span class="hljs-string">&quot;transactionResult&quot;</span>: <span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>    <span class="hljs-string">&quot;_links&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;self&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/payment/query/$&#123;你輸入的訂單編號&#125;&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;pay&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/payment/pay/$&#123;你輸入的訂單編號&#125;&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;refund&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/payment/refund/$&#123;你輸入的訂單編號&#125;&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;reverse&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/payment/reverse/$&#123;你輸入的訂單編號&#125;&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;settle&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;href&quot;</span>: <span class="hljs-string">&quot;http://localhost:8080/payment/settle/$&#123;你輸入的訂單編號&#125;&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用戶使用訂單查詢後可以順便帶入他的下一步可進行的動作，這麼做有以下好處：</p><ol><li>靈活度 客戶端的API不必寫死，也可以不必要事先知道有哪些API路徑。</li><li>當API有標註版本時，還可以進行靈活的版本控制，比方說原本是1.0版推出了1.1版。</li><li>更好的描述性，客戶端可以很明確地知道自己的下一部可以怎麼做。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HATEOAS</tag>
      
      <tag>REST</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary 2025/01/19</title>
    <link href="/2025/01/19/Diary-2025-01-19/"/>
    <url>/2025/01/19/Diary-2025-01-19/</url>
    
    <content type="html"><![CDATA[<p>本週追了去年的新番，還不錯，可以加入<br>【地下城的人們】<br>特色：</p><ul><li>非作為闖關地下城的視角，而是做為經營方看待地下城</li><li>畫風可愛，角色也可愛。</li><li>百合好香好香好香</li><li>OP ED 都好聽</li><li>戰鬥畫面、世界觀都做得不錯，有趣</li></ul><p>總評分：78&#x2F;100</p><p>【雖然是公會的櫃檯小姐，但因為不想加班所以打算獨自討伐迷宮頭目】<br>特色：</p><ul><li>高橋李依</li><li>劇情不算有趣，很多橋段缺乏合理性</li><li>ED 不合我胃口，OP風格與ED的協調性不佳，像是外包給兩個Team在做</li><li>棄坑<br>總評分：42&#x2F;100</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新手軟體工程師的一些思考</title>
    <link href="/2025/01/18/%E6%96%B0%E6%89%8B%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <url>/2025/01/18/%E6%96%B0%E6%89%8B%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>今天是鐵人賽的最後一篇了，這一篇我不打算要講技術了，比較像是要分享我的完賽感言，或者是作為一名作為一年的軟體工程師誕生出的一些想法，如果沒興趣看的可以上一頁了。</p><p>作為一名初出茅廬的軟體工程師，想必很多人都滿懷熱情地去學習各種軟體知識，前端、後端、資料庫、Devops等等，我初期時也是同樣的狀態，巴望著每天都要讓自己多懂一些。但後來就發現，軟體工程師的世界真的太大了。我曾經在實習時擔任過其他職位，我的感想是軟體工程師真的是一個不斷去學習的職業。</p><p>有些人可能會說，啊其他行業就不用學是不是？但我不是那個意思，我的意思是軟體工程師會需要你在下班後還去學習新的技術，在這很捲的業界中，在跑已經是基本了，彼此還在兢爭跑得夠不夠快、方向是不是趨勢等等。我認為會這樣的職業應該不多，當然如果我錯了就指正我吧。</p><p>有些人可能會說，啊軟體工程師薪水很高啊，這樣還好吧。但我也不是那個意思，倒不如說把辛勞與薪水相提並論本身就是一個謬論。</p><p>努力本身不代表薪水價值，你隨處可見一名工程師為了專案加班趕工，而隔壁老屁股工程師打高爾夫閃到腰要請假一個禮拜，而他的薪水高得不得了 (我們先假設不是有靠山)。</p><p>倘若薪水的決定依據與你個人的努力無關，那它究竟被甚麼決定呢？答案是價值，更精準地來說是職場價值、或是企業價值。而個人價值通常會被忽略。</p><p>職場價值是你作為一名軟體工程師中，在職場中有多少價值？</p><p>企業價值是你作為一名企業的軟體工程師中，在企業中有多少價值？</p><p>這也因此證明了為甚麼努力不被證明，加班趕工忙專案，但還是比不上老屁股閃到腰的原因。企業價值很難不被年資影響，縱使個人能力出眾，你也必須要說服所有上面的長官你為何出眾。而年資不用那麼麻煩，只要不被趕走就行。</p><p>職場價值是指軟體工程師在職場中的價值，這點主要受到兩個主要因素影響，一個是外部因素──也就是回到廣泛的市場供需，假設你在的產業就是一個夕陽產業(假設書籍出版業)，縱使你能力多麼出眾，軟體知識如何強如何透徹，你也無法獲得像其他產業一樣高的薪水。縱使你照三餐向老闆靠邀而老闆也同意你也一樣，本身的行業就沒有足夠的資金流動，與你個人的努力與程度沒有任何關係。另一個例子是假設你在博亦產業，然後…(我不說你們也知道我要說啥)</p><p>另一個因素就是內部因素，也就是回到你自身，相比在職場上活躍的軟體工程師，你比其他人要傑出多少，我們大多數人的努力都是期望在這個區間變得傑出。對，我們可以，但請別忘記，對企業來說，這不過只是標準之一。</p><p>說了這麼多，我只是想要闡述一個重點──決定薪資的，不全是職業，更重要影響的是「產業類別」與「企業」。講白就是你要，也得要別人給得起。</p><p>我認為所有的職業都一樣遵照供需法則，供給缺乏且需求高漲的價值才會高，與努力什麼的感性言論無關，而適逢AI近年崛起，對軟體工程師的未來也勢必成為一大挑戰。有些人可能會說甚麼AI取代不了軟體工程師，我對這個看法高度存疑。縱使OpenAI執行長奧特曼底下的研發都跑光光，執行長天馬行空也一樣。我們就講一件事，ChatGPT改變了世界用了僅僅不到三年，而你──假設不那麼苦命的話，至少也得工作20年，如果你可以預測到AI 20年的發展的話我認為你大可以這麼聲張，但若你不行，那我認為這樣的聲明是缺乏公信力的。</p><p>講了那麼多，我想要講什麼？</p><p>我的回答如下：就跟老黃講得一樣，跑就對了，你各位還不快滾去想明年鐵人賽要寫什麼啊，88888。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自我思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mircoservice 的特色</title>
    <link href="/2025/01/18/Mircoservice-%E7%9A%84%E7%89%B9%E8%89%B2/"/>
    <url>/2025/01/18/Mircoservice-%E7%9A%84%E7%89%B9%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<p><strong>3層架構（3-Tier Architecture）</strong></p><ul><li>通常來說，三層架構包括表示層、業務邏輯層、數據訪問層。</li></ul><p><strong>多層架構（N-Tier Architecture）</strong></p><ul><li>基於 3 層架構，進一步細化層次（如增加 API 層、安全層、緩存層等）。</li></ul><p>在分散式系統中，N層架構的層次可能分佈於不同的服務器或微服務中，例如：</p><ul><li>表示層運行在用戶的設備或前端服務器。</li><li>業務邏輯層運行在後端服務器。</li><li>數據層可能是雲端數據庫或分布式存儲。</li></ul><h3 id="N層式架構的缺點"><a href="#N層式架構的缺點" class="headerlink" title="N層式架構的缺點"></a>N層式架構的缺點</h3><p>⛔  進行特定層的變更時，必須要重啟應用程式 (多個專案)。<br>⛔  需要透過多個專案，無法直接運作。</p><h3 id="微服務特色"><a href="#微服務特色" class="headerlink" title="微服務特色"></a>微服務特色</h3><ul><li>各服務職責分明、並協同合作完成目標</li><li>獨立部署</li><li>使用JSON、HTTP 輕量級通訊協定</li><li>開發語言不拘，只要以JSON格式互相溝通都行</li></ul><h3 id="簡單的微服務概念"><a href="#簡單的微服務概念" class="headerlink" title="簡單的微服務概念"></a>簡單的微服務概念</h3><p><img src="/img/microservice.png" alt="▲ 微服務圖示"></p><h3 id="人們希望微服務解決的問題"><a href="#人們希望微服務解決的問題" class="headerlink" title="人們希望微服務解決的問題"></a>人們希望微服務解決的問題</h3><ul><li>Continuous Delivery 快速交付</li><li>Scalability 擴展性</li><li>High Availability 高可用性</li><li>Flexible &amp; Decoupled 靈活、解耦</li><li>Resilient 彈性</li></ul><h3 id="微服務的開發模式應思考"><a href="#微服務的開發模式應思考" class="headerlink" title="微服務的開發模式應思考"></a>微服務的開發模式應思考</h3><ul><li>思考服務粒度，正確責任級別為何？</li><li>通訊協定，服務可否接受非同步傳輸 (HTTP or AMQP) &lt;&lt; 其實就算不微服務也該思考</li><li>設定管理，如何管理微服務設定？</li><li>如何使用事件來解耦微服務？</li></ul><h3 id="微服務路由模式"><a href="#微服務路由模式" class="headerlink" title="微服務路由模式"></a>微服務路由模式</h3><ol><li><strong>Service Routing模式</strong>：為所有服務提供一個單一入口點(URL)，以便統一安全策略與路由規則，可作為操作身分、內容驗證的入口點。</li><li><strong>Service Discovery模式</strong>：可以不寫死IP位址就可以讓Client找到正確的服務，抽象化後可以一併控制服務的新增與刪除，Auto-Scaling的概念。</li></ol><h3 id="微服務Client端彈性模式"><a href="#微服務Client端彈性模式" class="headerlink" title="微服務Client端彈性模式"></a>微服務Client端彈性模式</h3><ol><li><strong>Client Load Balancing模式</strong>：快取微服務的服務實例以便對單一微服務的呼叫可以Load Balance到所有健康的實例上。</li><li><strong>Circuit Breaker模式</strong>：用於防止Client不斷呼叫失敗或有問題的服務，使這些請求快速失敗。</li><li><strong>Fallback模式</strong>：當呼叫服務失敗時，用於提供一種外掛機制，允許Client改呼叫其他服務以完成工作。</li><li><strong>Bulkhead模式</strong>：當微服務應用程式使用多個分散式資源執行工作時，區隔這些呼叫，避免單一服務壅塞導致其他服務也跟著無法正常運作。</li></ol><h3 id="微服務Security模式"><a href="#微服務Security模式" class="headerlink" title="微服務Security模式"></a>微服務Security模式</h3><ol><li>身分驗證，確保Client與提供身分符合</li><li>授權，確保以能進行被授權的操作</li><li>憑證管理與傳播，避免不斷對Client索取憑證，Token要可以傳遞於各服務間。</li></ol><h3 id="微服務Log-Tracking模式"><a href="#微服務Log-Tracking模式" class="headerlink" title="微服務Log Tracking模式"></a>微服務Log Tracking模式</h3><ol><li><strong>Log Correlation</strong>：實作關聯ID，將所有單一交易或操作而呼叫的所有服務所生成的Log紀錄關聯在一起。</li><li><strong>Log Aggregation</strong>：透過這種模式可以將微服務及各個實例產生的所有日誌紀錄彙整到一個跨服務的可查詢資料庫中，藉由各日誌紀錄的時間戳記可以了解各服務效能狀況。</li><li><strong>Microservice tracing</strong>：視覺化流程</li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MicroService</tag>
      
      <tag>微服務</tag>
      
      <tag>Concept</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隔離層級測試紀錄-使用Grails</title>
    <link href="/2025/01/11/%E9%9A%94%E9%9B%A2%E5%B1%A4%E7%B4%9A%E6%B8%AC%E8%A9%A6%E7%B4%80%E9%8C%84-%E4%BD%BF%E7%94%A8Grails/"/>
    <url>/2025/01/11/%E9%9A%94%E9%9B%A2%E5%B1%A4%E7%B4%9A%E6%B8%AC%E8%A9%A6%E7%B4%80%E9%8C%84-%E4%BD%BF%E7%94%A8Grails/</url>
    
    <content type="html"><![CDATA[<p>我本來的想法是 READ_COMMITTED 只要commit()後的資料就應該要被讀取到，但實際上卻出現還是讀取到舊資料的問題。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">def <span class="hljs-title function_">testRepeatableRead</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(&#123;<br>        testService.readData(<span class="hljs-number">2106</span>)<br>    &#125;)<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(&#123;<br>        Thread.sleep(<span class="hljs-number">5000</span>) <span class="hljs-comment">// Delay to ensure the first read in t1 has completed</span><br>        modifyDataService.modifyData(<span class="hljs-number">2106</span>)<br>    &#125;)<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span><br>&#125;<br><br><span class="hljs-meta">@Transactional(isolation=Isolation.READ_COMMITTED)</span><br>def <span class="hljs-title function_">repeatReadData</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">MeetingRoomBooking</span> <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br>    <span class="hljs-comment">// Simulate some processing time</span><br>    Thread.sleep(<span class="hljs-number">10000</span>)<br>    <span class="hljs-comment">// Read the same data again</span><br>    booking = MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;Second read: $&#123;booking?.content&#125;&quot;</span><br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModifyDataService</span> &#123;<br>    def <span class="hljs-title function_">modifyData</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">MeetingRoomBooking</span> <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>        booking.content = <span class="hljs-string">&quot;2&quot;</span><br>        booking.save(flush: <span class="hljs-literal">true</span>)<br>        println <span class="hljs-string">&quot;Data updated to: $&#123;booking.content&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// First read: 1</span><br><span class="hljs-comment">/// Data updated to: 2</span><br><span class="hljs-comment">/// Second updated: 1</span><br></code></pre></td></tr></table></figure><h2 id="發生原因"><a href="#發生原因" class="headerlink" title="發生原因"></a>發生原因</h2><p>出现这种情况的原因是 Grails 的一级缓存（Session 级别缓存）导致的。默认情况下，Grails 使用 Hibernate 作为 ORM 框架，并且 Hibernate 会维护一个一级缓存，这个缓存会存储当前 Session 中加载的所有对象。在你的 <code>readData</code> 方法中，第一次调用 <code>MeetingRoomBooking.get(id)</code> 时，会从数据库加载对象并缓存到当前 Session 中。在第二次调用 <code>MeetingRoomBooking.get(id)</code> 时，Hibernate 会直接从一级缓存中获取对象，而不会再去查询数据库</p><p>为了确保你在第二次读取时能读取到最新的数据，你可以清理一级缓存。你可以使用 <code>withNewSession</code> 方法或者 <code>clear()</code> 方法来达到这个目的。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ol><li>withNewSession</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Read the same data again in a new session</span><br>MeetingRoomBooking.withNewSession &#123;<br>    booking = MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;Second read: $&#123;booking?.content&#125;&quot;</span><br><br></code></pre></td></tr></table></figure><ol><li>clear()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>    sessionFactory.currentSession.clear()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Q: 那假設REPEATABLE_READ隔離層級下，可讀取到在其他地方被commit之後的資料嗎？</p><p>A:  clear Session無效，只能建立新的Session。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br>def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">MeetingRoomBooking</span> <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br>    modifyData(id)<br>    Thread.sleep(<span class="hljs-number">5000</span>)<br><br>    MeetingRoomBooking.withNewSession &#123;<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;Second Read:$&#123;booking?.content&#125;&quot;</span><br>    &#125;<br>    booking = MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;Third read: $&#123;booking?.content&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">//First read: 1</span><br><span class="hljs-comment">//Update to 2</span><br><span class="hljs-comment">//Second Read:1 (因為交易結束後才會commit(),withNewTransaction會讀到資料庫的舊資料</span><br><span class="hljs-comment">//Third Read:2 (直接讀取會讀取Hibernate的一級緩存，所以是修改後的值</span><br><br></code></pre></td></tr></table></figure><p>Q: 有辦法在交易裡面強迫commit()嗎？</p><p>A:可以，使用Hibernate Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">def sessionFactory<br><br><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br>def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>    MeetingRoomBooking <span class="hljs-type">booking</span><br>    <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br><br>    <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession()<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        tx = session.beginTransaction()<br>        modifyData(id)<br>        Thread.sleep(<span class="hljs-number">5000</span>)<br>        <span class="hljs-comment">// Manually commit the transaction</span><br>        tx.commit()<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (tx != <span class="hljs-literal">null</span>) tx.rollback()<br>        <span class="hljs-keyword">throw</span> e<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        session.close()<br>    &#125;<br><br>    MeetingRoomBooking.withNewSession &#123;<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;new Transaction Read:$&#123;booking?.content&#125;&quot;</span><br>    &#125;<br>    booking = MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;Direct read: $&#123;booking?.content&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Update to 2</span><br><span class="hljs-comment">// 2 (此時已經commit，資料已經寫到資料庫了)</span><br><span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><p>Q: 那如果我提高隔離層級呢</p><p>A:  依然讀取的是Hibernate快取，不符合可重複讀特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br>def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br><br>    <span class="hljs-type">MeetingRoomBooking</span> <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br><br>    <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sessionFactory.openSession()<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        tx = session.beginTransaction()<br>        modifyData(id)<br>        Thread.sleep(<span class="hljs-number">5000</span>)<br>        <span class="hljs-comment">// Manually commit the transaction</span><br>        tx.commit()<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (tx != <span class="hljs-literal">null</span>) tx.rollback()<br>        <span class="hljs-keyword">throw</span> e<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        session.close()<br>    &#125;<br><br>    MeetingRoomBooking.withNewSession &#123;<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;new Transaction Read:$&#123;booking?.content&#125;&quot;</span><br>    &#125;<br>    booking = MeetingRoomBooking.get(id)<br>    println <span class="hljs-string">&quot;Direct read: $&#123;booking?.content&#125;&quot;</span><br>&#125;<br><br><span class="hljs-comment">//First read: A</span><br><span class="hljs-comment">//Data updated to: B</span><br><span class="hljs-comment">//new Transaction Read:B</span><br><span class="hljs-comment">//Direct read: B ( 照理來說應該是A 因為多次讀取都應該是同一個值。可能是Grails的行為？)</span><br><br></code></pre></td></tr></table></figure><p>Q: 確認是否因為同一個交易的Transaction導致Hibernate緩存改變</p><p>A: 拆開</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MeetingTestService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span><br>    def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">MeetingRoomBooking</span> <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br>        Thread.sleep(<span class="hljs-number">10000</span>)<br>        MeetingRoomBooking.withNewSession &#123;<br>            booking = MeetingRoomBooking.get(id)<br>            println <span class="hljs-string">&quot;new Transaction Read:$&#123;booking?.content&#125;&quot;</span><br>        &#125;<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;Direct read: $&#123;booking?.content&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">//Update to 2</span><br><span class="hljs-comment">// 2 (因為已經commit，值已經改變)</span><br><span class="hljs-comment">// 1 (確認來自Hibernate快取，符合可重複讀特性)</span><br><br></code></pre></td></tr></table></figure><p>嘗試降隔離層級</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MeetingTestService</span> &#123;<br>    <span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br>    def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>        MeetingRoomBooking <span class="hljs-type">booking</span><br>        <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br>        Thread.sleep(<span class="hljs-number">10000</span>)<br>        MeetingRoomBooking.withNewSession &#123;<br>            booking = MeetingRoomBooking.get(id)<br>            println <span class="hljs-string">&quot;new Transaction Read:$&#123;booking?.content&#125;&quot;</span><br>        &#125;<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;Direct read: $&#123;booking?.content&#125;&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//1 依然受Hibernate緩存影響</span><br><br></code></pre></td></tr></table></figure><p>如果清除Hibernate快取呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">SessionFactory sessionFactory<br>    <span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span><br>    def <span class="hljs-title function_">readData</span><span class="hljs-params">(Long id)</span> &#123;<br>        MeetingRoomBooking <span class="hljs-type">booking</span><br>        <span class="hljs-variable">booking</span> <span class="hljs-operator">=</span> MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;First read: $&#123;booking?.content&#125;&quot;</span><br>        Thread.sleep(<span class="hljs-number">10000</span>)<br>        MeetingRoomBooking.withNewSession &#123;<br>            booking = MeetingRoomBooking.get(id)<br>            println <span class="hljs-string">&quot;new Transaction Read:$&#123;booking?.content&#125;&quot;</span><br>        &#125;<br>        sessionFactory.currentSession.clear()<br>        booking = MeetingRoomBooking.get(id)<br>        println <span class="hljs-string">&quot;Direct read: $&#123;booking?.content&#125;&quot;</span><br>  &#125;<br><span class="hljs-comment">// A</span><br><span class="hljs-comment">// Update to B</span><br><span class="hljs-comment">// B</span><br><span class="hljs-comment">// B (正確，如果有改變，就使用改變後的值)</span><br></code></pre></td></tr></table></figure><p>大概測試是這樣</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ol><li>Hibernate 的一級緩存機制會影響資料讀取的行為</li><li>要讀取最新資料，可以：<ul><li>使用 withNewSession</li><li>清除當前 Session 緩存</li></ul></li><li>在使用 READ_COMMITTED 隔離層級時，需要特別注意緩存的影響</li><li>使用獨立 Session 進行修改可以確保資料立即提交</li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hibernate</tag>
      
      <tag>Grails</tag>
      
      <tag>Isolation Level</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot Test</title>
    <link href="/2025/01/08/SpringBoot-Test/"/>
    <url>/2025/01/08/SpringBoot-Test/</url>
    
    <content type="html"><![CDATA[<p>在開發完你的應用程式後，儘管非必要，但許多人都建議要撰寫測試去確保功能是可以正常運作的。 ( TDD 甚至主張 測試撰寫要在 開發之前 )，不論你是在開發前撰寫測試或是在開發後才寫測試，我都認為測試是重要且不可少的。</p><p>對我來說，撰寫測試的主要好處是建立信心，一個覆蓋率高的測試案例，可以讓我更大膽地針對程式碼進行重構，改完後也不需要重新撰寫測試(或者撰寫少量)。他可以帶來的好處是非當下的，也就是說當下撰寫本身沒有辦法產生效益，也有些公司覺得無法產生效益而不做。但無論如何，了解概念都是重要的。</p><p>本回會使用SpringBootTest撰寫測試。主要要介紹的測試有三種：</p><ol><li>單元測試 UNIT TEST</li><li>整合測試 INTEGER TEST</li><li>端對端測試 END TO END TEST</li></ol><p>單元測試 中的 單元 ，意味著程式中最小的一個單位，也就是方法，單元測試主要用來確保一個被撰寫好的方法，是否正常運作。舉例來說以下有一個Member的驗證方法，我撰寫了一個假資料來確保這樣的資料結構是否足夠通過驗證。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AioApiApplicationTests</span> &#123;<br><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUnitsTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Member</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> Member.builder()<br>                .name(<span class="hljs-string">&quot;Clark&quot;</span>)<br>                .account(<span class="hljs-string">&quot;clark1232&quot;</span>)<br>                .password(<span class="hljs-string">&quot;cclark23123&quot;</span>)<br>                .email(<span class="hljs-string">&quot;test@gmail.con&quot;</span>)<br>                .address(<span class="hljs-string">&quot;台北&quot;</span>).build();<br>        assertTrue(Member.registerValidate(member));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整合測試的層級比單元測試高，整合測試主要著重的是在確保當下元件正常之外，與外部服務之間的互動也必須要符合預期結果，撰寫難度也因此比單元測試高。舉例來說，我想要去取得會員的資料並進行驗證，但MemberService同時依賴MemberRepository，所以如果我想測試他的話，我不只要初始化MemberService也要初始化MemberRepository。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MemberRepository memberRepository;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MemberService</span><span class="hljs-params">(MemberRepository repo)</span> &#123;<br>    <span class="hljs-built_in">this</span>.repository = repo;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Optional&lt;MemberPO&gt; <span class="hljs-title function_">findAccountById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> memberRepository.findById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>測試時，為了力求測試的準確度，我們希望會造成影響的變因越小越好，然後實際上，一個整合測試中經常性的依賴多個服務，針對多個服務都直接使用的話，開銷將會非常高。因此現在常見的做法是針對外部依賴採用假造(Mock)的形式完成。</p><p>那怎麼假造呢？這時就可以使用SpringBoot提供的Mockito去完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@MockBean</span><br>    MemberRepository memberRepository;<br>    <span class="hljs-meta">@Autowired</span><br>    MemberService memberService;<br><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">optionalTest2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MemberPO</span> <span class="hljs-variable">memberPOTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberPO</span>();<br>        memberPOTest.setStatus(<span class="hljs-string">&quot;INACTIVE&quot;</span>);<br>        Mockito.<span class="hljs-keyword">when</span>(memberRepository.findByAccount(Mockito.isNull())).thenReturn(memberPOTest);<br>        Optional&lt;MemberPO&gt; memberPO1 = memberService.findActiveAccount(<span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">assert</span> !memberPO1.isPresent();<br>    &#125;<br></code></pre></td></tr></table></figure><p>因為MemberPository是一個Bean，所以我引入了MockBean去假造它。此外，我使用了Mockito這個測試框架去模擬memberPository的行為，只要findByAccount方法中傳出了Null，就回傳一個我是先建立好的一個模擬物件(memberPOTest)</p><p>基本上Mockito的寫法是 Mockito.when(要被測試的方法).thenReturn(你預計的回傳內容)，透過這樣的方法可以在測試的@Test中覆蓋原先memberPosiory.findByAccount()的方法 ( 應該也是回傳Null，SpringBootTest 不會真的引入Bean )</p><p>最後，我們使用 assert 斷言去判斷memberPO 是否存在</p><p>最後，我們來看一下端對端測試吧。端對端測試我理解的就是API層級的測試，它包含了更多貼近商業情境的測試，也是測試上不好測試，經常會透過人工執行的測試。SpringBoot我經常使用Mockmvc來進行整合測試，舉例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span> <span class="hljs-comment">// 注意要額外定義@AutoConfigureMockMvc，否則無法使用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AioApiApplicationTests</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MockMvc mockMvc;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetMember</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">MemberPO</span> <span class="hljs-variable">memberPO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemberPO</span>();<br>    memberPO.setStatus(<span class="hljs-string">&quot;ACTIVE&quot;</span>);<br>    memberPO.setName(<span class="hljs-string">&quot;Clark&quot;</span>);<br>    Mockito.<span class="hljs-keyword">when</span>(memberRepository.findById(<span class="hljs-number">1L</span>)).thenReturn(Optional.ofNullable(memberPO));<br><br>    mockMvc.perform(get(<span class="hljs-string">&quot;/api/1.0/member&quot;</span>)<br>                    .param(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>                    .accept(MediaType.APPLICATION_JSON))<br>            .andExpect(status().isOk())<br>            .andExpect(content().contentType(MediaType.APPLICATION_JSON))<br>            .andExpect(jsonPath(<span class="hljs-string">&quot;$.info.name&quot;</span>).value(<span class="hljs-string">&quot;Clark&quot;</span>));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>這三種測試是我在初學階段時經常搞不清楚的，這次也趁著鐵人賽的機會一口氣把它們釐清，希望以上內容能幫助到什麼人。那今天的分享就到此為止了，我們明天見。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot Spring Validation介紹</title>
    <link href="/2025/01/07/SpringBoot-Spring-Validation%E4%BB%8B%E7%B4%B9/"/>
    <url>/2025/01/07/SpringBoot-Spring-Validation%E4%BB%8B%E7%B4%B9/</url>
    
    <content type="html"><![CDATA[<p>今天要介紹的是一個簡單卻實用的小工具──SpringBoot Validator，它可以協助我們做物件的驗證，減少物件建立後繁瑣的驗證邏輯，以下會介紹一些常用的方法。首先要使用的話我們要先引入依賴，如果是使用Maven的話可以參考以下程式碼：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;dependency&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>假設我們今天有一個交易的Object，我們希望在實際進入Controller前先驗證傳入值是否正確的話，可以看看以下舉例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionObject</span> &#123;<br>    <span class="hljs-meta">@Size(min = 10, max = 28, message = &quot;長度必須介於10~28之間&quot;)</span><br>    <span class="hljs-keyword">private</span> String transactionId;<br>    <span class="hljs-meta">@Email(regexp = &quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,&#125;$&quot;, message = &quot;Email格式不符合&quot;)</span><br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@NotBlank(message = &quot;Type is not exist&quot;)</span><br>    <span class="hljs-keyword">private</span> String transactionType;<br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@PositiveOrZero</span><br>    <span class="hljs-keyword">private</span> BigDecimal amount; <span class="hljs-comment">// 交易金额</span><br>    <span class="hljs-meta">@PastOrPresent</span><br>    <span class="hljs-keyword">private</span> LocalDateTime transactionDate;<br><br><span class="hljs-comment">// ... getter setter constructor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在TransactionObject中，<br>@Size會在物件建立時判斷transactionId是否在長度10<del>28之間，若不符合會報Excpetion，訊息為 長度必須介於10</del>28之間。<br>@Email 利用正規表達式驗證傳入email格式是否符合，若不符合就跳出錯誤訊息。</p><p>@NotBlank 類似於撰寫StringUtils.isNotBlank()，@NotNull則用來判斷是否不為Null</p><p>@PositiveOrZero 宣告了數值必須是正數或者0</p><p>@PastOrPresent 宣告了交易時間，必須是現在或者現在以前，因為不會有未來的交易。</p><p>以上，透過物件在建立的同時便完成驗證就是Spring Validator的特色。</p><p>通常他會在API Controller就被使用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TransactionService transactionService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TransactionController</span><span class="hljs-params">(TransactionService transactionService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transactionService = transactionService;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping(&quot;/payment&quot;)</span><br>    <span class="hljs-keyword">public</span> TransactionObject <span class="hljs-title function_">payment</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> TransactionObject transactionObject)</span> &#123;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> transactionService.payment(transactionObject);<br>        <span class="hljs-keyword">return</span> success ? transactionObject : <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中@Valid 代表了啟動物件驗證的方法，如果不符合就會直接拋出org.springframework.web.bind.MethodArgumentNotValidException，避免讓不合法的物件進入程式內部。</p><p>然而，在Controller作物件驗證有一個缺點，就是無法撰寫try catch，這部分要怎麼解決呢，我們明天在說明吧，感恩感謝。</p><p>參考資源：</p><p><a href="https://blog.csdn.net/Hello_World_QWP/article/details/116129788">Spring Boot中validation-api和hibernate-validator详解及快速应用实践，@Valid BindingResult实现接口入参自动检验，Java实体字段校验-CSDN博客</a></p><p><a href="https://www.baeldung.com/spring-boot-bean-validation">https://www.baeldung.com/spring-boot-bean-validation</a></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Hibernate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security探秘</title>
    <link href="/2025/01/05/Spring-Security%E6%8E%A2%E7%A7%98/"/>
    <url>/2025/01/05/Spring-Security%E6%8E%A2%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot引入Spring-Security做了什麼？"><a href="#SpringBoot引入Spring-Security做了什麼？" class="headerlink" title="SpringBoot引入Spring Security做了什麼？"></a>SpringBoot引入Spring Security做了什麼？</h3><p>Spring Boot 引入 Spring Security 後的預設行為：</p><ul><li>自動保護所有 endpoint</li><li>提供預設帳號 (user) 與隨機密碼</li><li>提供登入&#x2F;登出表單</li><li>未認證的請求會導向登入頁或回傳 401</li><li>提供多種安全防護機制:<ul><li>CSRF 防護</li><li>Session Fixation 防護</li><li>強制 HTTPS (HSTS)</li><li>防止內容類型嗅探</li><li>緩存控制</li><li>點擊劫持防護 (X-Frame-Options)</li></ul></li><li>使用 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-hsts">Strict-Transport-Security</a>確保是HTTPS，HSTS用於強制瀏覽器僅通過 HTTPS（而非 HTTP）訪問該網站</li><li>使用 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-content-type-options">X-Content-Type-Options</a> 以緩解 <a href="https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-content-type-options">sniffing attacks</a></li><li>使用 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-cache-control">Cache Control headers</a> that 保護授權後的資源，Cache-Control 和 Pragma 標頭用於指示瀏覽器或代理不要快取授權後的敏感資源，防止未經授權的用戶訪問緩存。</li><li>使用 <a href="https://docs.spring.io/spring-security/reference/servlet/exploits/headers.html#servlet-headers-frame-options">X-Frame-Options</a> 緩解 <a href="https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-frame-options">Clickjacking</a>，頭防止網頁內容被嵌入到 <code>&lt;iframe&gt;</code> 中，避免 Clickjacking 攻擊</li><li>與<code>HttpServletReqeust</code>的認證方法整合</li><li>發布成功認證與失敗認證訊息 (<code>AuthenticationSuccessHandler</code> 與 <code>AuthenticationFailureHandler</code> )</li></ul><h4 id="Session-Fixation攻擊模式介紹"><a href="#Session-Fixation攻擊模式介紹" class="headerlink" title="Session Fixation攻擊模式介紹"></a>Session Fixation攻擊模式介紹</h4><ol><li><strong>目標</strong>：<ul><li>攻擊者試圖固定用戶的會話ID，然後在用戶登錄後劫持會話。</li></ul></li><li><strong>方法</strong>：<ul><li>攻擊者需要事先將特定的會話ID注入到用戶的會話中。</li></ul></li><li><strong>SpringSecurity防禦措施</strong>：<ul><li>在用戶登錄後重新生成新的會話ID，使用安全屬性的cookie設置（例如HttpOnly、Secure）。</li></ul></li></ol><h4 id="CSRF攻擊模式介紹"><a href="#CSRF攻擊模式介紹" class="headerlink" title="CSRF攻擊模式介紹"></a>CSRF攻擊模式介紹</h4><ol><li><strong>目標</strong>：<ul><li>攻擊者利用用戶已經登錄的狀態，在未經用戶同意的情況下執行操作。</li></ul></li><li><strong>方法</strong>：<ul><li>攻擊者誘導用戶訪問惡意網站，然後利用用戶的瀏覽器發送請求。</li></ul></li><li><strong>SpringSecurity防禦措施</strong>：<ul><li>使用CSRF令牌（token），驗證請求來源的Referer頭，確保關鍵操作需要用戶確認（例如多因素認證）。</li></ul></li></ol><h3 id="Spring-Security基本設定步驟："><a href="#Spring-Security基本設定步驟：" class="headerlink" title="Spring Security基本設定步驟："></a>Spring Security基本設定步驟：</h3><h4 id="認證流程的重要元件："><a href="#認證流程的重要元件：" class="headerlink" title="認證流程的重要元件："></a>認證流程的重要元件：</h4><ul><li>AuthenticationManager: 負責認證流程</li><li>UserDetailsService: 載入使用者資訊</li><li>PasswordEncoder: 密碼編碼與驗證</li><li>SecurityContextHolder: 儲存認證信息</li><li>SecurityContext: 保存當前使用者的認證信息</li></ul><p>基本範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> &#123;<br>    <span class="hljs-comment">// 1. 配置使用者資訊</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> InMemoryUserDetailsManager <span class="hljs-title function_">userDetailsManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 建立使用者帳號、密碼、權限</span><br>       <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> User<br>               .withUsername(<span class="hljs-string">&quot;user1&quot;</span>)<br>               .password(<span class="hljs-string">&quot;&#123;noop&#125;111&quot;</span>)<br>               .authorities(<span class="hljs-string">&quot;STUDENT&quot;</span>)<br>               .build();<br>       <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> User<br>               .withUsername(<span class="hljs-string">&quot;user2&quot;</span>)<br>               .password(<span class="hljs-string">&quot;&#123;noop&#125;222&quot;</span>)<br>               .authorities(<span class="hljs-string">&quot;TEACHER&quot;</span>)<br>               .build();<br>       <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user3</span> <span class="hljs-operator">=</span> User<br>               .withUsername(<span class="hljs-string">&quot;user3&quot;</span>)<br>               .password(<span class="hljs-string">&quot;&#123;bcrypt&#125;333&quot;</span>)<br>               .authorities(<span class="hljs-string">&quot;ADMIN&quot;</span>, <span class="hljs-string">&quot;TEACHER&quot;</span>)<br>               .build();<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryUserDetailsManager</span>(List.of(user1, user2, user3));<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 配置安全過濾器鏈</span><br>    <span class="hljs-meta">@Bean</span> <br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> &#123;<br>        <span class="hljs-keyword">return</span> http<br>            .authorizeRequests() <span class="hljs-comment">// 設定訪問權限</span><br>            .formLogin()        <span class="hljs-comment">// 啟用表單登入</span><br>            .httpBasic()       <span class="hljs-comment">// 啟用 HTTP Basic 認證</span><br>            .build();<br>    &#125;<br>    <span class="hljs-comment">// OR</span><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">securityFilterChain</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">return</span> httpSecurity<br>              .formLogin(Customizer.withDefaults())<br>              .authorizeHttpRequests(requests -&gt; requests<br>                      .requestMatchers(HttpMethod.GET, <span class="hljs-string">&quot;/register&quot;</span>).permitAll()<br>                      .requestMatchers(HttpMethod.GET, <span class="hljs-string">&quot;/selected-courses&quot;</span>).hasAuthority(<span class="hljs-string">&quot;STUDENT&quot;</span>)<br>                      .requestMatchers(HttpMethod.GET, <span class="hljs-string">&quot;/course-feedback&quot;</span>).hasAnyAuthority(<span class="hljs-string">&quot;TEACHER&quot;</span>, <span class="hljs-string">&quot;ADMIN&quot;</span>)<br>                      .requestMatchers(HttpMethod.GET, <span class="hljs-string">&quot;/members&quot;</span>).hasAuthority(<span class="hljs-string">&quot;ADMIN&quot;</span>)<br>                      .anyRequest().authenticated()<br>              )<br>              .csrf(csrf -&gt; csrf.disable())<br>              .build();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這裡註冊了一個SecurityFilterChain，定義它們要開放給具有哪些權限的人存取。<br>Spring Security 會將 HttpSecurity 物件注入到建立元件的方法中。透過該物件的一系列方法呼叫，我們能站在安全管理的角度，自定義 request 到達後端時的應對方式。<br>一開始的 formLogin 方法，是啟用先前的登入畫面，便於我們繼續進行測試。<br>接下來的 authorizeHttpRequests 方法，其用途是設定要如何進行授權。定義時，需提供「API」與「授權規則」這兩個部份。<br>呼叫 requestMatchers 方法，可傳入 API 路徑與 HTTP 方法；呼叫 anyRequests 方法，代表要對「其餘」的 API 做設定。這是有先後順序之分的，就像 Java 語言的「if → else if → else」，是由上而下逐一判斷。<br>提供完 API 後，接著要定義授權規則。以下舉例幾個可用的方法：</p><table><thead><tr><th>方法名稱</th><th>意義</th></tr></thead><tbody><tr><td>permitAll</td><td>不必登入就能存取。</td></tr><tr><td>hasAuthority</td><td>需具備某一個權限才能存取。</td></tr><tr><td>hasAnyAuthority</td><td>只要具備任一個權限就能存取。</td></tr><tr><td>authenticated</td><td>需登入才能存取。</td></tr></tbody></table><p>看 <code>InMemoryUserDetailsManager</code> 類別的原始碼，會發現它頂層實作了 <code>UserDetailsService</code> 介面。該介面是 Spring Security 用來進行認證的重要元件。它提供一個叫做 <code>loadUserByUsername</code> 的方法，用途是接收帳號的值，並回傳內含使用者資料的 <code>UserDetails</code> 介面物件。繼續追蹤 <code>InMemoryUserDetailsManager</code> 的原始碼，會發現它是用 <code>Map</code> 資料結構來儲存使用者。<br>啟動程式時，Spring Security 會檢查專案中是否有 <code>UserDetailsService</code> 元件。若無，則自動建立一個 <code>InMemoryUserDetailsManager</code> 元件，並包含一個帳號為「user」、密碼為隨機（可在 console 找到）的使用者。<br>權限資料是透過 <code>GrantedAuthority</code> 介面來傳遞。Spring Security 內建了一個叫做 <code>SimpleGrantedAuthority</code> 的實作類別。</p><p>認證方式還有許多變形，例如：</p><h4 id="HTTP-BASIC-Not-Http-Form"><a href="#HTTP-BASIC-Not-Http-Form" class="headerlink" title="HTTP_BASIC (Not Http Form)"></a>HTTP_BASIC (Not Http Form)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// OR</span><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">securityFilterChain</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">return</span> httpSecurity<br>              .authorizeHttpRequests(requests -&gt; requests<br>                      .requestMatchers(HttpMethod.GET, <span class="hljs-string">&quot;/home&quot;</span>).permitAll()<br>                      .requestMatchers(HttpMethod.POST, <span class="hljs-string">&quot;/select-course&quot;</span>).hasAuthority(<span class="hljs-string">&quot;STUDENT&quot;</span>)<br>                      .requestMatchers(HttpMethod.PUT, <span class="hljs-string">&quot;/courses&quot;</span>).hasAuthority(<span class="hljs-string">&quot;TEACHER&quot;</span>)<br>                      .anyRequest().authenticated()<br>              )<br>              .csrf(csrf -&gt; csrf.disable())<br>              .httpBasic(Customizer.withDefaults())<br>              .build();<br>   &#125;<br></code></pre></td></tr></table></figure><p>Spring Security 支援一種叫做「HTTP Basic」的認證方式。其做法是在「Authorization」這個 request header 攜帶帳號與密碼，就像在登入畫面輸入帳密一樣。而後端會在每次接收到 request 時，就先進行認證。</p><p>透過上面內容，我們已經知道Spring Security提供了甚麼安裝防護，以及註冊User的過程。那假設我們想要在API取得有關User的資料的話，可以這麼做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@GetMapping(&quot;/home&quot;)</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();<br>      <span class="hljs-type">Authentication</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> context.getAuthentication();<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">principal</span> <span class="hljs-operator">=</span> auth.getPrincipal(); <span class="hljs-comment">// 取得Spring Security User，若無顯示anonymousUser</span><br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;anonymousUser&quot;</span>.equals(principal)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;你尚未經過身份認證&quot;</span>;<br>      &#125;<br>      <br>      <span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> (UserDetails) principal;<br>      <span class="hljs-keyword">return</span> String.format(<br>              <span class="hljs-string">&quot;你好，%s，你的權限是：%s&quot;</span>,<br>              userDetails.getUsername(),<br>              userDetails.getAuthorities()<br>      );<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring Security 是透過 Java Servlet 的「Filter」，才能在 request 到達 Controller 前進行認證與授權。其中 <code>BasicAuthenticationFilter</code> 是專門處理 HTTP Basic 認證的 Filter。<br>Filter 接收到 request 後，首先 <code>AuthenticationConverter</code> 會從 <code>HttpServletRequest</code> 取出「Authorization」這個 header 的值，進行 Base64 解碼。解析出帳密後，封裝成 <code>Authentication</code> 物件。<br>而 <code>AuthenticationConverter</code> 介面的實作類別是 <code>BasicAuthenticationConverter</code>，它會回傳 <code>Authentication</code> 介面的實作類別 <code>UsernamePasswordAuthenticationToken</code>。解析出的帳號，會放在 <code>UsernamePasswordAuthenticationToken</code> 物件的 <code>principal</code> 欄位，而密碼放在 <code>credentials</code> 欄位。<br><img src="/img/spring_security_1.jpg" alt="AuthenticationConverter"></p><h3 id="AuthenticationManager-進行認證"><a href="#AuthenticationManager-進行認證" class="headerlink" title="AuthenticationManager 進行認證"></a>AuthenticationManager 進行認證</h3><p>將帳號與密碼的值封裝成 <code>Authentication</code> 介面的物件後，接下來 <code>AuthenticationManager</code> 會進行身份認證，並回傳另一個新的 <code>Authentication</code> 物件。兩個物件的差別在於，新物件會包含認證後的結果，即使用者資料。<br>另外，這個 <code>AuthenticationManager</code> 介面，有個實作類別叫做 <code>ProviderManager</code>，它擁有多個 <code>AuthenticationProvider</code> 介面的物件，讀者可理解成「認證功能的提供者」。<br><img src="/img/spring_security_2.jpg" alt="AuthenticationConverter"><br>在 HTTP Basic 認證的情況下，會由 <code>DaoAuthenticationProvider</code> 提供認證功能。它接收 <code>Authentication</code> 物件後，使用了 <code>UserDetailsService</code> 與 <code>PasswordEncoder</code> 進行帳號與密碼的認證。</p><p>認證成功後，<code>DaoAuthenticationProvider</code> 會將 <code>UserDetailsService</code> 回傳的 <code>UserDetails</code> 放入 <code>UsernamePasswordAuthenticationToken</code> 物件的 <code>principal</code> 欄位中，並以 <code>Authentication</code> 介面回傳。</p><h3 id="SecurityContextHolderStrategy-管理認證資訊"><a href="#SecurityContextHolderStrategy-管理認證資訊" class="headerlink" title="SecurityContextHolderStrategy 管理認證資訊"></a>SecurityContextHolderStrategy 管理認證資訊</h3><p>Spring Security 會將認證後的使用者資料儲存於記憶體，讓我們在程式邏輯中能使用。就像在 Controller 的範例程式取出 <code>UserDetails</code> 物件那樣。<br>負責管理認證資訊的是 <code>SecurityContextHolder</code> 中的 <code>SecurityContextHolderStrategy</code>。後者是一個介面，代表管理的「策略」，Spring Security 內建數種實作好的策略。<br>而前者是一個類別，會在啟動程式時選擇其中一種管理策略。除此之外，就只是對外提供存取認證資訊的方法罷了。<br><img src="/img/spring_security_3.jpg" alt="AuthenticationConverter"><br>預設的管理策略是 <code>ThreadLocalSecurityContextHolderStrategy</code>，它採用了「ThreadLocal」的技術，讓每個執行緒只能取得屬於自己的資料。因此，即便 Spring Boot 同時處理許多 request，但並不會意外地取得他人的認證資訊。<br>回到 Filter 的邏輯。接下來會產生一個 <code>SecurityContext</code> 介面的物件，將認證後的 <code>Authentication</code> 物件封裝起來。<br>最後將 <code>SecurityContext</code> 存回 <code>SecurityContextHolderStrategy</code>，就完成 HTTP Basic 認證的流程。</p><p>認證方法有很多種，除了HTTP_BASIC，也可以考慮安全性更高的JWT Token 或是 Oauth。以下僅介紹JWT<br>JWT是一種特殊的Token格式，主要由</p><ul><li>Header (類型、演算法)</li><li>Payload (聲明資訊)</li><li>Signature (簽名)<br>三個部分形成，實務上則有兩種形式</li><li>Access Token 用戶存取 API 時會攜帶於 request header，證明自己的身份。為了安全性，其有效期限較短，例如 1 小時。因此若外洩，則盜用者也無法使用太久的時間</li><li>Refresh Token 在換發新的 Access Token 時提供。有效期限較長，例如 7 天。</li></ul><p>透過 Refresh Token，就能在不重新登入的條件下，取得新的 Access Token，有助於使用者體驗。等到 Refresh Token 到期，就真的要重新登入，取得以上 2 種 Token 了。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Security</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎的SpringBoot小知識</title>
    <link href="/2025/01/05/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84SpringBoot%E5%B0%8F%E7%9F%A5%E8%AD%98/"/>
    <url>/2025/01/05/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84SpringBoot%E5%B0%8F%E7%9F%A5%E8%AD%98/</url>
    
    <content type="html"><![CDATA[<p>這邊的是提到許多一個個SpringBoot的小知識，內容沒有多到可以變成一篇文章，所以整理在這裡：</p><h2 id="Spring-Bean-模式"><a href="#Spring-Bean-模式" class="headerlink" title="Spring Bean 模式"></a>Spring Bean 模式</h2><p>Spring Bean 有Singleton、Prototype模式</p><ul><li>Singleton 只有一個，每次作為Bean被呼叫時，都是使用同一個Bean。生命週期從容器啟動到第一次被請求而實體化開始，只要容器不銷毀或終止，這類的Bean就會一直存活。</li><li>原型 可有多個，每次作為Bean被呼叫時，都重新初始化，定義出一個新的Bean，再請求完成後便無法引用，請求方須要自己負責後續生命週期的管理工作，包括銷毀等等。</li><li>Spring Bean 默認是 單例模式。</li></ul><h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h2><ul><li>JPA的查詢語言是物件導向而非面向資料庫的，它以物件導向的自然語法構造查詢語句，可以看成是Hibernate HQL的等價物。</li><li>JPA定義了獨特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一種擴展，它操作對象是實體，而不是關聯資料庫的表。</li><li>它而且能夠支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能夠提供的高級查詢特性，甚至還能夠支持子查詢。</li></ul><h2 id="Spring-Bean-掃描功能"><a href="#Spring-Bean-掃描功能" class="headerlink" title="Spring Bean 掃描功能"></a>Spring Bean 掃描功能</h2><ul><li>為了能 Spring 能自動掃描 Bean 的存在，可以使用<code>@ComponentScan</code>，如此 Spring 預設會自動掃描同一套件以及其子套件下，是否有 Bean 元件的存在。</li></ul><h2 id="RestTemplate的妙用"><a href="#RestTemplate的妙用" class="headerlink" title="RestTemplate的妙用"></a>RestTemplate的妙用</h2><p>你可以使用RestTemplate發送request，並強行把回傳的string內容轉換成想要的Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RespInfo <span class="hljs-title function_">SendRequest</span><span class="hljs-params">(Fundmentals funds, String body)</span> &#123;<br>        <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>(); <span class="hljs-comment">// 請求 Header</span><br>        headers.setContentType(MediaType.APPLICATION_JSON);<br>        headers.setAccept(Arrays.asList(MediaType.TEXT_PLAIN, MediaType.APPLICATION_JSON));<br>        headers.set(<span class="hljs-string">&quot;Ocp-Apim-Subscription-Key&quot;</span>, funds.getApiKey());<br>        HttpEntity&lt;String&gt; httpEntity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntity</span>&lt;&gt;(body, headers);<br><br>        <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">mappingJackson2HttpMessageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>();<br>        mappingJackson2HttpMessageConverter.setSupportedMediaTypes(Collections.singletonList(MediaType.TEXT_PLAIN)); <span class="hljs-comment">// OP Response Header 為 text/plain RestTemplate 預設 為 application/json (允許接受text/plain)</span><br><br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplateBuilder</span>()<br>                .setConnectTimeout(<span class="hljs-number">22000</span>)<span class="hljs-comment">// 連接Timeout單位毫秒</span><br>                .setReadTimeout(<span class="hljs-number">25000</span>) <span class="hljs-comment">// 讀取Timeout 單位毫秒</span><br>                .build();<br><br>        restTemplate.getMessageConverters().add(mappingJackson2HttpMessageConverter);<span class="hljs-comment">// 調整可接收的 MediaType 不加會爆炸</span><br><br>        <span class="hljs-keyword">return</span> restTemplate<br>                .exchange(funds.getAccessUrl(), HttpMethod.POST, httpEntity, RespInfo.class)<br>                .getBody();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="String-特性"><a href="#String-特性" class="headerlink" title="String 特性"></a>String 特性</h2><ul><li>String 是不可變的，每次對String的操作都會產生新的String物件，建議使用StringBuffer或StringBuilder。</li><li>當中StringBuffer是執行緒安全的，StringBuilder是非執行緒安全的，在單一執行緒下使用為好。</li></ul><h2 id="Controller-與-RestController"><a href="#Controller-與-RestController" class="headerlink" title="@Controller 與 @RestController"></a>@Controller 與 @RestController</h2><ul><li>差別就在於是否包含視圖(View)</li></ul><h2 id="IOC-控制反轉。"><a href="#IOC-控制反轉。" class="headerlink" title="IOC 控制反轉。"></a>IOC 控制反轉。</h2><ul><li>指的是一種Spring的開發模式，不是由你去掌控流程，而是由框架去掌控流程。</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>Target是針對Spring Bean的定義，用來告訴Java你的Annotation是想要標記在哪一些元素類別上，包括 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, ANNOTATION_TYPE 等等…。在一般來說，我們最常用的應該也是有列出來的這些，像是 TYPE 其實就包括了我們常用的 Class, Interface, Enum 了。</p><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>Retention是針對Spring Bean的定義，主要有以下三種策略：SOURCE, CLASS (default), RUNTIME。</p><ul><li>SOURCE 的意思就是你所使用的註解在 compile 後會被丟掉，如果要以最簡單的看法去理解這件事，可以看 IDE 在幫你 compile 後的 target 資料夾，會發現 <code>@Data</code> 的標記不見了，反而多了很多 Getter Setter。</li><li>另外 CLASS 與 RUNTIME 的差別就在 VM 是否會記得你所寫的 Annotation，只有後者能夠透過reflection 去存取與使用元件。所以一般你若是需要進行一些業務邏輯的處理時，則都會宣告<code>ElementType.RUNTIME</code></li></ul><h2 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h2><p>如果說 interface 是一個給 implemented class 的介面，那 @interface 就是一個給 Annotation 互動的介面，因此所有的 Annotation 在宣告時都需要使用 @interface。並且在現在會有越來越多人不想寫 Comment，反而透過這種方式寫註解。</p><h2 id="RepositoryRestResource"><a href="#RepositoryRestResource" class="headerlink" title="@RepositoryRestResource"></a>@RepositoryRestResource</h2><p>是 Spring Data REST 提供的註解，用於自動將 Spring Data Repositories 曝露為 RESTful Web API。也就是說會自動生成Entity的Rest API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RepositoryRestResource(path = &quot;books&quot;, collectionResourceRel = &quot;bookList&quot;, itemResourceRel = &quot;bookItem&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Book, Long&gt; &#123;<br>    <span class="hljs-comment">// 可以自定義查詢方法</span><br>    List&lt;Book&gt; <span class="hljs-title function_">findByAuthor</span><span class="hljs-params">(String author)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>將會自動生成</p><ul><li>GET &#x2F;books：獲取所有書籍的集合。 </li><li>GET &#x2F;books&#x2F;{id}：根據 ID 獲取單個書籍。 </li><li>POST &#x2F;books：新增一本書。 </li><li>PUT &#x2F;books&#x2F;{id}：更新一本書（完整更新）。 </li><li>PATCH &#x2F;books&#x2F;{id}：部分更新一本書。 </li><li>DELETE &#x2F;books&#x2F;{id}：刪除一本書。</li></ul><h2 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h2><p>ServerSocket是Java最底層建立網路伺服器的基本概念，Server端透過Socket建立監聽，並持續等待Client的Request，使用Accept()取得Socket物件，就可以與Client端進行對話與取得資訊，接著就是IO的讀寫，最後釋放Socket資源。</p><p><img src="/img/ServerSocket.png" alt="ServerSocket圖示"></p><p>想自己動手做可以參考以下範例程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定義埠號</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">serverPort</span> <span class="hljs-operator">=</span> <span class="hljs-number">5001</span>;<br><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">receiveMsgSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">byte</span>[] receiveBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">32</span>];<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 建立 ServerSocket</span><br>            serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(serverPort);<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;服務已經啟動，port: &quot;</span> + serverPort);<br><br>                <span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">clientAddress</span> <span class="hljs-operator">=</span> clientSocket.getRemoteSocketAddress();<br>                System.out.println(<span class="hljs-string">&quot;收到客戶端連線, ip: &quot;</span> + clientAddress);<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> clientSocket.getInputStream();<br>                <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> clientSocket.getOutputStream();<br><br>                <span class="hljs-keyword">while</span>((receiveMsgSize = in.read(receiveBuffer)) != -<span class="hljs-number">1</span>) &#123;<br>                    out.write(<span class="hljs-string">&quot;伺服器回應: &quot;</span>.getBytes());<br>                    out.write(receiveBuffer, <span class="hljs-number">0</span>, receiveMsgSize);<br>                &#125;<br>                <span class="hljs-comment">// 釋放 Socket 資源</span><br>                clientSocket.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringBoot-Validation"><a href="#SpringBoot-Validation" class="headerlink" title="SpringBoot Validation"></a>SpringBoot Validation</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;dependency&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>在ObjectMapper進行序列化轉換時，有些方便工具</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;dependency&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NotEmpty(message = &quot;Product name is undefined.&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-comment">// 在 Java 物件的欄位加上 @JsonProperty 標記，可以調整序列化為 JSON 的欄位名稱。</span><br><span class="hljs-meta">@JsonProperty(&quot;telephone&quot;)</span><br><span class="hljs-keyword">private</span> String tel;<br><br><span class="hljs-comment">// 在 Java 物件的欄位加上 @JsonIgnore 標記，可以在序列化為 JSON 時忽略該欄位，連 null 值都不會出現</span><br><span class="hljs-meta">@JsonIgnore</span><br><span class="hljs-keyword">private</span> String isbn;<br><br><span class="hljs-comment">// 在 Java 物件的物件欄位加上 @JsonUnwrapped 標記，可以在序列化為 JSON 時，將該欄位展開。</span><br><span class="hljs-meta">@JsonUnwrapped</span><br><span class="hljs-keyword">private</span> Publisher publisher;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;開始載入&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;完成，將銷毀&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-Filter"><a href="#Spring-Filter" class="headerlink" title="Spring Filter"></a>Spring Filter</h2><p>有時我們的SpringBoot應用程式會想要對API進入口之前做一些前處理，這時候不僅可以考慮Spring AOP，也可以使用Filter，以下是實現的程式碼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProcessTimeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OncePerRequestFilter</span> &#123;<br>    <span class="hljs-comment">// 紀錄API耗費時間</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    chain.doFilter(request, response);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">processTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;<br><br>    System.out.println(processTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>實作完 Filter 的程式後，需要向 Spring 註冊，才會建立它的元件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">logProcessTimeFilter</span><span class="hljs-params">()</span> &#123;<br>        FilterRegistrationBean&lt;LogProcessTimeFilter&gt; bean = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>        bean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogProcessTimeFilter</span>());<br>        bean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        bean.setName(<span class="hljs-string">&quot;logProcessTimeFilter&quot;</span>);<br><br>    <span class="hljs-comment">//bean.setOrder(1); //多個存在可以設置順序 </span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>FilterRegistrationBean 是 Spring 提供的工具，用於註冊 Filter 並配置其屬性：</p><ul><li>setFilter()：設置具體的 Filter。 </li><li>addUrlPatterns()：指定哪些路徑會被該 Filter 攔截。 </li><li>setOrder()：設置該 Filter 的執行順序（可選）多filter時用來排序處理。</li></ul><h2 id="Spring-Exception處理"><a href="#Spring-Exception處理" class="headerlink" title="Spring Exception處理"></a>Spring Exception處理</h2><p>當你的API報錯回復你的自定義Exception時，可以為它加入指定的錯誤代碼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ItemNotFoundException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>為你的自定義Exception捕捉異常並處理回傳</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(OperateAbsentItemsException.class)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;ExceptionResponse&gt; <span class="hljs-title function_">handleOperateAbsentItem</span><span class="hljs-params">(OperateAbsentItemsException e)</span> &#123;<br>    Map&lt;String, Object&gt; info = Map.of(<span class="hljs-string">&quot;itemIds&quot;</span>, e.getItemIds());<br>    <span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionResponse</span>();<br>    res.setType(BusinessExceptionType.OPERATE_ABSENT_ITEM);<br>    res.setInfo(info);<br><br>    <span class="hljs-keyword">return</span> ResponseEntity.unprocessableEntity().body(res); <span class="hljs-comment">// HTTP 422</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外還可以使用Global的Exception處理Annotation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice(assignableTypes = &#123;ProductController.class, UserController.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralAdvice</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CustomDateEditor</span> <span class="hljs-variable">customDateEditor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDateEditor</span>(CommonUtil.sdf, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ToSearchTextEditor</span> <span class="hljs-variable">toSearchTextEditor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToSearchTextEditor</span>();<br><br>    <span class="hljs-comment">// 異常處理方法</span><br>    <span class="hljs-meta">@ExceptionHandler(OperateAbsentItemsException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;ExceptionResponse&gt; <span class="hljs-title function_">handleOperateAbsentItem</span><span class="hljs-params">(OperateAbsentItemsException e)</span> &#123;<br>        Map&lt;String, Object&gt; info = Map.of(<span class="hljs-string">&quot;itemIds&quot;</span>, e.getItemIds());<br>        <span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionResponse</span>();<br>        res.setType(BusinessExceptionType.OPERATE_ABSENT_ITEM);<br>        res.setInfo(info);<br><br>        <span class="hljs-keyword">return</span> ResponseEntity.unprocessableEntity().body(res);<br>    &#125;<br><br>    <span class="hljs-comment">// 綁定自定義屬性編輯器</span><br>    <span class="hljs-meta">@InitBinder(&#123;&quot;createdFrom&quot;, &quot;createdTo&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindDate</span><span class="hljs-params">(WebDataBinder binder)</span> &#123;<br>        binder.registerCustomEditor(Date.class, customDateEditor);<br>    &#125;<br><br>    <span class="hljs-meta">@InitBinder(&#123;&quot;name&quot;, &quot;email&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindSearchText</span><span class="hljs-params">(WebDataBinder binder)</span> &#123;<br>        binder.registerCustomEditor(String.class, toSearchTextEditor);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToSearchTextEditor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PropertyEditorSupport</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAsText</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> CommonUtil.toSearchText(text);<br>        <span class="hljs-built_in">super</span>.setValue(t);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toSearchText</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(s)<br>            .map(String::trim)<br>            .map(String::toLowerCase)<br>            .orElse(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SpringMVC-ModelAttribute"><a href="#SpringMVC-ModelAttribute" class="headerlink" title="SpringMVC @ModelAttribute"></a>SpringMVC @ModelAttribute</h2><ol><li>用來Controller上，執行home()前先執行top()把資料放到model中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;top&quot;)</span><br><span class="hljs-keyword">public</span> Map <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> pageTop.getDataMap();<br>&#125;<br><span class="hljs-meta">@ReqeustMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">(<span class="hljs-meta">@Reqeust(require=true)</span> Map&lt;String,Object&gt; params,Model model)</span> &#123;<br>    model.addAttriute(<span class="hljs-string">&quot;model&quot;</span>,dataAssembly.homePageData(params));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>用來方法的參數中，這種用法會將 Model 中 key 為 “top” 的值注入到這個參數中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute(&quot;top&quot;)</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 假設這裡是從某個服務中獲取資料並放到 model 中</span><br>    <span class="hljs-keyword">return</span> pageTop.getDataMap();<br>&#125;<br><span class="hljs-meta">@ReqeustMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;top&quot;)</span> Map top,Model model)</span> &#123;<br>    <span class="hljs-type">JsonArray</span> <span class="hljs-variable">js</span> <span class="hljs-operator">=</span> JSONArray.fromObject(map);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java-Stream-vs-ParallelStream"><a href="#Java-Stream-vs-ParallelStream" class="headerlink" title="Java Stream vs ParallelStream"></a>Java Stream vs ParallelStream</h2><p>Java Stream執行是串行的，但ParallelStream是並行的，也就是多執行緒。<br>Stream是對集合資料類型是順序執行的，但ParallelStream則是隨機執行的<br>比方說以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Lists.newArrayList();<br>List&lt;String&gt; strList = Lists.newArrayList();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">practicalSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; practicalSize; i++) &#123;<br>    strList.add(String.valueOf(i));<br>&#125;<br><br>strList.parallelStream().forEach(each -&gt; &#123;<br>    integerList.add(Integer.parseInt(each));<br>&#125;);<br><br>System.out.println(strList.size()); <span class="hljs-comment">// 1000000</span><br>System.out.println(integerList.size()); <span class="hljs-comment">// 因為平行化的緣故，幾乎不可能是1000000</span><br></code></pre></td></tr></table></figure><p>應該要把資料型態改用SychronizeList或是Vector來處理多執行緒問題。<br>使用ParallelStream應該要考慮</p><ol><li>是否真正需要並行？</li><li>Task是否彼此獨立不受影響？</li><li>是否有順序執行需求？</li></ol><h2 id="副作用-Side-Effect-是什麼？"><a href="#副作用-Side-Effect-是什麼？" class="headerlink" title="副作用(Side Effect) 是什麼？"></a>副作用(Side Effect) 是什麼？</h2><p>在操作物件當中，無意間改變了物件的值或是型別。</p><h2 id="記憶體洩漏-Memory-Leak-是什麼？"><a href="#記憶體洩漏-Memory-Leak-是什麼？" class="headerlink" title="記憶體洩漏(Memory Leak) 是什麼？"></a>記憶體洩漏(Memory Leak) 是什麼？</h2><ul><li>當一個程式被編譯成bytecode，在框架下運行的話，框架可以協助自動處理momery allocation, security, exception, GC等問題。</li><li>若沒有框架處理，就必須要手動處理這些問題，沒有把取用的記憶體全部釋放就會導致Memory leak。</li><li>一般程式來說，只要process結束後記憶體就會被虛擬機(JVM)全部釋放，不會有這個問題。</li><li>C&#x2F;C++ 因為沒有GC，所以經常出現。另外像是EventListener() 只移除了裡面的元素卻沒有移除Listener()也會造成。另外還有循環引用與存取全域變數。</li></ul><h2 id="循環引用-Circular-Import"><a href="#循環引用-Circular-Import" class="headerlink" title="循環引用 (Circular Import)"></a>循環引用 (Circular Import)</h2><p>物件A參照到B，B又參照到A，就會造成循環引用，會造成記憶體洩漏，同時GC也會無法正常運行(Java除外)。</p><p>不時更新…</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>簡單說明SOLID法則</title>
    <link href="/2025/01/04/%E7%B0%A1%E5%96%AE%E8%AA%AA%E6%98%8ESOLID%E6%B3%95%E5%89%87/"/>
    <url>/2025/01/04/%E7%B0%A1%E5%96%AE%E8%AA%AA%E6%98%8ESOLID%E6%B3%95%E5%89%87/</url>
    
    <content type="html"><![CDATA[<p>作為一名後端工程師，我們常聽過不少開發上的規範，比方說常見的</p><ul><li>DRY原則──指的是Don’t repeat yourself.，不要重複寫同樣的內容。</li><li>KISS原則──指開發的產品程式碼應該要越簡單越好，簡單的好處不僅可以降低錯誤的發生率，也帶來較好維護、好理解、好測試等等優點。</li></ul><p>但我們這次要提到的不是以上這兩個，而是SOLID。<br>SOLID是一名後端工程師在成長的過程中一定會聽到的單字，特別指物件導向設計的設計原則，SOLID的目的是使軟體設計更為便於理解、更便於修改、而且更好維護的五項設計原則。我們就一起來看看他們吧。</p><h3 id="S-單一職責原則-Single-Responsibility-Principle"><a href="#S-單一職責原則-Single-Responsibility-Principle" class="headerlink" title="S 單一職責原則(Single Responsibility Principle)"></a>S 單一職責原則(Single Responsibility Principle)</h3><hr><p>SRP主張一個類別應該只有一個職責，也就是說一個類別應該只有一個改變的原因。也有人這樣解釋：一個類別應只對唯一的一個角色負責。<br>這聽起來很難不讓人不茫然，我的理解是這樣的，SRP是指一個類別應該只做一件事，舉例來說：</p><p>假設有一個物件同時負責了將物件回傳給前端，以及物件存入資料庫這兩件事。當今天規格需要調整時，就可能造成，新增某欄位後前端壞掉後端也存不進去的問題，因為同一個模組負責了兩件事情 (回傳給前端的物件 + 存入資料庫的物件)。<br>比較好的做法是切割這兩個功能，使其成為一個獨立的類別。</p><p>實務上來說，這並不好實現，在設計時，雖然我們希望一個類別相當單純，但往往又會希望這個功能是可以好重複利用的，我們會很想要把一些重複的、不屬於該類別的處理加入該類別中，這最終導致了單一職責原則遭破壞。<br>所以SRP未必是一定得遵守的原則，反倒像是一種理想形式，只能透過經驗去學習如何切出一個乾淨的、職責分明的類別。</p><h3 id="O-開放封閉原則-Open-Closed-Principle"><a href="#O-開放封閉原則-Open-Closed-Principle" class="headerlink" title="O 開放封閉原則 (Open-Closed Principle)"></a>O 開放封閉原則 (Open-Closed Principle)</h3><hr><p>OCP主張一個軟體在面對擴展時是開放的，且擴充時不應修改到原有的程式。它必須是好修改的，就算要改，也不該影響現有程式功能。 舉例來說：</p><p>我們有一個車輛介面(Vehicle)，並有一個make()製造的方法，所有的汽車(Toyota、Honda)都是透過CarFactory的assemble()方法去組裝一台汽車。今天，假設我們有一個新的類別Mazda，他加入時， 不應該要更改CarFactory的內容。<br>所有的調整、商業邏輯要集中在Mazda，<del>並且沒有資格參加這個會議</del>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Toyota</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 實作省略</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Honda</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 實作省略</span><br>   &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assemble</span><span class="hljs-params">(Vehicle vehicle)</span> &#123;<br>        vehicle.make();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通常定義介面、或是一個繼承關係，可以實現OCP，定義中提到的擴展開放──就是指加入新的類別時不應影響到基底的功能。如果真的要加入的話，定義一個新的類別，透過繼承原先類別來完成它。<br>對修改封閉的意思剛好反過來，假設你想要調整CarFactory、就變得相當困難，因為一旦修改CarFactory，所有的汽車類別都會受到影響，因此對修改是封閉的。</p><p>聽起來是不是理所當然？但實際上也不太容易看到這樣的程式碼，通常的情況是，大家常常覺得在基底類別中加入一個if做特例處理就好，這導致了現實常常是一堆if if if在共用的類別中。要乾淨地拆開，既不違反KISS又要能符合OCP往往並不簡單。<br>最好的情況是，當下在設計初期，就考慮到抽象化類別的可能性，但這部分也需要經驗去判斷。</p><h3 id="L-里氏替換原則-Liskov-Substitution-Principle"><a href="#L-里氏替換原則-Liskov-Substitution-Principle" class="headerlink" title="L 里氏替換原則 (Liskov Substitution Principle)"></a>L 里氏替換原則 (Liskov Substitution Principle)</h3><hr><p>LSP主張，子類別必須能夠替換父類別，並且行為不受影響。原則有三：</p><ol><li>子類別的先決條件 (Preconditions) 不應被加強。────子類別應該要可以完全取代父類別、簡單來說就是不可以限制父類的定義，如果父類別的方法是接收Vehicle、子類別不可以覆寫並限制只能放入Mazda。</li><li>子類別的後置條件 (Postconditions) 不應被削弱。────子類別不可以削弱父類別的定義、與剛才相反，如果父類別的方法是接收Mazda，子類別覆寫時不可以改為Vehicle</li><li>父類別的不變條件 (Invariants) 必須被子型態所保留。────子類別不可以修改父類別的定義。<br>簡單來說呢，當你子類別想要做與父類別截然不同的事，你應該要思考，這個物件是否真的需要的是繼承嗎？還是應該拆開、或是套用Interface。</li></ol><p>讓我們看一個壞例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gandalf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>        戰吼();<br>        迴旋斬();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 搞屁啊為什麼甘道夫不是巫師嗎？為什麼會使用近戰技能？ </span><br><span class="hljs-comment">// 聽我說榮恩，這玩意兒比法杖好用多了</span><br></code></pre></td></tr></table></figure><h3 id="I-介面隔離原則-Interface-Segregation-Principle"><a href="#I-介面隔離原則-Interface-Segregation-Principle" class="headerlink" title="I 介面隔離原則 (Interface Segregation Principle)"></a>I 介面隔離原則 (Interface Segregation Principle)</h3><hr><p>ISP主張，因為模組之間的依賴不應有用不到的功能。<br>這是為了避免Code smell(程式碼異味)的一個原則，有一種設計上的問題要做God Object，這個God Object就跟上帝一樣什麼都能做，這種物件存在最終會導致，今天God Object需要調整時，你將會感受痛苦與絕望。因為它被使用到的地方太多，而你極有可能無法去確保修改之後系統會發生什麼不可預料的事情。腐敗就此開始。</p><p>當出現這樣的問題時，應該適當予以分割，我們可以透過介面來進行分割，把模組分得更符合本身的角色，也讓使用介面的角色只能分別接觸到應有的功能。<br>多使用介面來進行解藕、把實作隱藏起來、保持抽象，有助我們程式的彈性。</p><h3 id="D-依賴反轉原則-Dependency-Inversion-Principle"><a href="#D-依賴反轉原則-Dependency-Inversion-Principle" class="headerlink" title="D 依賴反轉原則 (Dependency Inversion Principle)"></a>D 依賴反轉原則 (Dependency Inversion Principle)</h3><hr><p>DIP主張，</p><ul><li>高層模組不應依賴低層模組，它們都應依賴於抽象介面。</li><li>抽象介面不應該依賴於具體實作，具體實作應依賴抽象介面。</li></ul><p>我當初看到就覺得，這什麼鬼？可不可以講人話？再說反轉是什麼，新的遊戲王陷阱卡嗎？<br>為了更好地說明，讓我們一步步解釋這概念吧。</p><p>高層、低層的概念是指抽象化的程度，比方說</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExportService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportDoc</span><span class="hljs-params">(Document document)</span> &#123;<br>        <span class="hljs-comment">//</span><br>    &#125;    <br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Document</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>當中ExportService是一個高層模組，exportDoc()負責輸出文件，而他不需要管文件到底是.txt、.doc、.docx，因為它並不直接依賴低階模組的內容，而是透過介面去操作它。<br>低階模組就像是Txt、Word等等實作Document的類別，內部定義了實作的內容。<br>所以，ExportService(高階模組)不應該依賴Word(低階模組)，而是依賴Document這個介面。</p><p>第二點，可以參考以下程式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Database</span> &#123;<br>    Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 強依賴於 JDBC 的 Connection</span><br>&#125;<br></code></pre></td></tr></table></figure><p>這個介面依賴了實際的內容，應該抽象化，比方說</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Database</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">(String data)</span>;<br>    String <span class="hljs-title function_">fetchData</span><span class="hljs-params">(String query)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>透過抽象化，讓介面可以更靈活。<br>透過實現DIP的原則，有以下好處</p><ol><li>提高靈活性：系統可以更輕鬆地替換具體實作，例如更換資料庫或支付服務。</li><li>提升可測試性：高層模組依賴抽象介面，可以通過模擬物件（Mock）來進行單元測試。</li><li>降低耦合：高層與低層模組相互隔離，修改低層模組時不需要修改高層模組。</li></ol><p>以上就是我整理的內容有關SOLID的一些概念解說，那今天就講到這裡了。</p><h3 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h3><ol><li><a href="https://medium.com/jastzeonic/soild-%E4%BA%94%E5%8E%9F%E5%89%87%E9%82%A3%E4%B8%80%E5%85%A9%E4%BB%B6%E4%BA%8B%E6%83%85-4410b72e37f3">https://medium.com/jastzeonic/soild-%E4%BA%94%E5%8E%9F%E5%89%87%E9%82%A3%E4%B8%80%E5%85%A9%E4%BB%B6%E4%BA%8B%E6%83%85-4410b72e37f3</a></li><li><a href="https://www.explainthis.io/zh-hant/swe/solid">https://www.explainthis.io/zh-hant/swe/solid</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SOLID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何打造自己的專業形象</title>
    <link href="/2025/01/01/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%88%E6%A5%AD%E5%BD%A2%E8%B1%A1/"/>
    <url>/2025/01/01/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%88%E6%A5%AD%E5%BD%A2%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>嗨，你是否跟我一樣，明明覺得自己工作做了很多事，天天被使喚來使喚去，明明做了不少事，但事到臨頭卻沒有辦法明確地寫出自己做了什麼？甚至有時候還開始懷疑起自己到底為什麼看起來不如他人來得優異？<br>當然，也是有可能你我做的事真的沒什麼了不起，是那種無關緊要緊要的事也說不定。但因為我的個性天生有點自卑，有時很容易被貶低自己的努力與付出，接著就進入負面的螺旋：努力-&gt;自貶-&gt;努力-&gt;自貶。<br>因此在2025年，我希望可以有一個明確的方式來認識自己。試著使用大眾的標準作為框架來定義自己的行為，當然我極力否認任何人被框架束縛，但作為評斷、參考用的標準來說，我想還是能為自己帶來點靈感與成長。<br>我所選的評斷標準，是Amazon Leadership Principle，又稱Amazon領導力準則。</p><h3 id="Amazon-Leadership-Principle-是什麼？"><a href="#Amazon-Leadership-Principle-是什麼？" class="headerlink" title="Amazon Leadership Principle 是什麼？"></a>Amazon Leadership Principle 是什麼？</h3><p>這是源自Amazon創辦人所提出的，共有14項的領導準則。這是用來告訴所有Amazon的員工，以及那些想要進入Amazon的應徵者們，Amazon所追求的員工形象，這十四項分別是：</p><ol><li>顧客至上 (Customer obsession) 努力工作，贏得客戶對他們的信任，<strong>以顧客優先</strong>。</li><li>主人翁精神 (Ownership) <strong>長遠考慮，不因短期業績犧牲長期價值</strong>，認為自己代表了公司，遇事不會說<strong>那不是我的工作</strong>“</li><li>創新與簡化 (Invent and simplify) <strong>不斷追求創新與發明</strong>、了解外界動態，尋求<strong>使工作簡易化的方法</strong></li><li>決策正確 (Right,a lot) <strong>做出正確決定</strong>，透過了解多樣視角，挑戰刻板印象</li><li>好奇求知 (Learn and be curious) <strong>終身學習</strong>者，<strong>對可能性充滿好奇並付諸行動加以探索</strong></li><li>選賢與能 (Hire and develop the best) 表彰傑出人才，磨練他們，從員工角度出發。</li><li>最高標準 (Insist on the highest standards) 有<strong>高標準</strong>，<strong>確保任何問題不會蔓延</strong>，<strong>得以及時徹底解決並確保不再出現</strong></li><li>胸懷大志 (Think big) 從<strong>不同角度考慮問題，廣泛尋找服務客戶的方法</strong>，進而激發出良好的成果。</li><li>崇尚行動 (Bias for action) 決策與行動是可以調整的，<strong>鼓勵在深思熟慮的前提下冒險</strong></li><li>勤儉節約 (Frugality) 以<strong>更少的投入換來更大的產出</strong></li><li>贏得信任 (Earn trust) <strong>專注傾聽 坦誠溝通 尊重他人 感於自我批評</strong> 以最佳領導者標準要求自己與其團隊</li><li>追根究柢 (Dive deep) <strong>深入各環節，掌控細節，經常自我審核，不遺漏任何工作</strong></li><li>批判與承諾 (Have backbone; disagree and commit) <strong>勇於質疑</strong>他們無法認同的決策，一旦做出決定，就全心全意致力於實現目標</li><li>達成業績 (Deliver results) 即使<strong>碰到困難也</strong>確保工作品質並執行完成。</li></ol><p>我是參考這份文章做出以下整理的，有興趣的朋友也有可以看看它：<a href="https://hsinchengchao.medium.com/%E7%BE%8E%E5%9C%8B%E6%B1%82%E8%81%B7%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB-%E5%85%AD-fb9c73ff995c">https://hsinchengchao.medium.com/%E7%BE%8E%E5%9C%8B%E6%B1%82%E8%81%B7%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB-%E5%85%AD-fb9c73ff995c</a></p><h4 id="用處"><a href="#用處" class="headerlink" title="用處"></a>用處</h4><p>透過這14項的整理，是用來讓我自己去思考，自己日常的舉止是否有符合該行為的指標，順帶思考是否可以整理出一個STAR來描述自己，透過實際案例與成果，讓自己的價值可以更好展現給聆聽者。<br>對於內向的我來說這不容易，我正在學習中，當作是今天的新年新希望做，希望今年能夠一帆風順。</p>]]></content>
    
    
    <categories>
      
      <category>Chat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Resume</tag>
      
      <tag>Personality</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linkedin-人資怎麼看你？</title>
    <link href="/2024/12/30/Linkedin-%E4%BA%BA%E8%B3%87%E6%80%8E%E9%BA%BC%E7%9C%8B%E4%BD%A0%EF%BC%9F/"/>
    <url>/2024/12/30/Linkedin-%E4%BA%BA%E8%B3%87%E6%80%8E%E9%BA%BC%E7%9C%8B%E4%BD%A0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="獵頭怎麼找到你？"><a href="#獵頭怎麼找到你？" class="headerlink" title="獵頭怎麼找到你？"></a>獵頭怎麼找到你？</h3><p>前一陣子參加了年底的<GDG Taipei>，突然有看到A開頭的獵頭公司開Linkedin講座，覺得有興趣就去聽聽看，意外的是還真的知道了一些平常不會知道的事<br>當然也可能是我涉世不深，懂得還不多，大概整理了一些東西，也歡迎分享與交流：</p><ul><li>獵頭在找尋人才時，通常都是使用Linkedin為招募者提供的後台進行搜尋。搜尋條件就主要是學經歷等等…</li><li>獵頭通常在找人才時，面對雇主的需求，經常用以下順位去找：<ul><li>Location 地點，在個人資訊頁面填入的地點會被納入人資的搜尋條件中。</li><li>Skill 技能，如果有經驗的技能，盡量放在技能欄位，好讓自己被發現。(A社獵頭表示軟體工程師不必寫軟實力)</li><li>Company 任職公司，有些公司會要求從XX公司來的人，這時公司就很重要了</li><li>KeyWords 關鍵字</li></ul></li><li>Linkedin後台，針對市場上的人才，會粗略分成三種類型，HR找人從上往下找：<ul><li>OPEN TO WORK 這是Linkedin可以開啟的狀態，求職者開啟表示主動找尋工作，同時可以限制為只有招募專員才可見。</li><li>ACTIVE TALENT 這是Linkedin用演算法分類的狀態，可以理解為活躍用戶的標籤，若是想要被分類到這一塊，要考慮：<ul><li>多多參與貼文回應</li><li>近期更新過Linkedin Profile</li></ul></li><li>REDISCOVERED CANDIDATES 非活躍用戶</li></ul></li></ul><h3 id="Linkedin-Profile-怎麼建？"><a href="#Linkedin-Profile-怎麼建？" class="headerlink" title="Linkedin Profile 怎麼建？"></a>Linkedin Profile 怎麼建？</h3><p>大致Linkedin Profile有這五個部分</p><ol><li>HeadLines&amp;Location</li><li>Experience</li><li>Skills&amp;Certification</li><li>About</li><li>Project</li></ol><p>A社獵頭表示，通常前三個符合，他們就會找你了。</p><p>有關HeadLines的寫法，可參考範例：<br><img src="/img/linkedin_headlines.png"><br>Experience的寫法，可參考範例：<br><img src="/img/linkedin_experience.png"><br>撰寫經歷要注意：</p><ul><li>至少要有三個bullet points</li><li>介紹自己使用的技術</li><li>其他關鍵字(領域、你開發什麼樣的系統等等)</li><li>量化描述成果</li></ul><p>About的寫法A社獵頭建議不要太長，約在10以內最好，如果沒想法可以參考範例：<br><img src="/img/linkedin_about.png"></p><p>其他雜圖<br><img src="/img/linkedin_extra1.png"><br><img src="/img/linkedin_extra2.png"></p><p>大約就是這樣，這篇文章沒有什麼可以讓人醍醐灌頂的內容，寫完的我可以保證，大多內容還是些老生常談，最多就能帶來一點方向性指導。<br>就這樣，祝各位求職順利。</p>]]></content>
    
    
    <categories>
      
      <category>Self-Value</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linkedin</tag>
      
      <tag>Head Hunter</tag>
      
      <tag>Resume</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clean-Code-筆記-2</title>
    <link href="/2024/12/29/Clean-Code-%E7%AD%86%E8%A8%98-2/"/>
    <url>/2024/12/29/Clean-Code-%E7%AD%86%E8%A8%98-2/</url>
    
    <content type="html"><![CDATA[<p>本次是繼續上回的Clean Code筆記，廢話不多說，Let’s us begin.</p><h2 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h2><h4 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h4><ol><li>撰寫一個單元測試前不應該撰寫產品程式碼</li><li>只撰寫剛好能通過的產品程式碼</li><li>只撰寫剛好能通過當前測試失敗的產品程式碼</li></ol><h4 id="注意要點"><a href="#注意要點" class="headerlink" title="注意要點"></a>注意要點</h4><ul><li>撰寫測試的好處可以讓你更動程式碼時不那麼恐懼， 需要注意的是，測試程式碼同樣需要與時俱進，若沒有跟著調整容易造成程式碼的腐敗，最終測試程式碼的品質同樣影響產品程式碼。</li><li>測試程式碼要求的是可讀性 闡明性(Clarity)，而不是效能。</li><li>盡量維持一個測試一個斷言(Assert)，讓一個測試只會顯示一個結果，方便開發者評估功能。(一個測試只測試一個概念)</li></ul><h4 id="TDD-FIRST原則"><a href="#TDD-FIRST原則" class="headerlink" title="TDD FIRST原則"></a>TDD FIRST原則</h4><ul><li>Fast 測試應該要夠快</li><li>Independent 測試應該要能夠獨立運行，不依賴其他測試程式</li><li>Repeatable 測試應該要能夠重複使用</li><li>Self-Validating 測試應該要能夠自我驗證，顯示要測試的概念是否成功運作</li><li>Timely 要在產品程式之前被撰寫，若是之後才撰寫，經常會發現撰寫出來的產品程式碼並不好被測試</li></ul><h2 id="Class-Level"><a href="#Class-Level" class="headerlink" title="Class-Level"></a>Class-Level</h2><h4 id="單一職責原則-Single-Responsibility-Principle-SRP"><a href="#單一職責原則-Single-Responsibility-Principle-SRP" class="headerlink" title="單一職責原則(Single Responsibility Principle, SRP)"></a>單一職責原則(Single Responsibility Principle, SRP)</h4><p>單一職責原則主張，一個類別或一個模組應該只能有一個，而且只能有一個被修改的理由。<br>個人對這段的理解是，一個類別的職責應該是很明確的，他只該負責一件事，而需要修改類別的原因，<br>必須得是當初認為要做的那件事。 比方說有一個專門處理報表Excel輸出的類別ExcelObject，若今天需要做輸出Excel之外的事 ，比方說：判斷格式、字串拼接、欄位驗證、給定預設值，若因為這些理由而修改了ExcelObject，就是違反了SRP。</p><h4 id="凝聚力"><a href="#凝聚力" class="headerlink" title="凝聚力"></a>凝聚力</h4><p>類別中的方法，盡量讓每個變數都被使用在每一個方法中。<br>當類別失去凝聚力時，就應該將它拆開</p><h4 id="開放閉合原則-Open-Closed-Principle"><a href="#開放閉合原則-Open-Closed-Principle" class="headerlink" title="開放閉合原則(Open-Closed Principle)"></a>開放閉合原則(Open-Closed Principle)</h4><p>類別應該要對擴充具備開放性，但對修改具有閉合性。</p><h4 id="隔離修改"><a href="#隔離修改" class="headerlink" title="隔離修改"></a>隔離修改</h4><p>類別之間不應該實體依賴，而是依賴抽象，透過一層抽象隔離變化，責任分明且易於測試。</p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h4 id="依賴注入-Dependency-Injection-DI"><a href="#依賴注入-Dependency-Injection-DI" class="headerlink" title="依賴注入(Dependency Injection, DI)"></a>依賴注入(Dependency Injection, DI)</h4><p>將物件的建立過程從使用中分離出來，這是控制反轉(Inversion of Control, IOC)在相依性管理裡的一種應用手段。控制反轉是將某個物件的第二個職責，移至其他專注於該職責的物件裡，也因此支援了SRP原則。<br>在相依性管理的範疇中，一個物件不應該負責實體化對本身的相依。而是將責任交給外部。建議可以透過抽象工廠進行。</p><h4 id="抽象工廠-Abstract-Factory-Example"><a href="#抽象工廠-Abstract-Factory-Example" class="headerlink" title="抽象工廠(Abstract Factory) Example"></a>抽象工廠(Abstract Factory) Example</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象產品：Button</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 抽象產品：TextBox</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TextBox</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具體產品：WindowsButton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Rendering a Windows-style Button&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體產品：WindowsTextBox</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsTextBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextBox</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Rendering a Windows-style TextBox&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體產品：MacOSButton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Rendering a MacOS-style Button&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體產品：MacOSTextBox</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSTextBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TextBox</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Rendering a MacOS-style TextBox&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象工廠：UIFactory</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UIFactory</span> &#123;<br>    Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span>;<br>    TextBox <span class="hljs-title function_">createTextBox</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 具體工廠：WindowsFactory</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UIFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsButton</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> TextBox <span class="hljs-title function_">createTextBox</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsTextBox</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具體工廠：MacOSFactory</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MacOSFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UIFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Button <span class="hljs-title function_">createButton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MacOSButton</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> TextBox <span class="hljs-title function_">createTextBox</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MacOSTextBox</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客戶端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 客戶端選擇一個工廠</span><br>        <span class="hljs-type">UIFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> getFactory(<span class="hljs-string">&quot;Windows&quot;</span>); <span class="hljs-comment">// 可切換為 &quot;MacOS&quot;</span><br><br>        <span class="hljs-comment">// 使用工廠創建產品</span><br>        <span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> factory.createButton();<br>        <span class="hljs-type">TextBox</span> <span class="hljs-variable">textBox</span> <span class="hljs-operator">=</span> factory.createTextBox();<br><br>        <span class="hljs-comment">// 渲染產品</span><br>        button.render();<br>        textBox.render();<br>    &#125;<br><br>    <span class="hljs-comment">// 工廠選擇邏輯</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UIFactory <span class="hljs-title function_">getFactory</span><span class="hljs-params">(String osType)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (osType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Windows&quot;</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowsFactory</span>();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;MacOS&quot;</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">MacOSFactory</span>();<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown OS type&quot;</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>▲ 這樣的設計可以靈活切換不同風格的 UI，且對於新的 UI 主題（如 Linux），只需添加新的工廠和產品類即可，無需修改現有代碼。</p><h3 id="橫切關注點"><a href="#橫切關注點" class="headerlink" title="橫切關注點"></a>橫切關注點</h3><p>假設我們有一個交易系統，流程如下：</p><ol><li>登入-&gt; 身分驗證  -&gt; 付款</li><li>登入-&gt; 身分驗證  -&gt; 退款</li></ol><p>嘗試以這樣的角度去理解系統的流程，你會發現「登入」與「身分驗證」並不是真正核心的功能，且兩者重複存在。為了使我們可以更專注在真正重要的商業流程上，我們可以將那些次要的細節作為一個個切片(Aspects)從主流程切割出來，這一個步驟我們稱之為關注點分離。<br>而實現這樣的構想的技術就是Java Proxy機制，或是AOP(又名切面導向編程)。<br>關於AOP，可以參考我的另一篇文章：<a href="https://medium.com/@ziegler7359/spring-boot-aop-%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97-392e2b83cd54">Spring AOP</a></p><p>大約整理到這邊，後面Clean Code的相關討論幾乎都是案例題目了，這邊就不拿出來討論了。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Clean Code</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clean Code 筆記(1)</title>
    <link href="/2024/12/26/Clean-Code-%E7%AD%86%E8%A8%98-1/"/>
    <url>/2024/12/26/Clean-Code-%E7%AD%86%E8%A8%98-1/</url>
    
    <content type="html"><![CDATA[<p>Clean Code的原則包含了多種面向，透過Clean Code的學習，可以使你全方位的檢視自己撰寫與他人撰寫的程式碼是否足夠整潔。<br>以下為自己整理的Clean Code學習筆記：</p><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>好的變數命名應該要能夠名副其實，比方說：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> day;<br></code></pre></td></tr></table></figure><p>永遠比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> expireDate;<br></code></pre></td></tr></table></figure><p>要來得糟。</p><hr><ul><li>避免使用 <em>O</em> <em>0</em> <em>I</em> <em>L</em> 這些容易誤導、寫錯的字元</li><li>使用能唸出來的名稱，<em>團隊溝通會使用到</em></li><li>使用可被搜尋到的名字 <em>除錯時會使用到</em></li><li>介面與繼承，可使用 Student、StudentImpl作為命名</li><li>命名應該直觀，符合開發人員的想像</li><li>類別應以名詞命名、方法應以動詞命名</li></ul><hr><h3 id="函式"><a href="#函式" class="headerlink" title="函式"></a>函式</h3><p>設計原則</p><ul><li>讓函式只做一件事，SRP。</li><li>參數的數量越少越好，方便開發者了解參數對整理輸出的影響</li><li>不要帶boolean進function，違背了SRP。</li><li>如果要傳入多個參數，用物件包裝會更好，至少符合相同概念。</li><li>輸入與指令分離，ex:判斷條件與操作物件是兩個不同層級的概念，不要放在一起</li><li>不要有副作用，避免不可預料的BUG發生</li><li>以try catch 取代if 判斷，減少巢狀迴圈。</li></ul><hr><h3 id="物件與資料結構"><a href="#物件與資料結構" class="headerlink" title="物件與資料結構"></a>物件與資料結構</h3><ol><li><p>抽象化設計界面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FuelTankCapacityInGallons();<br><span class="hljs-type">double</span> <span class="hljs-title function_">getGallonsOfGasoline</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">getPercentFuelRemaining</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>採用後者的設計方式可以隱藏資料的細節。</p></li><li><p>資料結構的程式碼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">talk</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> Merchant) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> Smith) &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在NPC類別中，要擴充一個新的類別很麻煩，必須要更動所有原先相關的程式碼，以符合函式的架構</li><li>在NPC類別中，新增新的方法很容易，不需更動既有程式碼</li><li></li></ul><ol start="2"><li>物件導向的程式碼<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Merchant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">talk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Smith</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NPC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">talk</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NPC</span> &#123;<br>    talk();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>在NPC類別中，要寫一個新的類別很容易，不需更動既有程式碼</li><li>在NPC類別中，新增新的方法很麻煩，必須要更動每一個繼承NPC的類別</li></ul><h3 id="例外處理"><a href="#例外處理" class="headerlink" title="例外處理"></a>例外處理</h3><ul><li>視情況，選擇封裝Exception</li><li>不要傳遞Null</li></ul><p>節錄<Clean Code> Ch1~Ch8</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Clean Code</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令與說明</title>
    <link href="/2024/12/24/Git-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%88%87%E8%AA%AA%E6%98%8E/"/>
    <url>/2024/12/24/Git-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%88%87%E8%AA%AA%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>我們常用的指令有很多，對資訊科技的學生來說，Git的使用已經是基礎了，更何況是一名資訊工作者。本次是要整理那些常用的指令，以及針對一些細節去做釐清學習。<br>常用的指令整理如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init #初始化Git Repo<br>git status #查看 Git 目錄更動狀態<br>git log # 查看commit紀錄<br>git add  # 將tracked的資料，添加到add區域<br>git commit # 將add區域的資料，提交一筆紀錄<br>git push # 把本地的commit提交至遠端伺服器<br>git reset -soft # 用來拆commit用的 會把HEAD重製到指定位置<br>git reset -mixed # 用來拆commit用的 除了把HEAD重製到指定位置，還會把資料變成untracked狀態<br>git reset -hard # 最少用，重製到指定位置，並刪除之前位置到重製點之前的commit，危險!<br>git checkout: 用來切換分支或恢復檔案，切換到分支時，使HEAD 指向該分支。<br>git merge: 將另一個分支的更改合併到當前分支中，會產生合併提交。<br>git rebase: 用來將一個分支的提交移到另一個分支上，通常用來保持提交歷史簡潔，可以取代 git merge 的方式。<br>git branch: 列出、創建或刪除分支。<br></code></pre></td></tr></table></figure><h4 id="Detach-HEAD-表示當前不在任何分支上，HEAD-直接指向某個提交，通常需要使用-git-checkout-返回分支。"><a href="#Detach-HEAD-表示當前不在任何分支上，HEAD-直接指向某個提交，通常需要使用-git-checkout-返回分支。" class="headerlink" title="Detach HEAD: 表示當前不在任何分支上，HEAD 直接指向某個提交，通常需要使用 git checkout 返回分支。"></a>Detach HEAD: 表示當前不在任何分支上，HEAD 直接指向某個提交，通常需要使用 git checkout 返回分支。</h4><h4 id="Fast-forward-當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。"><a href="#Fast-forward-當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。" class="headerlink" title="Fast-forward: 當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。"></a>Fast-forward: 當目標分支可以直接向前推進而不需要合併提交，會自動進行快進合併，保留簡潔的歷史。</h4><p>大致整理到這邊，後來其實我越來越少用了，主要是IDE內建Git功能很多都比Git Bash shell 的更易於使用了，也有更便捷的一些做法，所以以上僅作個人紀錄之用。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什麼樣的程式碼需要被重構？</title>
    <link href="/2024/12/23/%E4%BB%80%E9%BA%BC%E6%A8%A3%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%9C%80%E8%A6%81%E8%A2%AB%E9%87%8D%E6%A7%8B%EF%BC%9F/"/>
    <url>/2024/12/23/%E4%BB%80%E9%BA%BC%E6%A8%A3%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%9C%80%E8%A6%81%E8%A2%AB%E9%87%8D%E6%A7%8B%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>什麼樣的程式碼需要被重構？</p><p>還記得當我在找第一份後端工作時，曾經有被面試官問到有沒有過重構的經驗？當時的我菜得一批，連重構是什麼都講不出來，最後只吞吞吐吐地說自己沒有重構的經驗。後來，受到教訓的我讓自己慢慢去了解重構之後，才慢慢發現「重構」並不是什麼高大上的名詞，有時甚至你還沒聽過這個名詞時，就已經在重構之中了。<br>重構──意指在不影響程式碼功能的情況下，進行程式碼的效能、可讀性、可維護性等等進行調整的行為。小到修正命名不良的變數名稱，大到套用設計模式，調整系統的架構 ( 但前提是功能不受影響 )，這些都可以算是重構。<br>重構──那些變數、方法等級的重構，其實都不算太難。通常會讓人困惑的點更多是在於，我不確定這段程式碼需不需要被重構。假設有一段關於交易的程式碼，中間有超過100行的驗證程式碼，你可能直覺性地覺得應該要提取出來作為一個獨立的方法。但團隊的其他人也許早就習慣了這樣寫，這樣一來，是否真的能夠幫助到其他人理解這段程式碼？<br>這說明了其實很多標準最終你依然得Align自己的開發團隊，而非盲目遵從某些標準或規範。當然能夠判斷出哪部分的程式碼暴露了不必要的細節這點，也需要一些經驗。<br>對於這種模糊不清的感覺，有些人可以無師自通，抓出合理的平衡點。如果不是，我會推薦看Kent Beck的《測試驅動開發》，裡面詳細地描述了如何從一個肥胖的程式碼不斷調整，透過大量的測試，一步步將物件的依賴分離與凝聚力的提升。雖然TDD的開發流程是否適合開發團隊使用是個好問題。但做為學習重構程式碼的第一站來說，我還是認為說《測試驅動開發》會很適合初出茅廬的工程師。<br>此外，對於重構程式碼這件事，TDD還提到一個我認為最重要的觀念。「首先必須要有完善、覆蓋率高的測試程式碼，不然就只是在重寫而已」</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Refactor</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Github Page + Hexo + Vercel 建立你的部落格</title>
    <link href="/2024/12/22/%E7%94%A8Github-Page-Hexo-Vercel-%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E9%83%A8%E8%90%BD%E6%A0%BC/"/>
    <url>/2024/12/22/%E7%94%A8Github-Page-Hexo-Vercel-%E5%BB%BA%E7%AB%8B%E4%BD%A0%E7%9A%84%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>作為一名開發者，Github已經是每天都無法脫離的工具，除此之外，Github Page也是許多新手工程師的好朋友，使用簡單的指令就可以讓新手工程師建立一個屬於自己的部落格，以下就是簡單介紹要怎麼搭建一個自己的Github Blog<br>我們主要使用Hexo作為框架，他主要以Node.js作為編譯工具。</p><h3 id="環境安裝"><a href="#環境安裝" class="headerlink" title="環境安裝"></a>環境安裝</h3><ol><li>Git(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>) 版本控制工具</li><li>Node.js(<a href="https://nodejs.org/zh-tw">https://nodejs.org/zh-tw</a>) 執行Hexo框架必備Node.js的套件管理工具。</li></ol><p>安裝完後，打開CMD，輸入 “node -v” 與 “git -v” 看看兩者是不是都有安裝成功，有的話就繼續下去。</p><h1 id="步驟解說"><a href="#步驟解說" class="headerlink" title="步驟解說"></a>步驟解說</h1><h4 id="本機設定"><a href="#本機設定" class="headerlink" title="本機設定"></a>本機設定</h4><ol><li>建立你的工作資料夾。</li><li>在你建立的工作資料夾目錄下，點選右鍵 “Open Git Bash”，開啟Git cmd</li><li>安裝Hexo 輸入”npm install -g hexo-cli” npm 是 node.js的套件管理工具，-g 代表在資料夾外也可以使用(global)，hexo-cli是我們要安裝的node.js套件</li><li>安裝完後輸入”hexo -v” 確認hexo 是否有成功安裝，成功的話繼續。</li><li>在你的工作目錄下初始化hexo資訊 CMD輸入”hexo init” 與 “npm install”</li><li>安裝完後輸入 “hexo s” 啟用hexo運作的伺服器範例</li><li>你應該會看到訊息 “Hexo is running at port 4000”，這時可以開啟URL確認看看。</li></ol><p>這樣一來基本的安裝就完成了！</p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><ol><li>註冊Github</li><li>以”你的名字.github.io”建立Repository。</li></ol><h4 id="部署至GithubPage"><a href="#部署至GithubPage" class="headerlink" title="部署至GithubPage"></a>部署至GithubPage</h4><ol><li>在Hexo工作資料夾下安裝套件 “npm install hexo-deployer-git –save”</li><li>打開_config.yml文件，修改以下設定<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repository:</span> &lt;你的GithubPage路徑&gt;<br><span class="hljs-symbol">branch:</span> &lt;你要推的分支&gt;<br></code></pre></td></tr></table></figure>修改完後，我們要重新打包，在cmd 輸入 “hexo g” 產生靜態文件。<br>接著輸入 “hexo d”，把你的Hexo Page推到Github上。<br>接著打開你的Repository，並觀察Actions中，是否WorkFlow成功執行完。如果正常結束，那恭喜你，你已經完成了。</li></ol><p>感謝觀看，有任何問題歡迎下方留言，就這樣掰掰。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GithubPage</tag>
      
      <tag>Hexo</tag>
      
      <tag>Vercel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary in 2024/11/07</title>
    <link href="/2024/11/07/Diary-in-2024-11-07/"/>
    <url>/2024/11/07/Diary-in-2024-11-07/</url>
    
    <content type="html"><![CDATA[<p>Hi guy, I just started this new series of article. I try to express myself using my English ability. It might be dull,<br>so I assume no one want to see this. Now bro, get to previous page quickly.</p><p>Hmm…Where should I start…Oh! I know, I know.<br>My name is LIU,CHIH-MIN, everyone call me Clark at work. I worked as a software engineer for more than two years.<br>As a software engineer, I’m best at using Java to develop web application. I have tried many language of programming in my<br>first year engineer days. I have used Python,Javascript,Go,Kolin,Dart. Although this experience. I still decided to put Java<br>as my best skill. The reason is Java has the most active community, I can easy find out the resolution of my issue. Moreover,<br>active community also means better ecosystem. Although it does have some weekly, but it doesn’t affect me to recongize it as<br>a best choice of learning programming.<br>Talk enough about work, let write somethin about myself, shall we?<br>I got admit that I am not a good software engineer, for I have not get satisfactory for now in my career. It troubled me for a<br>long time. I always question myself, did I really feel enough? I am now having a cozy life, I have time to play mobile game, listen<br>Youtube films, have time to sleep 8 hours a day. Sometime I found myself is a orphange of IT. For most of my college classmate go to<br>Studying for a Master Degree. I was the only one who tries to fight as a college student. After these two years, I do find out that<br>there will always have something I don’t even know or hear about. I have get used to this situation. I tries to learning as much as I<br>can. But I can never be better than those who overtime throug holidays.<br>I started to think maybe this is what we called destiny, maybe…just maybe.</p>]]></content>
    
    
    
    <tags>
      
      <tag>English Diary Personal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring MapStruct</title>
    <link href="/2024/10/21/Spring-MapStruct/"/>
    <url>/2024/10/21/Spring-MapStruct/</url>
    
    <content type="html"><![CDATA[<p>在Java的歷史中，我們為了更責任分明的處理資料，誕生出了許多物件，如對應資料庫的Persistent Object(PO)、用來傳輸溝通使用的Data Transfer Object(DTO)、以及用來顯示的Value Object(VO)，等等…</p><p>這樣針對同一個(廣義來說)物件，根據不同使用情境進行封裝，很好展現出Java的特色(隱藏不必要的細節)，但缺點是管理這些物件變得比較麻煩，我們會經常將一個物件轉換為另外一個物件，比方說我們把DTO轉為PO並存入資料庫中。那有沒有一個方法可以幫助我們處理物件轉換。</p><p>有，就今天要介紹的Mapstruct。MapStruct比起傳統常看到的ObjectMapper，多了更多的功能可以使用，以符合現在更複雜的場景。</p><p>要使用Mapstruct，你首先要導入依賴。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;dependency&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>假設我們現在有一隻註冊API，他負責將傳來的會員資料，判斷是否可以被註冊，並將資料存入資料庫中，我們主要要將Member轉為MemberPO，規格如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Member</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Schema(description = &quot;Unique identifier of the User&quot;, example = &quot;Clark&quot;)</span><br>    <span class="hljs-keyword">private</span> String account;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> String phone;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-keyword">private</span> LocalDate birthday;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberPO</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@Column(nullable = false)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Column(nullable = false, unique = true)</span><br>    <span class="hljs-keyword">private</span> String account;<br>    <span class="hljs-meta">@Column(nullable = false)</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-meta">@Column(columnDefinition = &quot;INET&quot;)</span><br>    <span class="hljs-keyword">private</span> InetAddress ip;<br>    <span class="hljs-meta">@Column(name = &quot;wallet_id&quot;)</span><br>    <span class="hljs-keyword">private</span> Long walletId;<br>    <span class="hljs-meta">@Column(nullable = false, unique = true)</span><br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@Column(name = &quot;phone_number&quot;)</span><br>    <span class="hljs-keyword">private</span> String phoneNumber;<br>    <span class="hljs-meta">@Column(columnDefinition = &quot;TEXT&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-comment">// Update by SQL Trigger</span><br>    <span class="hljs-meta">@Column(name = &quot;created_at&quot;, nullable = false, updatable = false)</span><br>    <span class="hljs-meta">@Temporal(TemporalType.TIMESTAMP)</span><br>    <span class="hljs-keyword">private</span> LocalDateTime createdAt;<br>    <span class="hljs-comment">// Update by SQL Trigger</span><br>    <span class="hljs-meta">@Column(name = &quot;updated_at&quot;, nullable = false)</span><br>    <span class="hljs-meta">@Temporal(TemporalType.TIMESTAMP)</span><br>    <span class="hljs-keyword">private</span> LocalDateTime updatedAt;<br>    <span class="hljs-meta">@Column(nullable = false)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> MemberStatus.ACTIVE.name();<br>    <span class="hljs-meta">@Column(nullable = false)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> MemberRole.USER.name();<br>    <span class="hljs-meta">@Column</span><br>    <span class="hljs-keyword">private</span> LocalDate birthdate;<br>    <span class="hljs-meta">@Column(name = &quot;profile_picture_url&quot;)</span><br>    <span class="hljs-keyword">private</span> String profilePictureUrl;<br>    <span class="hljs-meta">@Column(name = &quot;last_login&quot;)</span><br>    <span class="hljs-keyword">private</span> LocalDateTime lastLogin;<br>    <span class="hljs-meta">@Column(name = &quot;login_attempts&quot;, nullable = false)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">loginAttempts</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Column(name = &quot;security_question&quot;)</span><br>    <span class="hljs-keyword">private</span> String securityQuestion;<br>    <span class="hljs-meta">@Column(name = &quot;security_answer&quot;)</span><br>    <span class="hljs-keyword">private</span> String securityAnswer;<br>    <span class="hljs-meta">@Column(name = &quot;two_factor_enabled&quot;, nullable = false)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">twoFactorEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>這兩個物件差異很大，欄位名稱，資料數量等等都不同，要怎麼做呢？</p><p>首先，我們要先定義出一個MapStruct來處理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MemberMapper</span> &#123;<br><span class="hljs-comment">// 實例化Mapstruct</span><br>    <span class="hljs-type">MemberMapper</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(MemberMapper.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>接著我們可以加入我們的轉換方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MemberMapper</span> &#123;<br><span class="hljs-comment">// 實例化Mapstruct</span><br>    <span class="hljs-type">MemberMapper</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> Mappers.getMapper(MemberMapper.class);<br>    <br>    MemberPO <span class="hljs-title function_">memberToMemberPo</span><span class="hljs-params">(Member member)</span>;<br>    Member <span class="hljs-title function_">memberPOToMember</span><span class="hljs-params">(MemberPO memberPO)</span>;<br>&#125;<br><span class="hljs-comment">// TEST</span><br><span class="hljs-type">MemberPO</span> <span class="hljs-variable">memberPO</span> <span class="hljs-operator">=</span> MemberMapper.INSTANCE.memberToMemberPo(member);<br><span class="hljs-type">Member</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> MemberMapper.INSTANCE.memberPOToMember(memberPO);<br></code></pre></td></tr></table></figure><p>我建立了兩個方法，以應對Member轉MemberPO與MemberPO轉回Member物件的情境。</p><p>基本上只要這樣兩個物件就可以進行互相轉換了。但我們剛剛有提到，兩者物件的欄位名稱並不相同，針對這部分，可以加上@Mapping進行Mapping，如果邏輯比較特殊，也可以自己掛一個轉換器，我們在加上這部分吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapping(source = &quot;phone&quot;,target = &quot;phoneNumber&quot;)</span><br><span class="hljs-meta">@Mapping(source = &quot;birthday&quot;,target = &quot;birthdate&quot;)</span><br><span class="hljs-meta">@Mapping(source = &quot;ip&quot;, target = &quot;ip&quot;, qualifiedByName = &quot;stringToInetAddress&quot;)</span><br>MemberPO <span class="hljs-title function_">memberToMemberPo</span><span class="hljs-params">(Member member)</span>;<br><br><span class="hljs-meta">@Named(&quot;stringToInetAddress&quot;)</span><br>    <span class="hljs-keyword">default</span> InetAddress <span class="hljs-title function_">stringToInetAddress</span><span class="hljs-params">(String ip)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> InetAddress.getByName(ip);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid IP address: &quot;</span> + ip, e);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>source 代表來源，也就是傳入的物件屬性，target則代表回傳的物件屬性，透過這樣的方式去映射兩個物件，qualifiedByName則可以掛一個轉換器，以下把String的 IP轉換為 InetAddress物件。</p><p>如果你想要針對一些欄位做出預設值？Mapstruct也支援這個功能，比方說在Member轉換為MemberPO後自動配置角色權限為一般使用者(USER)、並預設帳號狀態為啟用狀態。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 轉型後設定預設值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> memberPO 轉換對象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> member 轉換來源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AfterMapping</span><br><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDefaultValues</span><span class="hljs-params">(<span class="hljs-meta">@MappingTarget</span> MemberPO memberPO, Member member)</span> &#123;<br>  <span class="hljs-keyword">if</span> (memberPO.getRole() == <span class="hljs-literal">null</span>) &#123;<br>      memberPO.setRole(MemberRole.USER.name());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (memberPO.getStatus() == <span class="hljs-literal">null</span>) &#123;<br>      memberPO.setStatus(MemberStatus.ACTIVE.name());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上，我常用的主要操作就是以上這些了。Mapstruct非常靈活，提供了額外寫一個方法進行手動轉換以外的方法，有興趣的朋友可以試試看這個工具，那今天的部分就到這裡了，就明天見吧。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>MapStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Reflection</title>
    <link href="/2024/10/20/Spring-Reflection/"/>
    <url>/2024/10/20/Spring-Reflection/</url>
    
    <content type="html"><![CDATA[<p>Spring Reflection──反射，是不少新手開發者會感到不熟悉的部分，而他的概念確實也比較複雜，本次就是好好講個Reflection，以及Reflection怎麼使用。</p><p>在幾篇前我們有提到過Java的生命週期是 透過javac把Java程式碼轉換成位元碼，再用JVM去讀取ByteCode並把ByteCode轉換成個平台都可以支援的機器碼。而程式碼的類別都是在編譯階段就已經被載入，並固定下來了。</p><p>而Reflection最大的特點就是允許程式碼在執行階段才載入類別。這麼做有甚麼好處呢？就是可以動態化處理問題，假設你今天有一個用來處理Excel資料的物件XLSWorker，他擁有一個readFile方法，來讀取xls的資料。今天你開發了一個新的功能XLSXWorker，而你想要測試這兩個物件的同一個readFile()方法時。這時，你對程式的關注點就不會是 物件本身，而是你希望的方法是否可以得到符合期待的輸出。程式碼的部分以例子來說，會像這樣。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 沒有使用Reflection的寫法</span><br><span class="hljs-type">XLSService</span> <span class="hljs-variable">xlsService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XLSService</span>();<br>xlsService.readFile(xlsFile);<br><br><span class="hljs-comment">//反射方法</span><br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;XLSService&quot;</span>); <span class="hljs-comment">// 替换为你的 XLSService 类的全限定名</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">xlsServiceInstance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance(); <span class="hljs-comment">// 使用默认构造函数创建实例</span><br><br><span class="hljs-comment">// 2. 通过反射获取 readFile 方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">readFileMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;readFile&quot;</span>, String.class); <span class="hljs-comment">// 假设 readFile 方法接受一个 String 类型的参数</span><br><br><span class="hljs-comment">// 3. 调用 readFile 方法</span><br>readFileMethod.invoke(xlsServiceInstance, xlsFile); <span class="hljs-comment">// 传入 xlsFile 作为参数</span><br></code></pre></td></tr></table></figure><p>除此之外，它還可以掃描類別以下擁有的方法，甚至可以從外部訪問類別的私有方法，這部分使她有了安全性上的疑慮，比方說以下的程式就可以掃描出類別下有哪些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br><br>Field[] fields = personClass.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field i : fields) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Field = &quot;</span>+i.getName()); <span class="hljs-comment">// 印出類別中所有的屬性</span><br>&#125;<br>Method[] methods = personClass.getDeclaredMethods(); <span class="hljs-comment">//宣告的方法</span><br><span class="hljs-keyword">for</span> (Method m : methods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Method = &quot;</span> + m.getName()); <span class="hljs-comment">// 印出類別中所有的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假設你是一名不懷好意的攻擊者，你就可以使用Reflection去讀取類別的所有屬性與方法藉而得知如何竊取或竄改資料，像是以下程式碼，就可以任意set 物件的值，你只需要知道類別的方法名稱就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">setObjectValue</span><span class="hljs-params">(Object object,String colName,Class colNameType,Object colVal)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>    Class&lt;?&gt; aClass = object.getClass(); <span class="hljs-comment">// 取得類別</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;set&quot;</span>+StringUtils.capitalize(colName),colNameType); <span class="hljs-comment">// 取得指定值的set方法</span><br>    method.invoke(object,colVal);<br>    <span class="hljs-keyword">return</span> (T) object;<br>&#125;<br><span class="hljs-comment">// TEST </span><br><span class="hljs-type">Billing</span> <span class="hljs-variable">billing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Billing</span>();<br><span class="hljs-type">Billing</span> <span class="hljs-variable">billingAfterSetId</span> <span class="hljs-operator">=</span> setObjectValue(billing,<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-type">int</span>.class,id);<br></code></pre></td></tr></table></figure><p>小弟過去的使用場景主要還是在撰寫測試時使用比較常見，有時當程式碼規模很大，你需要去測試某個你撰寫出來的private方法，但你又不想要修改方法的作用域時，Reflection就是一個比較好的選擇，另外Reflection也適合大量測試。</p><p>而Reflection的缺點也很明顯。一，Reflection的寫法會讓程式碼的維護難度直線上升，少了Compiler自動幫你處理型別判斷後，就連大小寫都會導致你開發上功能異常。二，安全性，因為可以透過Reflection方法直接訪問類別的內部結構與自動觸發方法，導致她很危險。三，在執行期間訪問類別會無可避免地導致效能低落。</p><p>以上就是我的一些整理，那麼明天見了。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Reflection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Projection</title>
    <link href="/2024/10/19/Spring-Projection/"/>
    <url>/2024/10/19/Spring-Projection/</url>
    
    <content type="html"><![CDATA[<p>我們在前幾次的單元中提到了延遲初始化的概念，但延遲初始化其實並不是解決問題的根本方法，當這個議題產生時，通常想要解決的問題就是──我們一次抓出太多不必要的資料了，</p><p>那有沒有一個方法，可以讓我們選擇只抓出部分的資料而不是全部呢？有的！去找吧！我把所有的資源都放在那裡了！那我們今天的分享就到這裡──</p><p>嘖！不行嗎？好吧。</p><p>Spring Projection 主要想要解決的問題，就是避免撈出不必要的資料，透過在Repository 回傳一個介面而不是物件的形式，比方說以下程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Part1.</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-meta">@OneToOne</span><br>    <span class="hljs-keyword">private</span> Person person;<br>    <span class="hljs-keyword">private</span> String state;<br>    <span class="hljs-keyword">private</span> String city;<br>    <span class="hljs-keyword">private</span> String street;<br>    <span class="hljs-keyword">private</span> String zipCode;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddressView</span> &#123;<br>    String <span class="hljs-title function_">getZipCode</span><span class="hljs-params">()</span>;<br>    <span class="hljs-meta">@Value(&quot;#&#123;target.city + &#x27; &#x27; + target.state&#125;&quot;)</span><br>    String <span class="hljs-title function_">getCityAndState</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddressRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;Address, Long&gt; &#123;<br>    List&lt;AddressView&gt; <span class="hljs-title function_">getAddressByState</span><span class="hljs-params">(String state)</span>;<br>&#125;<br><br><span class="hljs-comment">// Test</span><br><span class="hljs-type">AddressView</span> <span class="hljs-variable">addressView</span> <span class="hljs-operator">=</span> addressRepository.getAddressByState(<span class="hljs-string">&quot;CA&quot;</span>).get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// Hibernate: select address0_.zip_code as col_0_0_ from address address0_ where address0_.state=?</span><br>assertThat(addressView.getZipCode()).isEqualTo(<span class="hljs-string">&quot;90001&quot;</span>);<br>assertThat(addressView.getCityAndState()).isEqualTo(<span class="hljs-string">&quot;Los Angeles CA&quot;</span>);<br></code></pre></td></tr></table></figure><p>在上面的範例中，於JPA的Repository中建立了getAddressByState()方法，並指定回傳物件為List的AddressView這個自訂物件，這樣的查詢好處是只會選擇到被使用的欄位，避免選擇到不需要的物件造成資源的浪費。</p><p>接著我們再看一個例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String firstName;<br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-meta">@OneToOne(mappedBy = &quot;person&quot;)</span><br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonView</span> &#123;<br>    String <span class="hljs-title function_">getFirstName</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getLastName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Value(&quot;#&#123;target.firstName + &#x27; &#x27; + target.lastName&#125;&quot;)</span><br>    String <span class="hljs-title function_">getFullName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AddressView</span> &#123;<br>    PersonView <span class="hljs-title function_">getPerson</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// Test</span><br><span class="hljs-type">AddressView</span> <span class="hljs-variable">addressView</span> <span class="hljs-operator">=</span> addressRepository.getAddressByState(<span class="hljs-string">&quot;CA&quot;</span>).get(<span class="hljs-number">0</span>);<br><span class="hljs-type">PersonView</span> <span class="hljs-variable">personView</span> <span class="hljs-operator">=</span> addressView.getPerson();<br>assertThat(personView.getFirstName()).isEqualTo(<span class="hljs-string">&quot;John&quot;</span>);<br>assertThat(personView.getLastName()).isEqualTo(<span class="hljs-string">&quot;Doe&quot;</span>);<br></code></pre></td></tr></table></figure><p>我們修改了AddressView，使他可以回傳關聯物件(Person)的資料，但回傳的形式使用了另外一個Interface接，透過PesonView介面，我就可以訪問Person類別的firstName與lastName。</p><p>此外，Projection還有提供 動態投影的效果，比方說可以在上面的Repository加入這一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonDto</span> &#123;<br>    <span class="hljs-keyword">private</span> String firstName;<br>    <span class="hljs-keyword">private</span> String lastName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PersonDto</span><span class="hljs-params">(String firstName, String lastName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.firstName = firstName;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonView</span> &#123;<br>    String <span class="hljs-title function_">getFirstName</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getLastName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Value(&quot;#&#123;target.firstName + &#x27; &#x27; + target.lastName&#125;&quot;)</span><br>    String <span class="hljs-title function_">getFullName</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;Person, Long&gt; &#123;<br>    &lt;T&gt; T <span class="hljs-title function_">findByLastName</span><span class="hljs-params">(String lastName, Class&lt;T&gt; type)</span>;<br>&#125;<br><span class="hljs-comment">//Test</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> personRepository.findByLastName(<span class="hljs-string">&quot;Doe&quot;</span>, Person.class);<br><span class="hljs-type">PersonView</span> <span class="hljs-variable">personView</span> <span class="hljs-operator">=</span> personRepository.findByLastName(<span class="hljs-string">&quot;Doe&quot;</span>, PersonView.class);<br><span class="hljs-type">PersonDto</span> <span class="hljs-variable">personDto</span> <span class="hljs-operator">=</span> personRepository.findByLastName(<span class="hljs-string">&quot;Doe&quot;</span>, PersonDto.class);<br><br>assertThat(person.getFirstName()).isEqualTo(<span class="hljs-string">&quot;John&quot;</span>);<br>assertThat(personView.getFirstName()).isEqualTo(<span class="hljs-string">&quot;John&quot;</span>);<br>assertThat(personDto.getFirstName()).isEqualTo(<span class="hljs-string">&quot;John&quot;</span>);<br></code></pre></td></tr></table></figure><p>你可以使用各種類別或介面去封裝回傳的物件。當然，要確保屬性的命名與SpringDataJPA的風格一致。</p><p>那今天的部分就先到這邊吧，明天見了。</p><p>參考資料：</p><p><a href="https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html">https://docs.spring.io/spring-data/jpa/reference/repositories/projections.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring IOC 與 DI</title>
    <link href="/2024/10/19/Spring-IOC-%E8%88%87-DI/"/>
    <url>/2024/10/19/Spring-IOC-%E8%88%87-DI/</url>
    
    <content type="html"><![CDATA[<p>當初剛學Spring的時候，看著教學大談Spring的設計概念，一直都沒有什麼感覺，直到後來真正開始看大型專案時，才慢慢了解到Spring IOC 與 DI 的概念。 因為這部分 其實並不太好描述，我會參考其他人的描述加上自己的體悟慢慢說明它。</p><h3 id="IOC-Inversion-of-Control-是什麼？"><a href="#IOC-Inversion-of-Control-是什麼？" class="headerlink" title="IOC (Inversion of Control) 是什麼？"></a>IOC (Inversion of Control) 是什麼？</h3><p>IOC，中文稱作控制反轉，是Spring設計上最為核心的一點。以往整個應用程式的生命週期是由開發者所開發的程式碼定義的，開發者會根據需求建立當下所需要的服務，比方說new一個Scanner去偵測使用者的輸入等等。</p><p>那控制反轉簡單來說，就是把新建立物件這一件事，交給框架去處理，而不必自己撰寫。物件的宣告、使用與回收都交給Spring框架去執行，讓使用者可以更專注在開發的程式碼上面。</p><p>之所以會這樣做有很多原因，比方說前幾次談過的，物件在被new 之後，就會在記憶體中佔走一塊位子，不好好處理的話可能會造成記憶體資源的浪費或無法被釋放等等。那與其如此就交給框架幫你煩惱這部分。</p><p>那DI 是什麼呢？ DI 就是指IOC是怎麼被實現的，其實跟Spring沒啥關係，比方說以下程式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>   private int id;<br>   private <span class="hljs-title class_">String</span> name;<br>   private int score;<br>&#125;<br></code></pre></td></tr></table></figure><p>假設你想要引入Exam這個物件去協助計算整學期的平均，你可以怎麼做？</p><ol><li>Attribute Injection 就是直接引入，簡單暴力</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>   private int id;<br>   private <span class="hljs-title class_">String</span> name;<br>   private int score;<br>   <br>   @<span class="hljs-title class_">Autowired</span><br>   private <span class="hljs-title class_">ExamService</span> exam;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Constructor Injection 透過物件的建構式去注入你想使用的服務。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>   private int id;<br>   private <span class="hljs-title class_">String</span> name;<br>   private int score;<br>   private <span class="hljs-title class_">ExamService</span> exam;<br>   <br>   @<span class="hljs-title class_">Autowired</span><br>   public <span class="hljs-title class_">Student</span>(int id,<span class="hljs-title class_">String</span> name,<span class="hljs-title class_">ExamService</span> exam) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>=id;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">exam</span>=exam;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就這樣？對，就這樣。</p><p>另外，你們肯定會注意到 @Autowired這個註解吧，這個註解是代表了它被注入的對象是一個Spring Bean 物件，而不是一般物件，這代表的是框架會幫你在專案啟動階段時，就處理好物件的初始化。</p><p>但可以被Spring 容器管理的物件，本身必須得是一個Spring Bean。這點很重要，請筆記。以上面的例子來說，你必須將Exam物件宣告為一個Spring Bean，才能夠作用。同時Student也必須是一個SpringBean</p><p>Spring Bean 可以是一個屬性、可以是一個方法、也可以是一個物件，用途包山包海，在此不多做贅述。至於宣告物件成為Bean的方法呢…</p><p>說到這裡，你有玩過天歲之咲稻姬嗎？也許沒有，但沒關係，這不重要。</p><p>將物件宣告為Spring Bean的方法有很多種，也根據你的Java版本不同有差異。常見的部分有</p><p>@RestController、@Service、@Repository、@Component、@Configuration、@Bean等等。</p><p>你可以根據實際商業場景宣告符合需求的註解，他們各自有不同的用途，可以去了解看看。</p><p>今天的部分就到此為止了，下周見吧。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Inversion Of Control</tag>
      
      <tag>Dependency Injection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[2024鐵人賽]18-Spring Hibernate Cache</title>
    <link href="/2024/10/18/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-18-Spring-Hibernate-Cache/"/>
    <url>/2024/10/18/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-18-Spring-Hibernate-Cache/</url>
    
    <content type="html"><![CDATA[<p>在進行與資料庫溝通時，使用ORM是常見的作法，因此在開發上就少不了要面對Hibernate，儘管可能使用的技術是Spring JPA、JPQL等等，但Hibernate的持久化、快取等等都是同樣的。</p><p>之前在Transactional篇我們提到，在Session中與資料庫物件維持對應關係的狀態被稱作Persistent(持久)狀態，而在這個狀態中，為了減少對資料庫的負擔，Hibernate會將取出的資料放入在快取中，避免下一次索取相同資料時重複對資料庫發動不必要的請求而加重資料庫的負擔。</p><p>而這接下來就會有一個議題，Hibernate如何保持快取資料是正確的？</p><p>Hibernate會針對在Persistent狀態的物件建立一個複製品，用來比對是否物件遭到更改，也就是drity check的功能，來確保資料的正確。另外，只要在Session之中，一個持久化的物件就會對應到一個複製品，也就是存在兩個物件。</p><p>當今天在一個Session中資料非常大量存在時，因為這些資源在Session中不會被自動釋放，因此有可能會出現OOM (Out Of Memory) 的狀況。所以實務上為了避免這件事情發生，建議要固定將資料.flush()進資料庫並清除快取。</p><p>已預設情況來說，flush()的時機是在@Transactional結束後自動.flush()與，如果想要根據特殊情況手動觸發flush，以下舉例，假設我要每500筆資料強制寫入資料庫並清除快取。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@<span class="hljs-title class_">PersistenceContext</span><br>private <span class="hljs-title class_">EntityManager</span> entityManager; <span class="hljs-comment">// 使用EntityMangere管理實體</span><br><br><br>@<span class="hljs-title class_">Transactional</span><br>public <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchInsertStudents</span>(<span class="hljs-params">List&lt;Student&gt; students</span>) &#123;<br>    final int batchSize = <span class="hljs-number">500</span>;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; students.<span class="hljs-title function_">size</span>(); i++) &#123;<br>        <span class="hljs-comment">// 物件持久化</span><br>        entityManager.<span class="hljs-title function_">persist</span>(students.<span class="hljs-title function_">get</span>(i));<br>        <span class="hljs-comment">// 每500筆就flush 和 clear</span><br>        <span class="hljs-keyword">if</span> (i % batchSize == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) &#123;<br>            entityManager.<span class="hljs-title function_">flush</span>();  <span class="hljs-comment">// 將資料更改同步到資料庫</span><br>            entityManager.<span class="hljs-title function_">clear</span>();  <span class="hljs-comment">// 清除Session快取</span><br>        &#125;<br>    &#125;<br>    entityManager.<span class="hljs-title function_">flush</span>();<br>    entityManager.<span class="hljs-title function_">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>另外Hibernate的快取還有分為兩種，Session Level與SessionFactory Level，前者是只快取在Session中，另外一個則是可以在多個Session中被共同使用，更常見的說法我們稱呼它們為 一級快取(Session Cache) 與 二級快取(SessionFactory Session)。Session Level的快取會在Session結束後被清除，二級快取則只會在資料被更新時刪除舊的快取，因此有時二級快取的管理會有一些潛在問題發生。更多可以參考底下的連結。</p><p>今天的分享就先到這邊了，我們明天見了。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean延遲初始化</title>
    <link href="/2024/10/17/Spring-Bean%E5%BB%B6%E9%81%B2%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2024/10/17/Spring-Bean%E5%BB%B6%E9%81%B2%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>當你啟動一個專案，Spring Framework會將所有被定義為Bean的物件交給Spring 容器控制，Spring Bean 的一個主要特性是採用了Singleton(單例)模式，也就是Bean的生命週期不是由使用者掌控，而是交給框架，這也是IOC的精神。</p><p>但是你有沒有想過，假設你擁有一個開銷昂貴的服務，它的功能並不經常被使用，但是卻佔據了大量的效能，而且又是一個Bean。你可能會想，有沒有一個方法可以讓開發者自己去掌控這個物件的生命週期？</p><p>有，就是@Lazy這個功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Lazy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XXService</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">XXService</span><span class="hljs-params">()</span> &#123;<br>     System.out.print(<span class="hljs-string">&quot;XXService Init!&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Lazy提供了延遲初始化的功能，使Bean在專案啟動時，被建立的是一個Bean的代理而不是Bean本身，實際上Bean會在被注入到其他類別時才被載入並初始化。而定義方法除了定義在Class上之外，還有以下兩種</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyBean myBean;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(<span class="hljs-meta">@Lazy</span> MyBean myBean)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myBean = myBean;<br>    &#125;<br>    <br>&#125;<br><br>與<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(MyApp.class);<br>        app.setLazyInitialization(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 启用全局延迟初始化</span><br>        app.run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以定義@Lazy在依賴注入的位置，這會讓實際使用到功能時才初始化Bean，另外也可以像下方直接定義在SpringBoot的設定中(但不建議)</p><p>這種方法的優缺點如下：</p><p>優點：</p><ol><li>減少SpringBoot初始啟動的服務數量，資源的節省，重啟速度也會比較快。</li><li>只在需要時建立，避免冗餘占用。</li></ol><p>缺點：</p><ol><li>延遲，因為被延遲初始化建立的Bean會在被實際使用時才被建立，可能會發生建立花的時間超出預期導致不可預料的情況發生，也有可能初始化出錯，但因為不是由Spring容器掌控，沒有第一時間掌握到錯誤發生。</li></ol><p>除了Spring Bean之外，Hibernate的資料庫物件也同樣可以設定延遲初始化，Hibernate的延遲初始化通常是用來避免一次性載入到不需要的Entity，通常載入模式被分為兩種</p><ol><li>Eager Loading 立即載入</li><li>Lazy Loading 延遲載入</li></ol><p>而它們被使用的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br> <span class="hljs-keyword">private</span> String name;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> unic_id;<br> <br> <span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;skillTree&quot;)</span><br> <span class="hljs-keyword">private</span> Set&lt;SkillTree&gt; skillTreeSet;<br> <br> <span class="hljs-meta">@OneToOne(fetch = FetchType.EAGER)</span><br> <span class="hljs-meta">@JoinColumn(name = &quot;user_id&quot;)</span><br> <span class="hljs-keyword">private</span> User user<br>&#125;<br></code></pre></td></tr></table></figure><p>以上定義了一個角色類別(Character)，他對應到多組的技能樹(SkillTree)，但資料庫讀取Character資料時，不會預設一併讀取skillTree，減少不必要的資源浪費。另外針對User則是採用EAGER_LOADING。預設值是 toMany的採用LAZY，toOne的採用EAGER。</p><p>然而，俗話說得好，有一好就沒有兩好，但是有三好夏凜是我的 ( 誤</p><p>Hibernate使用延遲載入會有一個潛在問題，就是LazyInitializationException，如果試圖在Session已經關閉的時候訪問被關聯的資料時，因為無法載入，所以會出現此錯誤。想來也合理，你是不可能訪問得到你一開始沒有載入的實體的，比方說以下程式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/getMyCharacter&quot;)</span><br><span class="hljs-keyword">public</span> Character <span class="hljs-title function_">getMyCharacter</span><span class="hljs-params">(<span class="hljs-meta">@Reqeustparam</span> <span class="hljs-type">long</span> id)</span> &#123;<br><br><span class="hljs-type">Character</span> <span class="hljs-variable">myCharacter</span> <span class="hljs-operator">=</span> charaService.findCharacterByUnicId(id);<br><br><span class="hljs-type">SkillTree</span> <span class="hljs-variable">myCharacterSkillSet</span> <span class="hljs-operator">=</span> myCharacter.getSkillTreeSet(); <span class="hljs-comment">// 出錯</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解決方法如下：</p><ol><li>在Transactional中就把屬性載入。</li><li>使用JOIN語法，一開始就載入完整的實體，從而避免無法存取的問題</li></ol><p>以上就是今天的分享，@Lazy我在工作上很少看到，但一次看過後就一直很好奇他是什麼，看著看著就產出這篇記錄文章了，希望能對其他有類似困惑的朋友帶來一點幫助，那我們明天見吧</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Bean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Transaction (2024鐵人賽-15)</title>
    <link href="/2024/10/15/Spring-Transaction-2024%E9%90%B5%E4%BA%BA%E8%B3%BD-15/"/>
    <url>/2024/10/15/Spring-Transaction-2024%E9%90%B5%E4%BA%BA%E8%B3%BD-15/</url>
    
    <content type="html"><![CDATA[<p>做為一個後端工程師，除了要理解程式碼的運作以及副作用之外，對於資料庫的溝通也是重要一課，也許剛開始時沒那麼關鍵，但隨著系統的規模逐漸擴大，你對於系統的了解本身就變得相當重要了。</p><p>提到資料庫的存取，我們就不免地提到幾乎是家喻戶曉的ACID定律了。ACID是關聯式資料庫的基本特性，他們規範了一個交易，也就是與資料庫溝通的一個單位，必須具備甚麼特性。他們分別由：</p><ol><li>Atomicity 原子性</li><li>Consistency 一致性</li><li>Isolation 隔離性</li><li>Durability 持久性。</li></ol><p>共四樣組成，後續被開發出來的NOSQL等等，雖然沒有完全實現所有的特性，但也有不少做到了部分的實現，其重要度可見一斑。</p><p>原子性代表一個操作必須是全部成功、要不然就是全部失敗。舉例來說，你在麥當勞點了套餐並得到了加一元多一件的大薯，你無法在不買套餐，只用一元獲得大薯，這就是原子性。</p><p>一致性代表一個交易的前後都必須要符合完整性的規範，寫入的資料必須完全符合所有規範，套用同樣的約束、Trigger等等。</p><p>隔離性是一種資料庫處理多個併發交易對資料進行讀寫的能力，隔離性有分為四種級別來根據各種不同需求的商業場景進行操作。</p><p>持久性代表了交易對資料庫的寫入是永久的，不會因為系統的異常導致資料消失。</p><p>這些規範看起來很合理，但未必適合每種商業場景，實際上還是要多多考慮實際上的商業場景在做出決定。就好比高可用性與系統效能永遠都是一個無法兼得的選項一樣。端看你要如何取捨。</p><p>在這四項RDBMS的特性中，隔離性是最為複雜的一種，關於隔離性的設定往往沒有最佳解答，只有想出最合適的選項，並接受他的tradeoff(代價)。</p><p>在開始提隔離層級前，我們先來回憶一下之前提到的Hibernate建立一段會話的生命流程。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 開啟Session，相當於開啟JDBC的Connection</span><br><span class="hljs-title class_">Session</span> session = <span class="hljs-title class_">HibernateUtil</span>.<span class="hljs-title function_">getSessionFactory</span>().<span class="hljs-title function_">openSession</span>(); <br><span class="hljs-comment">// Transaction表示一組會話操作</span><br><span class="hljs-title class_">Transaction</span> tx= session.<span class="hljs-title function_">beginTransaction</span>(); <br><span class="hljs-comment">// 將物件映射至資料庫表格中儲存</span><br>session.<span class="hljs-title function_">save</span>(user);<br>tx.<span class="hljs-title function_">commit</span>(); <br>session.<span class="hljs-title function_">close</span>(); <br></code></pre></td></tr></table></figure><p>根據上面的說明，可以總結出一個會話是這樣的：</p><ol><li>建立一個與資料庫的Session</li><li>在Session中建立一筆Transaction</li><li>執行資料的讀寫 ( save()…flush()等等)</li><li>把進行中交易提交(commit)</li><li>關閉開啟的對話(Session)</li></ol><p>簡單帶過會話後，我們回到原先的話題，來開始提四種隔離層級吧，由最寬鬆到最嚴謹分別是：</p><ol><li><strong>Read Uncommitted。<br>這個隔離層級可以讀取其他執行緒中save()後尚未被commit()的資料。</strong></li><li>Read Committed。<br>這個隔離層級只允許讀取其他 transaction 已經commit的資料。避免了讀取到未被commit的資料，也就是Dirty Read髒讀問題。</li><li>Repeatable Read。<br>這個隔離層級下，一般的預設情況是，同樣的讀取，回應的資料都必須是一樣，這避免了因前後讀取同筆資料記錄導致資料不一致的問題，也就是No-repeatable Read。</li><li><strong>Serializable<br>這個隔離就是序列化，也就是說同時只允許一個執行緒對資料進行操作，這根本解決了隔離性併發存取的問題，但是基本上在現在分散式系統盛行的時代下不會使用。</strong></li></ol><p>另外，如果提到效能的話，排序就剛好相反，最上面的效率最快，最下面的效率最差，開發者必須要根據實際需求，設定合理的隔離層級。</p><p>納今天我們就講到這裡啦，明天見 掰掰。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot ControllerAdvice</title>
    <link href="/2024/10/14/SpringBoot-ControllerAdvice/"/>
    <url>/2024/10/14/SpringBoot-ControllerAdvice/</url>
    
    <content type="html"><![CDATA[<p>上一輪我們提到了，如果在Controller解析物件階段就出錯，就沒有辦法撰寫try catch去 捕捉這部分。這部分其實有很多種處理方法，以下我只介紹兩種。</p><p>第一種是比較簡易的做法，就是Spring的ErrorController，Spring預設顯示錯誤會使用ErrorController做為顯示，因此我們可以做的就是定義一個Controller類別並實作ErrorController，就能夠攔截例外，並封裝我們需要的資訊在裡面。比方說以下程式碼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomErrorController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ErrorController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/error&quot;)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">handleError</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        Map&lt;String, Object&gt; response = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> (Integer) request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.status_code&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">errorMessage</span> <span class="hljs-operator">=</span> (String) request.getAttribute(<span class="hljs-string">&quot;javax.servlet.error.message&quot;</span>);<br><br>        response.put(<span class="hljs-string">&quot;status&quot;</span>, statusCode);<br>        response.put(<span class="hljs-string">&quot;error&quot;</span>, errorMessage != <span class="hljs-literal">null</span> ? errorMessage : <span class="hljs-string">&quot;Unexpected error&quot;</span>);<br><br>        <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> statusCode != <span class="hljs-literal">null</span> ? HttpStatus.valueOf(statusCode) : HttpStatus.INTERNAL_SERVER_ERROR;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(response, status);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getErrorPath</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/error&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;error的程式碼中可以得知，我們利用了ResponseEntity包裝過了我們的回傳並加上了status 與 error 欄位，使回傳的資料是可以控制的。另外，getErrorPath()的作用是把錯誤的路徑轉到&#x2F;error路徑下，統一做錯誤處理。</p><p>這樣的做法是簡單直觀，但是能夠套用的方法有限，如果想要更大範圍的處理錯誤，我會建議使用其他方法，也就是這次要介紹的Spring ControllerAdivce。</p><p>Spring ControllerAdvice本身已經整合在SpringBoot中，不需要額外引入，它主要提供的方法有三種。</p><ol><li>Global 級別的的例外處理</li><li>資料預先處理</li><li>資料綁定</li></ol><p>先介紹第一種，也是我最常用的例外處理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice(assignableTypes = TestController.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(value = NameNotCorrectException.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleExceptionCollecter</span><span class="hljs-params">(HttpServletRequest req, Exception e)</span> &#123;<br>        <span class="hljs-comment">// 处理NameNotCorrectException的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;nameNotCorrect&quot;</span>; <span class="hljs-comment">// 返回错误页面或其他适当的响应</span><br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(value = IDNotCorrectException.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleNullPointerException</span><span class="hljs-params">(HttpServletRequest req, Exception e)</span> &#123;<br>        <span class="hljs-comment">// 处理NullPointerException的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ID NotCorrect&quot;</span>; <span class="hljs-comment">// 返回错误页面或其他适当的响应</span><br>    &#125;<br>    ...<br></code></pre></td></tr></table></figure><p>@RestControllerAdvice宣告了類別是ControllerAdvice，assignType定義了作用的類別。在底下我宣告了兩個自定義類別，只要Controller爆出這兩種錯誤，就會來到這裡，並回復字串給使用者。</p><p>再來是第二種，資料的預先處理。以下的範例是，宣告一個Binder去針對傳入參數做預處理，使用了CustomDateEditor把字串的時間轉換成Date()型別。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@InitBinder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> &#123;<br>    <span class="hljs-comment">// 把日期轉換為Date()</span><br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    dateFormat.setLenient(<span class="hljs-literal">false</span>);<br>    binder.registerCustomEditor(Date.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDateEditor</span>(dateFormat, <span class="hljs-literal">false</span>));<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/profile&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserProfile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;birthDate&quot;)</span> Date birthDate)</span> &#123;<br>        <span class="hljs-comment">// birthDate 已经通过 @InitBinder 进行转换</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#x27;s birth date is: &quot;</span> + birthDate;<br>&#125;<br></code></pre></td></tr></table></figure><p>最後是第三種，在ModelAttribute中事先添加元素，使Controller可以直接使用這個屬性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAttributes</span><span class="hljs-params">(Model model)</span> &#123;<br>        model.addAttribute(<span class="hljs-string">&quot;globalAttribute&quot;</span>, <span class="hljs-string">&quot;This is a global attribute&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/profileInfo&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProductInfo</span><span class="hljs-params">(ModelMap model)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">globalAttribute</span> <span class="hljs-operator">=</span> (String) model.get(<span class="hljs-string">&quot;globalAttribute&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product Info with Global Attribute: &quot;</span> + globalAttribute;<br>&#125;<br></code></pre></td></tr></table></figure><p>個人感想是，例外處理是最好用的，其他的部分儘管方便，但倒是也沒有到 非常必要，但是用來了解學習還是很不錯的，推薦給各位。</p><p>那麼今天的分享就到這邊，我們明天見，88。</p><p>參考資料：</p><p><a href="https://www.cnblogs.com/antaia11/p/15092280.html">https://www.cnblogs.com/antaia11/p/15092280.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Exception</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring TestContainer一次就懂</title>
    <link href="/2024/10/12/Spring-TestContainer%E4%B8%80%E6%AC%A1%E5%B0%B1%E6%87%82/"/>
    <url>/2024/10/12/Spring-TestContainer%E4%B8%80%E6%AC%A1%E5%B0%B1%E6%87%82/</url>
    
    <content type="html"><![CDATA[<p>當今天你想要進行Web Application的測試時，除了程式開發，外部的環境配置也是必不可少的，假設你想要開發一個MySQL的應用程式以及一個PostgreSQL的應用程式，你就會必須要在本地安裝兩份資料庫。這是過去的作法。</p><p>然而，僅僅因為測試就得安裝一個資料庫的新環境非常麻煩，所以後來在進行開發測試時，許多開發人員都會使用Docker，先在本機下載Image之後在本地執行。如此一來就不必要煩惱各SQL的安裝了。</p><p>TestContiner依據這樣的需求誕生，整合了Docker與SpringBootTest的功能，實作也很簡單。比方說今天想要測試我的API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StudentRepository repo;<br>    StudentController(StudentRepository repo) &#123;<br>        <span class="hljs-built_in">this</span>.repo = repo;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/api/student&quot;)</span><br>    List&lt;Student&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> repo.findAll();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Student, Long&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是安裝環境，安裝基本的Spring Web、取用資料的Spring JPA、資料庫的依賴(以下使用PostgreSQL舉例)、SpringBootTest、TestContainer與Rest Assured ( 提供整合測試使用的方法 )，如果你使用Maven的話，安裝應該會如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">///</span> <span class="hljs-string">...</span><br><span class="hljs-string">&lt;properties&gt;</span><br><span class="hljs-string">&lt;java.version&gt;17&lt;/java.version&gt;</span><br><span class="hljs-string">&lt;testcontainer.version&gt;1.19.8&lt;/testcontainer.version&gt;</span><br><span class="hljs-string">&lt;/properties&gt;</span><br><span class="hljs-string">///</span> <span class="hljs-string">...</span><br><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;spring-boot-testcontainers&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.testcontainers&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;org.testcontainers&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br><span class="hljs-string">&lt;dependency&gt;</span><br><span class="hljs-string">&lt;groupId&gt;io.rest-assured&lt;/groupId&gt;</span><br><span class="hljs-string">&lt;artifactId&gt;rest-assured&lt;/artifactId&gt;</span><br><span class="hljs-string">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="hljs-string">&lt;/dependency&gt;</span><br></code></pre></td></tr></table></figure><p>環境安裝後便可以著手撰寫測試程式了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentControllerTest</span> &#123;<br><br>    <span class="hljs-meta">@LocalServerPort</span><br>    <span class="hljs-keyword">private</span> Integer port;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用docker Image建立一個PostgreSQL的容器，容器內的位址是預設的5432</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> PostgreSQLContainer&lt;?&gt; postgres = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PostgreSQLContainer</span>&lt;&gt;(<br>            <span class="hljs-string">&quot;postgres:16-alpine&quot;</span><br>    );<br><br>    <span class="hljs-meta">@BeforeAll</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;PostgreSQL 開始建立&quot;</span>);<br>        postgres.start();<br>    &#125;<br><br>    <span class="hljs-meta">@AfterAll</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterAll</span><span class="hljs-params">()</span> &#123;<br>        postgres.stop();<br>        System.out.println(<span class="hljs-string">&quot;PostgreSQL 已終止&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@DynamicPropertySource</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureProperties</span><span class="hljs-params">(DynamicPropertyRegistry registry)</span> &#123;<br>        registry.add(<span class="hljs-string">&quot;spring.datasource.url&quot;</span>, postgres::getJdbcUrl);<br>        registry.add(<span class="hljs-string">&quot;spring.datasource.username&quot;</span>, postgres::getUsername);<br>        registry.add(<span class="hljs-string">&quot;spring.datasource.password&quot;</span>, postgres::getPassword);<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StudentRepository studentRepository;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        RestAssured.baseURI = <span class="hljs-string">&quot;http://localhost:&quot;</span> + port;<br>        studentRepository.deleteAll();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldGetAllStudents</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Student&gt; students = List.of(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;john@mail.com&quot;</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Dennis&quot;</span>, <span class="hljs-string">&quot;dennis@mail.com&quot;</span>)<br>        );<br>        studentRepository.saveAll(students);<br><br>        given()<br>                .contentType(ContentType.JSON) <span class="hljs-comment">// 請求時的Header</span><br>                .<span class="hljs-keyword">when</span>()  <br>                .get(<span class="hljs-string">&quot;/api/students&quot;</span>) <span class="hljs-comment">// 請求路徑</span><br>                .then()<br>                .statusCode(<span class="hljs-number">200</span>) <span class="hljs-comment">// 預計接受回傳statusCode</span><br>                .body(<span class="hljs-string">&quot;name&quot;</span>, everyItem(not(containsString(<span class="hljs-string">&quot;Clark&quot;</span>)))); <span class="hljs-comment">// 回傳中的每一個name都不可以包含Clark</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這段建構了一個PostgreSQL的Instance，並實際存入值後進行整合測試與驗證結果。我簡單講一下運作</p><ul><li>@SpringBootTest(webEnvironment &#x3D; SpringBootTest.WebEnvironment.RANDOM_PORT)<br>這段代表了SpringBootTest 會在隨機的Port執行 用來模擬外部的HTTP請求測試</li><li>@LocalServerPort<br>這段宣告了SpringBootTest的Port</li><li>@BeforeAll是一個SpringBootTest的方法，會在啟動之後，任何@Test執行之前被執行，且只會執行一次，可以看出這一段啟動了PostgreSQL容器。</li><li>@AfterAll在應用程式結束後把PostgreSQL容器停止。</li><li>@DynamicPropertySource<br>SpringBoot本來讀取資料庫相關位址資訊的是透過application.properties這個檔案，該註解的作用是動態配置application.properties的內容。這邊是取得容器的路徑與帳號密碼並覆蓋掉開發環境的application.properties</li><li>@BeforeEach<br>與BeforeAll不同，該方法會在每一個Test方法執行之前被執行，比方說這段定義了整合測試的路徑，並移除所有存放在Container的資料，避免資料重複存入。</li></ul><p>以上是Spring Container 的基本使用，個人覺得這個方法可以隔離開發環境驗證API，對於撰寫整合測試來說相當理想，另外如果本地沒有Docker Image，還可以協助安裝，推薦各位試試看。</p><p>那麼今天的文章就到這邊，感恩。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Test Container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring @Lombok介紹</title>
    <link href="/2024/10/11/Spring-Lombok%E4%BB%8B%E7%B4%B9/"/>
    <url>/2024/10/11/Spring-Lombok%E4%BB%8B%E7%B4%B9/</url>
    
    <content type="html"><![CDATA[<p>今天沒什麼時間，決定要來介紹輕鬆又簡單的Lombok，Lombok是一套Java的函式庫，內部包含了許多功能，包括：</p><ul><li>@Setter</li><li>@Getter</li><li>@Slf4j - 撰寫log的工具，經常以log開頭( ex.log.info())</li><li>@ToString - 撰寫物件的toString() 方法，若不複寫只會印出位址資訊</li><li>@NoArgsConstructor 建立無參數建構式</li><li>@AllArgsConstructor 建立所有參數的建構式</li><li>@RequireConstructor 建立包含所有final參數的建構式</li><li>@EqualsAndHash 自動複寫equals與hash方法</li><li>@Builder 遵循builerPattern 來建立物件</li><li>@Data &gt;&gt; getter + setter + toString + equals + hashCode + requireArgsConstructor</li></ul><p>以下是一個範例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br>@<span class="hljs-title class_">Slf4</span>j<br>@<span class="hljs-title class_">NoArgsConstructor</span><br>@<span class="hljs-title class_">AllArgsConstructor</span><br>@<span class="hljs-title class_">Builder</span><br>@<span class="hljs-title class_">Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>   private final int id;<br>   private final <span class="hljs-title class_">String</span> name;<br>   private <span class="hljs-title class_">String</span> status;<br>   private <span class="hljs-title class_">String</span> nickname;<br>&#125;<br></code></pre></td></tr></table></figure><p>這是使用了Lombok，讓我們看看沒使用Lombok的版本 ( 同功能 )</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs jsx">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    private <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Logger</span> log = <span class="hljs-title class_">LoggerFactory</span>.<span class="hljs-title function_">getLogger</span>(<span class="hljs-title class_">Student</span>.<span class="hljs-property">class</span>);<br><br>    private final int id;<br>    private final <span class="hljs-title class_">String</span> name;<br>    private <span class="hljs-title class_">String</span> status;<br>    private <span class="hljs-title class_">String</span> nickname;<br><br>    <span class="hljs-comment">// No-args constructor</span><br>    public <span class="hljs-title class_">Student</span>() &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nickname</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// All-args constructor</span><br>    public <span class="hljs-title class_">Student</span>(int id, <span class="hljs-title class_">String</span> name, <span class="hljs-title class_">String</span> status, <span class="hljs-title class_">String</span> nickname) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = status;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nickname</span> = nickname;<br>    &#125;<br><br>    <span class="hljs-comment">// Getters</span><br>    public int <span class="hljs-title function_">getId</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getStatus</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getNickname</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> nickname;<br>    &#125;<br><br>    <span class="hljs-comment">// Setters</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> status</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = status;<br>    &#125;<br><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNickname</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> nickname</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nickname</span> = nickname;<br>    &#125;<br><br>    <span class="hljs-comment">// toString</span><br>    @<span class="hljs-title class_">Override</span><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, status=&#x27;&quot;</span> + status + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// equals and hashCode</span><br>    @<span class="hljs-title class_">Override</span><br>    public boolean <span class="hljs-title function_">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || <span class="hljs-title function_">getClass</span>() != o.<span class="hljs-title function_">getClass</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-title class_">Student</span> student = (<span class="hljs-title class_">Student</span>) o;<br>        <span class="hljs-keyword">return</span> id == student.<span class="hljs-property">id</span> &amp;&amp; <br>               <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">equals</span>(name, student.<span class="hljs-property">name</span>) &amp;&amp;<br>               <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">equals</span>(status, student.<span class="hljs-property">status</span>) &amp;&amp;<br>               <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">equals</span>(nickname, student.<span class="hljs-property">nickname</span>);<br>    &#125;<br><br>    @<span class="hljs-title class_">Override</span><br>    public int <span class="hljs-title function_">hashCode</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Objects</span>.<span class="hljs-title function_">hash</span>(id, name, status, nickname);<br>    &#125;<br></code></pre></td></tr></table></figure><p>總之，Lombok利用註解來幫你省去一大筆要慢慢手寫物件建立與讀取方法的時間，我過去也很喜歡使用Lombok，但是他也未必都是好處。以下統整出它的缺點：</p><ol><li>高度侵入性。 Lombok 即使如此實用，他也沒有被加入springBoot裡面，而是一個第三方的套件，而且只要在專案使用了，就會建議一律使用，避免同時存在兩種方法不好管理。</li><li>管理不易，通常來說，我們可以透過點選function來找出他的usage，但lombok目前不行，也就是說如果使用Lombok，會導致你無法確認到底有多少地方使用它。</li><li>容易導致壞習慣，當想到建立物件時，想都沒想就放一個@Data上去，並不是一個好習慣，但使用Lombok常常會導致我們這麼做。</li><li>外部套件依賴有時會導致意想不到的問題發生，之前我有一次開發新專案時，引入了Lombok，結果因為套件版本異常，getter與setter出來的值全部變成null，但沒有任何exception回報，我找了一下子才發現是lombok的問題。</li></ol><p>以上就是我今天偷懶的分享，我們明天見，掰掰</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot的三層式架構</title>
    <link href="/2024/10/08/SpringBoot%E7%9A%84%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/"/>
    <url>/2024/10/08/SpringBoot%E7%9A%84%E4%B8%89%E5%B1%A4%E5%BC%8F%E6%9E%B6%E6%A7%8B/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot針對一個Rest Web Service，提出了三層式架構的概念，分別是Controller、Service、Repository。</p><p>以下我們簡單建立一個基本的三層式架構應用程式，並說明其中概念。</p><p>Controllers</p><p>Controller是API的進入口，主要的功能是傳入參數的檢測與一些資料的前處理。舉例來說，一個最基本的Cotnroller會像這樣。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@<span class="hljs-title class_">RestController</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">StudentService</span> studentService;<br><br>    @<span class="hljs-title class_">GetMapping</span>(<span class="hljs-string">&quot;/getOneStudent&quot;</span>)<br>    public <span class="hljs-title class_">Student</span> <span class="hljs-title function_">getOneStudent</span>(<span class="hljs-params">@RequestParam(<span class="hljs-string">&quot;name&quot;</span>) <span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!name.<span class="hljs-title function_">matches</span>(<span class="hljs-string">&quot;/s+&quot;</span>))&#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot;非姓名欄位&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> studentService.<span class="hljs-title function_">getStudent</span>(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RestController 是Spring的註解，代表這個class檔作為一個REST API 的 Controller被定義，在這裡可以撰寫各種endPoint(API入口)。</p><p>@Autowired 代表了交給Spring 管理的 Bean，並已全域模式注入到這個檔案中，這部分之後我會之後再說明，現在只需要了解它是一個Service，可以幫我們處理麻煩的事情就好。</p><p>@GetMapping(”&#x2F;getOneStudent”) 代表了一個endPoint，路徑為 &#x2F;getOneStudent。如果你啟動的話，他預設會連線到<a href="http://localhost:8080/getOneMerchant%E9%80%99%E5%80%8B%E8%B7%AF%E5%BE%91%E4%B8%8B%E3%80%82">http://localhost:8080/getOneMerchant這個路徑下。</a></p><p>EndPoint內部接收了一個參數，如果當初URL帶入的查詢條件有包含name的話，這裡就會被載入進去，他接著會利用正規表達式判斷String是否符合純英文不包含數字，如果判斷失敗的話將會回傳Null，否則呼叫StudentService.getStudent()方法取得Student資料。</p><p>看完了Controller部分，我們接著來了解實際上API是怎麼取得我們所需要的資料的。</p><p>Service是程式主要的功能區域，處理一個API最為複雜的商業邏輯部分。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">StudentRepository</span> studentRepository;<br><br>    public <span class="hljs-title class_">Student</span> <span class="hljs-title function_">getStudent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>) &#123;<br>        <span class="hljs-keyword">return</span> studentRepository.<span class="hljs-title function_">findByName</span>(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Service 宣告了這個.class是一個Service(廢話)，當中@Autowired引入了StudentRepository。</p><p>getStudent()的方法很簡單，就是又呼叫了一層，取得Student的資料。</p><p>你也許現在會很困惑為什麼要搞得這麼麻煩，但我必須說，當系統功能逐漸複雜，規模逐漸增大後，良好的把功能切分出來是很重要的，Debug時你就會很感謝的。</p><p>最後是Repository的部分，Repository掌管與資料庫的互動，主要是把資料庫的部分從Service層獨立出來。實際的程式碼會像是以下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@<span class="hljs-title class_">Repository</span><br>public interface <span class="hljs-title class_">StudentRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CrudRepository</span>&lt;<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Long</span>&gt; &#123;<br>    <span class="hljs-title class_">Student</span> <span class="hljs-title function_">findByName</span>(<span class="hljs-title class_">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>@Repository的功用…額我就不說了，你們猜得到的。這個StudentRepository的介面繼承了CrudRepository這個類別，這意味著它可以使用以下方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">public interface <span class="hljs-title class_">CrudRepository</span>&lt;T, <span class="hljs-variable constant_">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;T, <span class="hljs-variable constant_">ID</span>&gt; &#123;<br>    &lt;S <span class="hljs-keyword">extends</span> T&gt; S <span class="hljs-title function_">save</span>(S entity);<br>    &lt;S <span class="hljs-keyword">extends</span> T&gt; <span class="hljs-title class_">Iterable</span>&lt;S&gt; <span class="hljs-title function_">saveAll</span>(<span class="hljs-title class_">Iterable</span>&lt;S&gt; entities);<br>    <span class="hljs-title class_">Optional</span>&lt;T&gt; <span class="hljs-title function_">findById</span>(<span class="hljs-variable constant_">ID</span> id);<br>    boolean <span class="hljs-title function_">existsById</span>(<span class="hljs-variable constant_">ID</span> id);<br>    <span class="hljs-title class_">Iterable</span>&lt;T&gt; <span class="hljs-title function_">findAll</span>();<br>    <span class="hljs-title class_">Iterable</span>&lt;T&gt; <span class="hljs-title function_">findAllById</span>(<span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-variable constant_">ID</span>&gt; ids);<br>    long <span class="hljs-title function_">count</span>();<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span>(<span class="hljs-variable constant_">ID</span> id);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span>(T entity);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAllById</span>(<span class="hljs-title class_">Iterable</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-variable constant_">ID</span>&gt; ids);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span>(<span class="hljs-title class_">Iterable</span>&lt;? <span class="hljs-keyword">extends</span> T&gt; entities);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我就不一一細說，總之就是符合一般日常的對資料庫的異動功能。像上面的功能就是利用Name從資料庫中找出Student的資料，並回傳到Service，再回傳到Controller，最後回覆給API的使用者。以上就是一個最基本的三層式架構的應用程式。</p><p>今天的部分就到此為止了，明天見吧。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速鍵好一個SpringBoot專案</title>
    <link href="/2024/10/07/%E5%BF%AB%E9%80%9F%E9%8D%B5%E5%A5%BD%E4%B8%80%E5%80%8BSpringBoot%E5%B0%88%E6%A1%88/"/>
    <url>/2024/10/07/%E5%BF%AB%E9%80%9F%E9%8D%B5%E5%A5%BD%E4%B8%80%E5%80%8BSpringBoot%E5%B0%88%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>好啦，講了那麼多篇Java了，我想是時候來看看SpringBoot了</p><p>過去，還記得我在學生時期時，光是安裝Java JDK 等等的就可以搞上半天，你得要下載JDK，你還要知道自己需要的是Java EE還是Java SE，下載後你還要知道怎麼開啟系統環境變數加入path以及JAVA_HOME等等。舉凡少了一個細節都會讓一個初接觸程式的朋友感到挫折與對外面籃球場的憧憬。 ( 迷之聲：我還沒說Ecplise呢 )</p><p>所幸後來，JetBrain的Intellij IDEA 推出了，並最大化簡化了初始環境安裝的複雜程度，讓Java開發者不必在對Java安裝環境焦頭爛額。</p><p>首先，要安裝SpringBoot，你只需要安裝Intellij IDEA：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></p><p>如果你是免費仔的話安裝Community 版本，這個版本一些功能比較侷限，但如果你只是用來練習而非大量使用的話，Community就足夠應付了。</p><p>如果你是付費仔、或是學生的話可以安裝Ultimate版本，這個項目比較完整，但基本功能都是不受影響的，請各位自行選擇。</p><p>在等待安裝的同時，各位可以先開啟Spring官方提供的專案產生器：<a href="https://start.spring.io/;">Spring Initializr</a></p><p>在這裡你可以選擇你想要使用的版本及工具，若是懶得想，可以參考我的這張圖。</p><p>記得要引入Spring Web，因為我們要撰寫的是一個Web Application。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/48871ff2-43a1-4294-ac43-f706269b20d2/b27bbcd3-1719-4916-a911-c8f23e86391f/image.png" alt="image.png"></p><p>下載並解壓縮後，就可以使用你剛剛下載好的Intellij IDEA開啟專案。</p><p>接下來你應該會看到這樣的畫面，這就是一個最原始的SpringBoot專案，簡單吧。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/48871ff2-43a1-4294-ac43-f706269b20d2/6a5286ad-4cdd-464f-b32b-c06c25eceb25/image.png" alt="image.png"></p><p>再來介紹一下右邊的目錄結構，主要的程式碼都放在src目錄下，src底下有main與test，test主要是提供給寫測試案例時使用，一般開發的程式碼則會聚集在main中。</p><p>main中包含了java與resource，resource主要是可以放一些靜態資源，比方說圖片或檔案等等，以及前端的畫面會放在template位置，java就…..java。</p><p>另外有一個值得一提的就是application.properties這個檔案。application.properties 是SpringBoot用來簡化配置的一個檔案。假設你想要撰寫Application開放的port、DB的連線URL、是否要套用熱重啟等等都可以放在這裡配置，只要記得遵照SpringBoot的格式，就可以運作，而不必撰寫程式碼。</p><p>再來我們來看到DemoApplication這個檔案。這邊是程式的起始點，@SpringBootApplication宣告了這是一個SpringBoot的應用程式。</p><p>最後我們來看一下外面的pom.xml檔案。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/48871ff2-43a1-4294-ac43-f706269b20d2/4d17bc93-d60b-4be7-a2f0-9f2882315a69/image.png" alt="image.png"></p><p>你可能眼花撩亂，但沒關係，你不必每一行都了解它。先關注在現有的重點就好：</p><ol><li>name 它反映了你的應用程式的名稱</li><li>description 它反映了你的應用程式的描述</li><li>java.version 這部分決定了你要在專案使用的JDK版本</li><li><dependecies> 這部分內部就是放置你想要引入的dependency、比方說剛剛引入的Spring Web就會以 spring-boot-starter-web顯示在dependency在裡面，另外還有一些SpringBoot預設引入的dependency，就不一一多做介紹了。<br>之後若是要引入套件，不必自己寫，直接從Maven官方取得就可以複製貼上了，相當方便。<a href="https://mvnrepository.com/artifact/org.springframework/spring-aop/6.1.12">https://mvnrepository.com/artifact/org.springframework/spring-aop/6.1.12</a></li></ol><p>以上是我的極短SpringBoot專案介紹，下一輪我們要進行開發，後續會提到更多有關Spring SpringBoot的事，那麼我們下次見拉。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java hashcode()解說</title>
    <link href="/2024/10/05/Java-hashcode-%E8%A7%A3%E8%AA%AA/"/>
    <url>/2024/10/05/Java-hashcode-%E8%A7%A3%E8%AA%AA/</url>
    
    <content type="html"><![CDATA[<p>上回，我們針對Student物件覆寫了.equals()方法，通常在複寫.equals()後，很多人會建議需要一併覆寫.hashcode()方法，這是為什麼呢？</p><p>首先，我們先學習一個觀念。什麼是「Hash」？</p><p>中文叫做雜湊，Hash就是一種把資料重新處理過的一種方法，比方說雜湊演算法 ( SHA-1、MD5、SHA-256等等)，這樣針對資料產生出的一串亂數，我們常稱呼它為HashCode。舉常見的例子來說，數位簽章就是比對雙方產生出的Hash是否相同，來判斷內容有無遭到竄改。</p><p>看到這裡，你可能有些想法了，沒錯，hashCode()也在很多地方是用來比對的，比方說HashSet這個型別就會預設使用hashCode來判斷是否是同一個值。我們繼續上一篇的範例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">int</span> schoolId;<br>        Integer age;<br>        String name;<br>        <span class="hljs-type">char</span> rank;<br>        Student(<span class="hljs-type">int</span> schoolId, Integer age, String name, <span class="hljs-type">char</span> rank) &#123;<br>            <span class="hljs-built_in">this</span>.schoolId = schoolId;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.rank = rank;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object that)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.schoolId == ((Student) that).schoolId &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.age, ((Student) that).age) &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.name, ((Student) that).name) &amp;&amp;<br>                    <span class="hljs-built_in">this</span>.rank == ((Student) that).rank;<br>        &#125;<br>  &#125;<br><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">copyStudent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br>System.out.println(student.hashCode()); <span class="hljs-comment">//output: 162083492</span><br>System.out.println(copyStudent.hashCode()); <span class="hljs-comment">//output: 1135300227</span><br><br>HashSet&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>list.add(student);<br>list.add(copyStudent);<br>System.out.println(list.size()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>看第三、四行你可以發現，兩個Student物件的hashCode依然是不同的，這點導致了以下的HashSet中，將這兩個物件判斷為不同的物件，所以陣列長度為2。但我們知道，Set 集合這個資料結構 應該要能夠將重複的資料排除才對。</p><p>所以，我們要做的是，在複寫equals()方法後，同步複寫.hashCode()方法，程式碼如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">int</span> schoolId;<br>        Integer age;<br>        String name;<br>        <span class="hljs-type">char</span> rank;<br>        Student(<span class="hljs-type">int</span> schoolId, Integer age, String name, <span class="hljs-type">char</span> rank) &#123;<br>            <span class="hljs-built_in">this</span>.schoolId = schoolId;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.rank = rank;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object that)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.schoolId == ((Student) that).schoolId &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.age, ((Student) that).age) &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.name, ((Student) that).name) &amp;&amp;<br>                    <span class="hljs-built_in">this</span>.rank == ((Student) that).rank;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Objects.hash(schoolId, age, name, rank);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>這樣，兩個物件印出的hashCode就會是同一個值了，HashSet也才能夠正常運作。</p><p>接著我們來看看另外一個有關Hash的資料結構：HashMap。首先我們來看看HashMap的內部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>    ......<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next;<br>......<br></code></pre></td></tr></table></figure><p>可以看出，HashMap內部是一個Node結構，也就是LinkedList。內部包含了key、value、hash與下一個節點的指標。所以當一個HashMap放入一筆資料時，會先判斷當前位址有沒有存放，若已經存放了則前往下一個節點去存放值。</p><p>當使用.put()放入資料時，HashMap內部預設會根據hashCode決定要放在哪一個bucket裡面(hashCode 的來源是key值)，也會使用equals判斷物件是否內容相同，覆寫.hashCode可以提前讓Hashmap知道要放入的物件是否存在當前的結構中。</p><p>大概對物件的.equals()與.hashCode()方法就整理到這邊，細節上其實還有不少值得研究的部分，無奈本人學藝不精，只能講到這裡了。有想法的大大歡迎在底下補充，感謝各位的觀看。</p><p>參考資料：</p><p><a href="https://codegym.cc/tw/groups/posts/tw.210.java-ha-xi-ma-">https://codegym.cc/tw/groups/posts/tw.210.java-ha-xi-ma-</a></p><p><a href="https://openhome.cc/Gossip/JavaEssence/ObjectEquality.html">https://openhome.cc/Gossip/JavaEssence/ObjectEquality.html</a></p><p><a href="https://chikuwa-tech-study.blogspot.com/2023/10/java-hashmap-structure-design.html">https://chikuwa-tech-study.blogspot.com/2023/10/java-hashmap-structure-design.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[2024鐵人賽]02-Call By Value？、Call By Reference？ =與==與equals()關聯</title>
    <link href="/2024/10/02/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-02-Call-By-Value%EF%BC%9F%E3%80%81Call-By-Reference%EF%BC%9F-%E8%88%87-%E8%88%87equals-%E9%97%9C%E8%81%AF/"/>
    <url>/2024/10/02/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-02-Call-By-Value%EF%BC%9F%E3%80%81Call-By-Reference%EF%BC%9F-%E8%88%87-%E8%88%87equals-%E9%97%9C%E8%81%AF/</url>
    
    <content type="html"><![CDATA[<p>這章主要討論的點有兩個。</p><ol><li>Java Call By Value與Call By Reference都是什麼？</li><li>Java &#x3D;、&#x3D;&#x3D;、equals() 之間的差別以及如何使用？</li></ol><p>在開始之前，請讓我講個大約五十字的幹話。<br>這次感謝XX糾我一同參加鐵人賽，若不是他，我現在肯定躺在床上耍廢玩手機…嗯？我該感謝他嗎？唔…嗯…</p><p>好，算了，正文開始。</p><p>在初學Java時，有一些Java的觀念是你必須要認識的，像是 基本型別 (Primitive Type)與參考型別(Reference Type)，這兩個的差別在，當變數被改變時，基本型別被改變的是值本身，而參考型別改變的是參考的對象。</p><p>針對Call By Value可以參考以下例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> schoolId;<br>    Integer age;<br>    String name;<br>    <span class="hljs-type">char</span> rank;<br>    Student(<span class="hljs-type">int</span> schoolId, Integer age, String name, <span class="hljs-type">char</span> rank) &#123;<br>        <span class="hljs-built_in">this</span>.schoolId = schoolId;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.rank = rank;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceByHacker</span><span class="hljs-params">(<span class="hljs-type">int</span> schoolId, Integer age, String name, <span class="hljs-type">char</span> rank)</span> &#123;<br>    schoolId = <span class="hljs-number">99999</span>;<br>    age = <span class="hljs-number">9999</span>;<br>    name = <span class="hljs-string">&quot;Stolen&quot;</span>;<br>    rank = <span class="hljs-string">&#x27;F&#x27;</span>;<br>&#125;<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br>System.out.println(student);<br>replaceByHacker(student.schoolId,student.age,student.name,student.rank);<br>System.out.println(student);<br><br><span class="hljs-comment">//output</span><br>schoolId=<span class="hljs-number">1</span>, age=<span class="hljs-number">14</span>, name=John, rank=B<br>schoolId=<span class="hljs-number">1</span>, age=<span class="hljs-number">14</span>, name=John, rank=B<br></code></pre></td></tr></table></figure><p>比方說，我們有一個學生類別，我們定義它之後，先印出學生的資料，接著執行replaceByHacker()方法，想要竄改學生資料，但最後學生的資料並沒有被改變。<br>原因是傳入的參數是基本型別，也就是傳入的是”值”而不是”參考”，因此實際上在方法內部被更改後，也不會影響該變數。<br>接著我們來看另外一個例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceByHacker2</span><span class="hljs-params">(Student student)</span> &#123;<br>  student.age = <span class="hljs-number">777</span>;<br>&#125;<br>  System.out.println(student);<br>  replaceByHacker2(student);<br>  System.out.println(student);<br>  <br>  <span class="hljs-comment">//output</span><br>schoolId=<span class="hljs-number">1</span>, age=<span class="hljs-number">14</span>, name=John, rank=B<br>schoolId=<span class="hljs-number">1</span>, age=<span class="hljs-number">777</span>, name=John, rank=B<br></code></pre></td></tr></table></figure><p>在這個例子中，你可以在方法中更改student這個物件的屬性，但對物件本身也是無法被更改的，比方說你不能在方法中把student指定為null。</p><p>我自己的理解是，方法中你操作的這些參數都只是一個代理的對象，並不是值本身，所以以&#x3D;取代不會生效，但如果使用物件本身的方法改變物件的狀態，因為不是使用方法內的，所以可以被改變。<br>另外，Java本身也無法傳入記憶體位址，因此並沒有沒有Call By Reference的概念。<br>至於哪些屬於基本型別，哪些屬於參考型別的，可以看看這篇文章：<a href="https://yubin551.gitbook.io/java-note/basic_java_programming/datatype/referencedatatype">https://yubin551.gitbook.io/java-note/basic_java_programming/datatype/referencedatatype</a></p><p>綜合以上範例我們可以得出一道結論。針對 基本型別中 &#x3D; 所傳遞的是值，而針對參考型別 &#x3D; 所傳遞的是值的參考，為了更好地說明這件事，我們再舉個例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>b=a;<br></code></pre></td></tr></table></figure><p>這三行程式碼做了以下事：</p><ol><li>JVM在記憶體中宣告一個空間放了10，並把a指定給10</li><li>把k指定給10</li><li>JVM在記憶體中宣告一個空間放了5，並把b指定給5。</li><li>把a存放的10指定給b</li><li>a,b等於10</li></ol><p>這是傳遞值的例子，接下來是傳遞參考的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Some&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br><br>System.out.println(<span class="hljs-string">&quot;is a equal b ?&quot;</span> + (a == b)); <span class="hljs-comment">// output: true</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Car&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Car&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;is c equal d ?&quot;</span> + (c == d)); <span class="hljs-comment">// output: false</span><br>System.out.println(<span class="hljs-string">&quot;is c equal d ?&quot;</span> + (c.equals(d))); <span class="hljs-comment">// output: true</span><br></code></pre></td></tr></table></figure><p>前面都一樣，差別只是在第二行a將它的參考給了b，所以a b此時指向了同一個位置（記憶體位址）。</p><p>值得一提的是 c d 兩個變數，兩個都宣告為同一個”Car”，但是因為c d 兩個使用new String()方法宣告，並擁有各自的記憶體位址，且兩者並沒有指向同一個參考。所以 &#x3D;&#x3D; 比較的結果是 false。</p><p>同時，你也可以得知 &#x3D;&#x3D; 並不是值的比較，而是判斷兩個變數是否指向同一個位址。</p><p>所以，若要比較兩個字串實際上是否相同，則要使用.equals()。</p><p>基本上，非Primitive Type的型別我都不建議使用 &#x3D;&#x3D; 作為判斷是否相等的依據，因為不準。</p><p>再來我們來看下一題</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">copyStudent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br>System.out.println(student == copyStudent); <span class="hljs-comment">//output: false</span><br>System.out.println(student.equals(copyStudent)); <span class="hljs-comment">//output: false</span><br></code></pre></td></tr></table></figure><p>從剛剛我們可以得知&#x3D;&#x3D;比較的是記憶體位址，因此第三行為false是可理解的，但我想你一定會好奇為甚麼第四行不是true呢？這個原因是因為物件本身若沒有實作.equals()方法時預設套用Object的.equals()，也就是以下程式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>看到沒，他結果還是使用&#x3D;&#x3D; 去比較，所以，這也是為很多物件在建立後必須要複寫.equals()的原因，因為不準，之所以我說不準是因為，並不是所有時候都會呈現錯誤的結果，在一些複雜的情況下，可能你並不知道兩個物件的記憶體位址是否同源。</p><p>所以在實務上必須要額外覆寫成我們需要的判斷。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">int</span> schoolId;<br>        Integer age;<br>        String name;<br>        <span class="hljs-type">char</span> rank;<br>        Student(<span class="hljs-type">int</span> schoolId, Integer age, String name, <span class="hljs-type">char</span> rank) &#123;<br>            <span class="hljs-built_in">this</span>.schoolId = schoolId;<br>            <span class="hljs-built_in">this</span>.age = age;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.rank = rank;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object that)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.schoolId == ((Student) that).schoolId &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.age, ((Student) that).age) &amp;&amp;<br>                    Objects.equals(<span class="hljs-built_in">this</span>.name, ((Student) that).name) &amp;&amp;<br>                    <span class="hljs-built_in">this</span>.rank == ((Student) that).rank;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>以上是一些Java的觀念，下一回也會繼續談有關Java的一些特性，我們明天見吧。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[2024鐵人賽]01-2024了還學Java嗎？</title>
    <link href="/2024/10/01/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-01-2024%E4%BA%86%E9%82%84%E5%AD%B8Java%E5%97%8E%EF%BC%9F/"/>
    <url>/2024/10/01/2024%E9%90%B5%E4%BA%BA%E8%B3%BD-01-2024%E4%BA%86%E9%82%84%E5%AD%B8Java%E5%97%8E%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>大家好，我是一個學Java不到兩年的菜鳥工程師。為甚麼學了一年多我還是要堅稱菜鳥呢？這是因為Java的世界實在是太大了。我想即使花了四五年，也依然會對Java的許多功能感到十分陌生吧。</p><p>之所以會參與這次的鐵人賽，主要也是被朋友糾團，因為最低是三人組團但是剛好缺一人，於是我就補了進去。那話又說回來了，既然都參與了，我也覺得這是個好機會，可以整理自己這一年多來學習Java、Spring的種種知識，大到軟體設計的概念，小到怎麼使用一個API，都是在我這次鐵人賽會談到的範圍，30天內，我不只會提到SpringBoot、也會提到Java的一些基本概念，但不是從頭學，通常就一些觀念的補充，幫助你在基本的Coding外，對自己使用的工具有更多的一層認識。</p><p>這篇文章會適合什麼人？</p><ol><li>寫過、或至少聽過Java的人。</li><li>想要學習更多有關Java知識的人。</li><li>希望可以了解更多SpringBoot功能的人。</li><li>周末有空的人。</li></ol><p>如果你不屬於以上四類人，那建議你可以上一頁離開了，去做些真正讓你開心的事吧。人生寶貴，何必與自己的髮線過不去呢？</p><p>還沒走？很好，那，正文開始。<br>Java作為一名老前輩，目前已經有25年的歷史，也誕生出許多應用程式。Java的熱門程度，你可以參考這張圖。<br><a href="https://www.statista.com/statistics/793628/worldwide-developer-survey-most-used-languages/">https://www.statista.com/statistics/793628/worldwide-developer-survey-most-used-languages/</a><br>在2024年，最常被開發者使用的程式語言排行中，撇除非後端的資料，Java被使用的比率中僅小於Python，而Python近年來的崛起主要與AI、機器學習有關，由此可見，Java作為一個古老的語言依然保持著強大的競爭力。<br>它的主要優點如下：</p><ol><li>生態的成熟：<br>選擇一個古老且熱門的程式語言有許多好處，其中一項便是豐富的套件與社群資源，作為一名軟體開發者，有許多與你一樣的開發者也許早你一步遇見了某個你正困擾的難題，並給出了寫法。而你只需要照搬，就可以達到你的目的，這很大的一個幅度減少了面對不確定性的試錯成本。</li><li>向下相容性：<br>在多年Oracle(Java的公司)的開發者的努力之下，Java 有多個版本的JDK，從Java1.8到Java21版，你會在業界看到各種不同版本的Java，小弟我待的前公司甚至在部分專案中使用Java 7，不過那是另外一個故事。<br>總地來說，Java提供了高度的向下相容，針對已存在的企業級應用提供了相當好的支援。</li><li>強型別語言：<br>在我過去的公司，曾經有遇到這樣的問題。情境是這樣的，程式中有一段針對手續費的處理是這樣的。<br>String merchantFeeInWeek &#x3D; ((Integer) map.get(“fee”)).toString();<br>前面的map沒有指定value的型別。本來這段程式碼雖然不好看，但因為種種原因沒有人主動去改它，直到有一天金額高到超出預期時，這段就爆出錯誤了，原因是因為懶惰交給自動型別轉換所造成的問題。自動處理麻煩的型別本身是件好事，但我的看法是，如果一開始是可以被明確定義的，那就不該讓它模糊處理。可能比較麻煩，但這應該是必要的。</li></ol><p>以上，是我小小工程師對Java這門語言的一些小感想，若有不同的意見也歡迎在下方討論，那麼我們明天再會吧。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Google API 環境建置</title>
    <link href="/2024/09/15/Google-API-%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE/"/>
    <url>/2024/09/15/Google-API-%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Google Docs API 提供了讀取、寫入、更新三種API</strong></p></blockquote><p><img src="/img/google_survey_1.png" alt="image.png"></p><p>每個Google文件有各自專屬的documentId，如下：</p><aside>💡 `https://docs.google.com/document/d/{**DOCUMENT_ID}**/edit`</aside><h2 id="環境設定-Sample程式碼："><a href="#環境設定-Sample程式碼：" class="headerlink" title="環境設定&amp;Sample程式碼："></a>環境設定&amp;Sample程式碼：</h2><ul><li>開發環境 Java 17 with SpringBoot &#x2F; Java 1.8 以上版本必要。</li><li>套件管理 maven &#x2F; <a href="https://gradle.org/install/">Gradle 7.0 以上版本</a></li></ul><ol><li>在Google Cloud 專案啟用 API，如果沒有專案請新建一個。</li><li>啟用Google Docs API。</li></ol><p><img src="/img/google_survey_2.png" alt="image.png"></p><ol><li>開啟Google Cloud Console，點選「選單」 &gt; 「API 與 服務」 &gt; 「同意畫面」 &gt; User Type 選擇內部後建立。</li></ol><p><img src="/img/google_survey_3.png" alt="image.png"></p><ol start="2"><li>輸入支援Email後建立。</li></ol><p><img src="/img/google_survey_4.png" alt="image.png"></p><ol><li>在Google Cloud console中，點選「選單」&gt; 「API與服務」 &gt; 「憑證」 &gt; 「建立憑證」 &gt; 「OAuth Client ID」 &gt; 應用程式類型選擇「電腦版應用程式」、命名一個憑證名稱。</li></ol><p><img src="/img/google_survey_5.png" alt="image.png"></p><ol><li>建立完成後，需要下載憑證(<strong>credentials.json檔案)並放置到檔案的工作目錄</strong></li><li>引入需要的套件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.apis&lt;/groupId&gt;<br>    &lt;artifactId&gt;google-api-services-docs&lt;/artifactId&gt;<br>    &lt;version&gt;v1-rev20220609-<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.api-client&lt;/groupId&gt;<br>    &lt;artifactId&gt;google-api-client&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.oauth-client&lt;/groupId&gt;<br>    &lt;artifactId&gt;google-oauth-client-jetty&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.34</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt; <span class="hljs-comment">//Optional </span><br>    &lt;groupId&gt;com.google.apis&lt;/groupId&gt;<br>    &lt;artifactId&gt;google-api-services-drive&lt;/artifactId&gt;<br>    &lt;version&gt;v3-rev20240730-<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br><span class="hljs-comment">// 若使用Gradle則是以下</span><br>dependencies &#123;<br>    implementation <span class="hljs-string">&#x27;com.google.api-client:google-api-client:2.0.0&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.google.oauth-client:google-oauth-client-jetty:1.34.1&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.google.apis:google-api-services-docs:v1-rev20220609-2.0.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如果要使用其他功能，會需要Enable-其他的API"><a href="#如果要使用其他功能，會需要Enable-其他的API" class="headerlink" title="如果要使用其他功能，會需要Enable 其他的API"></a>如果要使用其他功能，會需要Enable 其他的API</h2><h1 id="參考文件："><a href="#參考文件：" class="headerlink" title="參考文件："></a>參考文件：</h1><p><a href="https://developers.google.com/docs/api/how-tos/overview?hl=zh-tw">https://developers.google.com/docs/api/how-tos/overview?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/quickstart/java?hl=zh-tw">https://developers.google.com/docs/api/quickstart/java?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/reference/rest?hl=zh-tw">https://developers.google.com/docs/api/reference/rest?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/reference/rest/v1/documents/get?hl=zh-tw">https://developers.google.com/docs/api/reference/rest/v1/documents/get?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/reference/rest/v1/documents/batchUpdate?hl=zh-tw">https://developers.google.com/docs/api/reference/rest/v1/documents/batchUpdate?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/samples/output-json?hl=zh-tw">https://developers.google.com/docs/api/samples/output-json?hl=zh-tw</a></p><p><a href="https://developers.google.com/docs/api/how-tos/move-text?hl=zh-tw">https://developers.google.com/docs/api/how-tos/move-text?hl=zh-tw</a></p><p><a href="https://developers.google.com/drive/api/guides/create-file?hl=zh-tw">https://developers.google.com/drive/api/guides/create-file?hl=zh-tw</a></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基本資料結構介紹</title>
    <link href="/2024/07/27/Java%E5%9F%BA%E6%9C%AC%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E4%BB%8B%E7%B4%B9/"/>
    <url>/2024/07/27/Java%E5%9F%BA%E6%9C%AC%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E4%BB%8B%E7%B4%B9/</url>
    
    <content type="html"><![CDATA[<p>這篇文章主要在介紹Java的各種集合資料結構，久久來複習一下基本功。</p><h2 id="Java-集合框架的主要類型與差異"><a href="#Java-集合框架的主要類型與差異" class="headerlink" title="Java 集合框架的主要類型與差異"></a>Java 集合框架的主要類型與差異</h2><p>Java 的集合框架提供了三大主要類型：<code>List</code>、<code>Set</code> 和 <code>Map</code>，每種類型都有不同的特性與適用場景。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特性：有序、允許重複元素、以索引存取</p><table><thead><tr><th>類型</th><th>特性</th><th>適用場景</th></tr></thead><tbody><tr><td><strong>ArrayList</strong></td><td>- 動態大小，基於陣列實現<br/>- 隨機讀取快 (<code>O(1)</code>)<br/>- 插入、刪除效率低 (<code>O(n)</code>)<br/>- 非同步<br/>- 容量自動擴充（1.5 倍）<br/>- 預設初始容量為 10</td><td>- 資料讀取頻繁、變動少的場合<br/>- 需要快速隨機存取<br/>- 主要在尾部新增&#x2F;刪除元素</td></tr><tr><td><strong>LinkedList</strong></td><td>- 雙向鏈結串列<br/>- 插入、刪除快 (<code>O(1)</code>)<br/>- 讀取效率低 (<code>O(n)</code>)<br/>- 非同步<br/>- 實現了 Deque 介面，可當作佇列或堆疊使用</td><td>- 資料頻繁插入、刪除的情況<br/>- 需要從兩端操作集合的場景<br/>- 不需要隨機存取</td></tr><tr><td><strong>Vector</strong></td><td>- 同步版的 ArrayList<br/>- 執行緒安全但效率較低<br/>- 容量自動擴充（2 倍）<br/>- 已被 Collections.synchronizedList() 取代</td><td>- 需要執行緒安全但不頻繁操作的場合<br/>- 建議使用 ArrayList 配合 Collections.synchronizedList()</td></tr></tbody></table><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>特性：無序、不允許重複元素、基於 equals() 和 hashCode() 判斷重複</p><table><thead><tr><th>類型</th><th>特性</th><th>適用場景</th></tr></thead><tbody><tr><td><strong>HashSet</strong></td><td>- 基於 <code>HashMap</code> 實現<br/>- 無序儲存，存取快 (<code>O(1)</code>)<br/>- 允許 null 元素<br/>- 非同步</td><td>- 需要快速去重的集合<br/>- 不在意元素順序<br/>- 需要 O(1) 時間複雜度的添加&#x2F;刪除&#x2F;查詢</td></tr><tr><td><strong>TreeSet</strong></td><td>- 基於 <code>TreeMap</code> 實現<br/>- 元素排序儲存<br/>- 不允許 null 元素<br/>- 使用自然排序或自定義 Comparator<br/>- 操作複雜度為 O(log n)</td><td>- 需要有序的去重集合<br/>- 需要範圍查詢<br/>- 需要獲得排序後的元素</td></tr><tr><td><strong>LinkedHashSet</strong></td><td>- 基於 <code>LinkedHashMap</code> 實現<br/>- 維護插入順序<br/>- 結合 HashSet 的快速和有序性</td><td>- 需要記住插入順序的去重集合<br/>- 需要可預測的迭代順序</td></tr></tbody></table><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>特性：key-value 資料結構、key 不可重複、value 可重複</p><table><thead><tr><th>類型</th><th>特性</th><th>適用場景</th></tr></thead><tbody><tr><td><strong>HashMap</strong></td><td>- 無序鍵值映射<br/>- 存取快 (<code>O(1)</code>)<br/>- 非同步<br/>- 允許 null 鍵和值<br/>- Java 8 後使用紅黑樹優化碰撞</td><td>- 單執行緒下的快速查詢與更新<br/>- 不需要排序的鍵值對應用</td></tr><tr><td><strong>TreeMap</strong></td><td>- 鍵值排序存儲<br/>- 基於紅黑樹<br/>- 存取速度為 <code>O(log n)</code><br/>- 不允許 null 鍵，允許 null 值<br/>- 可使用自定義 Comparator</td><td>- 需要按鍵排序的映射<br/>- 需要範圍操作<br/>- 需要最接近值查詢</td></tr><tr><td><strong>Hashtable</strong></td><td>- 同步版的 HashMap<br/>- 執行緒安全但效率較低<br/>- 不允許 null 鍵和值<br/>- 已被 ConcurrentHashMap 取代</td><td>- 建議使用 ConcurrentHashMap 替代<br/>- 舊系統維護</td></tr><tr><td><strong>LinkedHashMap</strong></td><td>- 維護插入順序或訪問順序<br/>- 結合 HashMap 的快速和有序性<br/>- 可實現 LRU 快取</td><td>- 需要記住鍵值對插入順序<br/>- 需要實現 LRU 快取機制</td></tr></tbody></table><h3 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h3><ol><li><p><strong>執行緒安全的選擇</strong>：</p><ul><li>使用 Collections 的同步包裝器：<code>Collections.synchronizedList/Set/Map()</code></li><li>使用 <code>java.util.concurrent</code> 包中的實現：<ul><li><code>CopyOnWriteArrayList</code></li><li><code>ConcurrentHashMap</code></li><li><code>ConcurrentSkipListSet/Map</code></li></ul></li></ul></li><li><p><strong>效能考量</strong>：</p><ul><li>初始容量設置：若預知集合大小，建議設定適當的初始容量</li><li>載入因子：HashMap&#x2F;HashSet 預設 0.75，可根據需求調整</li><li>迭代效能：LinkedHashMap&#x2F;Set 比 HashMap&#x2F;Set 稍慢，但提供可預測的迭代順序</li></ul></li><li><p><strong>選擇建議</strong>：</p><ul><li>一般場景：ArrayList、HashMap</li><li>需要排序：TreeSet、TreeMap</li><li>需要執行緒安全：ConcurrentHashMap、CopyOnWriteArrayList</li><li>需要記住順序：LinkedHashMap、LinkedHashSet</li></ul></li></ol><h2 id="Array-與-ArrayList-的差別"><a href="#Array-與-ArrayList-的差別" class="headerlink" title="Array 與 ArrayList 的差別"></a>Array 與 ArrayList 的差別</h2><h3 id="1-Array（陣列）"><a href="#1-Array（陣列）" class="headerlink" title="1. Array（陣列）"></a><strong>1. Array（陣列）</strong></h3><p><strong>簡介</strong>：</p><p><code>Array</code> 是 Java 中最基本的陣列結構，提供了固定大小的、連續存儲的數據結構。特性：</p><ul><li><strong>固定大小</strong>：在創建時需要指定大小，且不能動態調整。</li><li><strong>快速存取</strong>：<code>Array</code> 提供 <strong>O(1)</strong> 的隨機存取速度，非常適合頻繁讀取資料的場合。</li><li><strong>元素類型固定</strong>：只能存儲相同類型的元素，且元素可以是任何物件或基本類型（如 <code>int</code>、<code>char</code> 等）。</li></ul><p>兩者之間的比較</p><table><thead><tr><th>\</th><th>Array</th><th>ArrayList</th></tr></thead><tbody><tr><td><strong>大小</strong></td><td>固定</td><td>可動態調整</td></tr><tr><td><strong>型別</strong></td><td>支援基本類型與物件</td><td>只支援物件類型</td></tr><tr><td><strong>效能</strong></td><td>記憶體占用較少，效能較高</td><td>增刪元素時效能較低</td></tr><tr><td><strong>線程安全</strong></td><td>非同步</td><td>非同步</td></tr></tbody></table><h3 id="堆疊-Stack-：後進先出-LIFO-原理"><a href="#堆疊-Stack-：後進先出-LIFO-原理" class="headerlink" title="堆疊 (Stack)：後進先出 (LIFO) 原理"></a>堆疊 (Stack)：後進先出 (LIFO) 原理</h3><p><strong>堆疊（Stack）</strong> 是一種遵循<strong>後進先出（Last In, First Out, LIFO）</strong>的數據結構。在 Java 中，當方法被調用時，會被壓入堆疊頂部，方法結束後會從堆疊中彈出。</p><h4 id="運作原理："><a href="#運作原理：" class="headerlink" title="運作原理："></a>運作原理：</h4><p>假設方法調用順序如下：</p><p><code>method1()</code> → <code>method2()</code> → <code>method3()</code></p><ol><li><code>method3()</code> 會先執行並完成，然後從堆疊中彈出。</li><li>接著 <code>method2()</code> 完成並彈出。</li><li>最後 <code>method1()</code> 完成。</li></ol><h3 id="案例：呼叫堆疊-Call-Stack-與-堆疊追蹤-Stack-Trace"><a href="#案例：呼叫堆疊-Call-Stack-與-堆疊追蹤-Stack-Trace" class="headerlink" title="案例：呼叫堆疊 (Call Stack) 與 堆疊追蹤 (Stack Trace)"></a>案例：呼叫堆疊 (Call Stack) 與 堆疊追蹤 (Stack Trace)</h3><ul><li><strong>Call Stack</strong>：管理方法調用順序，每次方法調用會生成一個 <code>StackTraceElement</code>，記錄方法名稱、文件名、行號等，方法完成後該元素從堆疊中彈出。</li><li><strong>Stack Trace</strong>：當發生錯誤時，堆疊追蹤會列出從方法調用開始到錯誤發生時的完整堆疊路徑，幫助開發者定位錯誤來源。</li></ul><p>大致介紹如上。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本軟銀金流API筆記</title>
    <link href="/2024/06/21/%E6%97%A5%E6%9C%AC%E8%BB%9F%E9%8A%80%E9%87%91%E6%B5%81API%E7%AD%86%E8%A8%98/"/>
    <url>/2024/06/21/%E6%97%A5%E6%9C%AC%E8%BB%9F%E9%8A%80%E9%87%91%E6%B5%81API%E7%AD%86%E8%A8%98/</url>
    
    <content type="html"><![CDATA[<p>這邊是之前整理的筆記，公司之前串接了軟銀金流，我這邊也一併協助了金流相關Domain的整理，之前接觸的金流大多是台灣的銀行或支付商的API模式，第一次看到海外的也覺得有點新鮮。對日本金流這塊有興趣的也可以看看</p><h2 id="課金方式-用戶收款模式"><a href="#課金方式-用戶收款模式" class="headerlink" title="課金方式(用戶收款模式)"></a><strong>課金方式(用戶收款模式)</strong></h2><ul><li>都度課金 &#x3D; 每次交易都從信用卡扣款</li><li>継続課金（簡易） &#x3D; 根據軟銀規定日扣除固定金額</li><li>継続課金（定期・従量） &#x3D; 根據特店指定日期與指定金額扣款</li></ul><h2 id="売上方式-請款模式"><a href="#売上方式-請款模式" class="headerlink" title="売上方式(請款模式)"></a><strong>売上方式(請款模式)</strong></h2><ul><li>自動売上方式 &gt; 自動請款</li><li>指定売上方式 &gt; 手動請款</li></ul><h2 id="与信と売上-授權與請款"><a href="#与信と売上-授權與請款" class="headerlink" title="与信と売上(授權與請款)"></a><strong>与信と売上(授權與請款)</strong></h2><h2 id="提供功能介紹"><a href="#提供功能介紹" class="headerlink" title="提供功能介紹"></a>提供功能介紹</h2><table><thead><tr><th><strong>提供機能名(功能)</strong></th><th><strong>説明</strong></th></tr></thead><tbody><tr><td>購入<br/>(付款)</td><td>購入商品の決済を行う機能です。指定売上の場合は、与信を取得する機能となり、売上機能の実施が必要です。<br/>(指付款，若手動請款模式需使用請款功能)</td></tr><tr><td>売上<br/>(請款)</td><td>指定売上の場合に、与信後の取引を全額請求する機能です。加盟店の任意のタイミングで使用します。売上を実施しないとエンドユーザーに利用代金は請求されず、加盟店への入金もされません。<br/>(手動請款時，將授權金額進行全額請款的功能，不請款不扣除消費者錢，特店也不會收到金流)</td></tr><tr><td>部分売上<br/>(部分請款)</td><td>指定売上の場合に、与信後の取引に対して、エンドユーザーへ請求したい金額を指定して請求する機能です。※請求金額は、与信取得金額の範囲内となります。<br/>(部分請款，只請部分款項，勿超過授權金額)</td></tr><tr><td>取消<br/>(取消授權)</td><td>指定売上の場合に、与信後の取引を取消する機能です。売上後の取引に対しては、返金を使用します。  <br/> (取消授權，若已請款，則需呼叫退款)</td></tr><tr><td>返金<br/>(退款)</td><td>売上後の取引を全額返金する機能です。売上前の取引に対しては、取消を使用します。<br/>(請款後的全額退款功能。)</td></tr><tr><td>部分返金<br/>(部分退款)</td><td>売上後の取引に対して、返金したい金額を指定して返金する機能です。1回のみ使用可能です。<br/>(部分退款功能，只能退款一次)</td></tr><tr><td>複数回返金<br/>(多次退款)</td><td>売上後の取引に対して、返金したい金額を指定して複数回返金ができる機能です。利用代金が0円になるまで複数回使用可能です。<br/>(多次退款功能，退到不能退為止)</td></tr><tr><td>金額変更<br/>(金額變更)</td><td>与信後または売上後の取引に対して、変更したい金額を指定して変更する機能です。※与信取得金額および売上金額の範囲を超えての変更も可能です。<br/>(授權後或請款後，希望變更金額，可以超過當初的授權&#x2F;請款額度)</td></tr><tr><td>再与信<br/>(再授權)</td><td>過去の決済情報を利用して、別の決済として与信を取得する機能です。与信期限内の売上ができない場合などに利用します。<br/>(利用前次的付款資訊，再次付款的功能，用於超出請款期限的情境)</td></tr><tr><td>決済結果参照<br/>(查詢付款結果)</td><td>決済のステータスを確認できる機能です。<br/>(查詢付款結果)</td></tr><tr><td>入金通知</td><td>エンドユーザーがオフラインで支払い（コンビニ払い、振込等）を済ませたことを加盟店へ通知する機能です。  <br/>(針對線下付款用戶已經付款完成時通知特店之功能。)</td></tr><tr><td>支払期限切れキャンセル通知</td><td>オフラインの支払い（コンビニ払い等）の期限が過ぎたため、取引がキャンセルになったことを加盟店へ通知する機能です。<br/>(針對線下付款用戶未能及時付款導致取消通知)</td></tr><tr><td>継続課金（簡易）解約</td><td>継続課金（簡易）の登録を解約する機能です。解約以後の課金は、行いません。</td></tr><tr><td>継続課金（簡易）解約通知</td><td>課金ができなかった取引を加盟店へ通知する機能です。解約通知以後の課金は、行いません。</td></tr><tr><td>継続課金（定期・従量）申込</td><td>継続課金（定期・従量）で提供する購入商品の申込みを行う機能です。継続課金（定期・従量）の登録のみで課金は行いません。</td></tr><tr><td>継続課金（定期・従量）再申込</td><td>継続課金（定期・従量）で登録した課金金額を変更する機能です。</td></tr><tr><td>継続課金（定期・従量）購入</td><td>継続課金（定期・従量）で提供する購入商品の決済を行う機能です。</td></tr><tr><td>継続課金（定期・従量）解約</td><td>継続課金（定期・従量）の登録を解約する機能です。</td></tr></tbody></table><h2 id="軟銀規範"><a href="#軟銀規範" class="headerlink" title="軟銀規範"></a>軟銀規範</h2><ul><li>當月請款交易，消費者會於次月月底支付</li><li>當月交易，次月請款，消費者會於次次月底支付</li><li>信用卡金流可以進行2次清算。</li><li>都度課金：消費者在每次利用服務都扣款</li><li>継続課金（簡易）：根據軟銀規範(月初)從消費者身上扣除固定金額 </li><li>継続課金（定期・従量：根據店家指定的日期與金額進行消費者的金額扣除 </li><li>在特店請款後10天收到收支報表，請款後的次月月底會收到款項。 </li><li>1~15日的請款，月底收到款項 </li><li>16日至月底的請款，隔月15日會收到款項</li></ul><p>針對都度課金:</p><ul><li>自動請款 不需要請款 </li><li>手動請款 45日以內可以請款 </li><li>自動請款 無法取消 </li><li>手動請款 45天以內可以取消 </li><li>退款期限 6個月 </li><li>再授權期限 6個月</li></ul><p>大約整理如上，有不懂的可以在問我。</p>]]></content>
    
    
    <categories>
      
      <category>Finance</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SoftBank</tag>
      
      <tag>Payment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Optional API 紀錄</title>
    <link href="/2024/05/23/Java-Optional-API-%E7%B4%80%E9%8C%84/"/>
    <url>/2024/05/23/Java-Optional-API-%E7%B4%80%E9%8C%84/</url>
    
    <content type="html"><![CDATA[<p>之前我在寫Java時，總是覺得一直寫 if (obj !&#x3D; null) {} 這樣的處理會讓整體的程式碼變得不好看，我希望有一種API可以更好地協助我處理NLP問題，於是我後續就開始使用Optional這個套件<br>，覺得它挺好用的。它好用的點如下：</p><ul><li><p>提供兩種對Null的處理方式，使你更安全地操作你的變數。例如說：Optional.of() 與 Optional.ofNullable()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> Optional.ofNullable(object); <br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExist</span> <span class="hljs-operator">=</span> object.isPresent(); <span class="hljs-comment">// Null 顯示為 false</span><br><span class="hljs-keyword">if</span>(isExist) &#123;<br>    System.out.println(<span class="hljs-string">&quot;String = &quot;</span> + object.get());<br>&#125;<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> Optional.of(object); <span class="hljs-comment">// 若Object為Null會立即爆錯</span><br></code></pre></td></tr></table></figure></li><li><p>支援Lambda function</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> Optional.ofNullable(object);<br>object.ifPresent(name -&gt; System.out.println(name.length()));<br></code></pre></td></tr></table></figure></li><li><p>例外處理可以賦值、執行Lambda、拋錯誤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若InputName存在顯示InputName否則回傳orElse Value</span><br><span class="hljs-type">String</span> <span class="hljs-variable">inputName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Kevin&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Optional.ofNullable(inputName).orElse(<span class="hljs-string">&quot;John&quot;</span>); <br><br><span class="hljs-comment">// 如果為Null 可以使用orElse() 與 orElseGet() 處理Null問題</span><br><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">defaultText</span> <span class="hljs-operator">=</span> Optional.ofNullable(text).orElseGet(<span class="hljs-built_in">this</span>::getMyDefault);<br><span class="hljs-type">String</span> <span class="hljs-variable">defaultText</span> <span class="hljs-operator">=</span> Optional.ofNullable(text).orElse(getMyDefault());<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMyDefault</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Default Value&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 如果為null 拋出Exception</span><br><span class="hljs-type">String</span> <span class="hljs-variable">insertName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Kelvin&quot;</span>;<br>name = Optional.ofNullable(insertName).orElseThrow(IllegalArgumentException::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure></li><li><p>支援Java Stream API，提供更多資料處理的協助。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用filter可以篩選判斷</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">2016</span>;<br>Optional&lt;Integer&gt; yearOptional = Optional.of(year);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">is2016</span> <span class="hljs-operator">=</span> yearOptional.filter(y -&gt; y == <span class="hljs-number">2016</span>).isPresent();<br><br><span class="hljs-comment">// 可以使用 function進行值的檢測判斷</span><br><span class="hljs-type">Modem</span> <span class="hljs-variable">modem2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Modem</span>(<span class="hljs-number">13.10d</span>);<br>System.out.println(<span class="hljs-string">&quot;Result = &quot;</span> + priceIsInRange2(modem2));<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">priceIsInRange2</span><span class="hljs-params">(Modem modem2)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(modem2)<br>            .map(Modem::getPrice).<br>            filter(p -&gt; p &gt;= <span class="hljs-number">10</span>).<br>            filter(p -&gt; p &lt;= <span class="hljs-number">15</span>).<br>            isPresent();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modem</span> &#123;<br>      <span class="hljs-keyword">private</span> Double price;<br><br>      Modem(Double price) &#123;<br>          <span class="hljs-built_in">this</span>.price = price;<br>      &#125;<br>      <span class="hljs-comment">// standard getters and setters</span><br><br>      <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrice</span><span class="hljs-params">(Double price)</span> &#123;<br>          <span class="hljs-built_in">this</span>.price = price;<br>      &#125;<br><br>      Double <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">return</span> price;<br>      &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 利用map進行映射，再用filter處理值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; password &quot;</span>;<br>Optional&lt;String&gt; passOpt = Optional.of(password);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">correctPassword</span> <span class="hljs-operator">=</span> passOpt<br>.filter(pass -&gt; pass.equals(<span class="hljs-string">&quot;password&quot;</span>))<br>.isPresent();<br>assertFalse(correctPassword);<br>correctPassword = passOpt<br>.map(String::trim)<br>.filter(pass -&gt; pass.equals(<span class="hljs-string">&quot;password&quot;</span>))<br>.isPresent();<br>assertTrue(correctPassword);<br></code></pre></td></tr></table></figure></li><li><p>對Collection API的處理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用map 處理陣列</span><br>List&lt;String&gt; companyNames = Arrays.asList(<span class="hljs-string">&quot;paypal&quot;</span>, <span class="hljs-string">&quot;oracle&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;microsoft&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br>Optional&lt;List&lt;String&gt;&gt; listOptional = Optional.of(companyNames);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listOptional.map(List::size).orElse(<span class="hljs-number">0</span>);<br>System.out.println(<span class="hljs-string">&quot;SIZE = &quot;</span> + size);<br><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;john&quot;</span>, <span class="hljs-number">26</span>);<br>Optional&lt;Person&gt; personOptional = Optional.of(person);<br>Optional&lt;String&gt; nameOptional = personOptional<br>                                    .map(Person::getName)<br>                                    .orElseThrow(IllegalArgumentException::<span class="hljs-keyword">new</span>);<br>Optional&lt;String&gt; namesOptional = personOptional.flatMap(Person::getName);<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testflatMap</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    List&lt;Integer&gt; together = Stream.of(asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// Stream of List&lt;Integer&gt;</span><br>            .flatMap(List::stream)<br>            .map(integer -&gt; integer + <span class="hljs-number">1</span>)<br>            .collect(Collectors.toList());<br>    assertEquals(asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>), together);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = i;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Optional&lt;Integer&gt; <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(password);<br>    &#125;<br><br>    <span class="hljs-comment">// normal constructors and setters</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>更多參考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  取得第一個非null的值，Optional::get 是為了取得&lt;Stream&lt;String&gt;&gt;</span><br><span class="hljs-comment">//  方法會全數執行</span><br><span class="hljs-type">String</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> Stream.of(getEmpty(), getHello(), getBye())<br>        .filter(Optional::isPresent)<br>        .map(Optional::get)<br>        .findFirst()<br>        .get();<br><br><span class="hljs-comment">//  同樣意思，但方法不會全數執行</span><br>Optional&lt;String&gt; found2 =<br>      Stream.&lt;Supplier&lt;Optional&lt;String&gt;&gt;&gt;of(<span class="hljs-built_in">this</span>::getEmpty, <span class="hljs-built_in">this</span>::getHello, <span class="hljs-built_in">this</span>::getBye)<br>              .map(Supplier::get)<br>              .filter(Optional::isPresent)<br>              .map(Optional::get)<br>              .findFirst();<br><br><span class="hljs-comment">// 若function想要帶上參數 需使用lambda</span><br>Optional&lt;String&gt; found3 = Stream.&lt;Supplier&lt;Optional&lt;String&gt;&gt;&gt;of(<br>              () -&gt; createOptional(<span class="hljs-string">&quot;empty&quot;</span>),<br>              () -&gt; createOptional(<span class="hljs-string">&quot;hello&quot;</span>)<br>      )<br>      .map(Supplier::get)<br>      .filter(Optional::isPresent)<br>      .map(Optional::get)<br>      .findFirst();<br><br><span class="hljs-comment">//        判斷是否全數為null</span><br><span class="hljs-type">String</span> <span class="hljs-variable">found4</span> <span class="hljs-operator">=</span> Stream.&lt;Supplier&lt;Optional&lt;String&gt;&gt;&gt;of(<br>                () -&gt; createOptional(<span class="hljs-string">&quot;empty&quot;</span>),<br>                () -&gt; createOptional(<span class="hljs-string">&quot;E&quot;</span>)<br>        )<br>        .map(Supplier::get)<br>        .filter(Optional::isPresent)<br>        .map(Optional::get)<br>        .findFirst()<br>        .orElseGet(() -&gt; <span class="hljs-string">&quot;default&quot;</span>);<br><br>assertEquals(<span class="hljs-string">&quot;E&quot;</span>,found4);<br><br><span class="hljs-keyword">private</span> Optional&lt;String&gt; <span class="hljs-title function_">getEmpty</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> Optional.empty();<br>&#125;<br><br><span class="hljs-keyword">private</span> Optional&lt;String&gt; <span class="hljs-title function_">getHello</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> Optional&lt;String&gt; <span class="hljs-title function_">getBye</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-string">&quot;bye&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> Optional&lt;String&gt; <span class="hljs-title function_">createOptional</span><span class="hljs-params">(String input)</span> &#123;<br>    <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(input) || <span class="hljs-string">&quot;empty&quot;</span>.equals(input)) &#123;<br>        <span class="hljs-keyword">return</span> Optional.empty();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Optional.of(input);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解說SQL的Transaction與隔離層級</title>
    <link href="/2024/05/19/%E8%A7%A3%E8%AA%AASQL%E7%9A%84Transaction%E8%88%87%E9%9A%94%E9%9B%A2%E5%B1%A4%E7%B4%9A/"/>
    <url>/2024/05/19/%E8%A7%A3%E8%AA%AASQL%E7%9A%84Transaction%E8%88%87%E9%9A%94%E9%9B%A2%E5%B1%A4%E7%B4%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="什麼是Transaction？"><a href="#什麼是Transaction？" class="headerlink" title="什麼是Transaction？"></a>什麼是Transaction？</h2><p>Transaction，大陸有人翻譯為交易或事務，但都同一個意思。</p><span id="more"></span>它是一個執行過程中的一個邏輯單位。比方說SELECT、INSERT、UPDATE，當中也可能包含多個行為，比方說查詢後更新。為了確保資料庫的交易在各種情況下都是維持正確性，交易有四個特性，也就是俗稱的ACID。<h3 id="1-Atomicity-原子性"><a href="#1-Atomicity-原子性" class="headerlink" title="1. Atomicity 原子性"></a>1. <strong>A</strong>tomicity 原子性</h3><p>原子性主張交易必須要維持統一不變的狀況，交易必須是全數成功，不然就得是全部失敗。<br>舉例： 假設你是消費者，進行消費後在前台的交易系統有存入這筆交易，但是系統的交易後台卻沒有這筆交易，顯示更新這個功能<strong>只做了一半</strong>，交易的行為破壞了<strong>原子性</strong>。</p><h3 id="2-Consistency-一致性"><a href="#2-Consistency-一致性" class="headerlink" title="2. Consistency 一致性"></a>2. <strong>C</strong>onsistency 一致性</h3><p>一致性主張，交易前與交易後都必須要遵守完整性的規範，比方說店家前台的交易系統與系統後台<strong>必須要維持一致性</strong>，交易的結果不統一破壞了<strong>一致性</strong>。</p><h3 id="3-Isolation-隔離性"><a href="#3-Isolation-隔離性" class="headerlink" title="3. Isolation 隔離性"></a>3. <strong>I</strong>solation 隔離性</h3><p>隔離性代表了交易不應該互相干擾，假設你看到的戶頭有1000元，而你在領800去吃飯時，剛好電費同時扣款導致你無法進行交易。不夠嚴謹的隔離性後續會產生許多問題，等一下會一一介紹。</p><h3 id="4-Durability-永久性"><a href="#4-Durability-永久性" class="headerlink" title="4. Durability 永久性"></a>4. <strong>D</strong>urability 永久性</h3><p>永久性意味對於資料的寫入是永久的，即使系統故障也不會丟失資料。</p><p>這些規範看起來很合理，但未必適合每種商業場景，實際上還是要多多考慮實際上的商業場景在做出決定。就好比高可用性與系統效能永遠都是一個無法兼得的選項一樣。端看你要如何取捨。</p><h2 id="三種SQL隔離性會產生的問題"><a href="#三種SQL隔離性會產生的問題" class="headerlink" title="三種SQL隔離性會產生的問題"></a>三種SQL隔離性會產生的問題</h2><p>設定了錯誤的隔離層級會造成許多系統上難維護的課題，特別是在多執行緒的場景，使用Trasaction特性要特別謹慎。常見的隔離性不正確會有以下問題：</p><h3 id="1-Dirty-Read-髒讀"><a href="#1-Dirty-Read-髒讀" class="headerlink" title="1. Dirty Read 髒讀"></a>1. Dirty Read 髒讀</h3><p>指一筆交易在處理過程中讀取了另外一個交易”未提交”的數據。<br>舉例：<br>帳戶原有1000，<br>A會</p><ol><li>對帳戶領500</li><li>對帳戶存500<br>B會</li><li>讀取帳戶餘額。</li></ol><p>在兩者同時處理的併發情況下可能發生： A1 &gt; B &gt;A2<br>也就是說帳戶其實錢並沒有減少，但在B的視角中，可能產生帳戶少了500元的結果。</p><h3 id="2-Non-Repeatable-不可重複讀"><a href="#2-Non-Repeatable-不可重複讀" class="headerlink" title="2. Non-Repeatable 不可重複讀"></a>2. Non-Repeatable 不可重複讀</h3><p>指一個交易範圍內，多次查詢某個數據，卻得到不同的結果。<br>舉例：<br>呈上例，B初次讀取時得到了500，但過一下子讀取後又得到了1000。兩次結果不一致。</p><h3 id="3-Phantom-Read-幻讀"><a href="#3-Phantom-Read-幻讀" class="headerlink" title="3. Phantom Read 幻讀"></a>3. Phantom Read 幻讀</h3><p>一個交易範圍內，多次查詢某個數據，卻得到不同的資料筆數。</p><h2 id="四種隔離層級"><a href="#四種隔離層級" class="headerlink" title="四種隔離層級"></a>四種隔離層級</h2><h3 id="1-Read-Uncommitted"><a href="#1-Read-Uncommitted" class="headerlink" title="1. Read Uncommitted:"></a>1. Read Uncommitted:</h3><p>這個隔離層級可以讀取尚未commit的資料，因為資料包含為commit的資料，所以可能會產生以上三種問題。<br>這種隔離層級可能產生：</p><ul><li>髒讀</li><li>不可重複讀</li><li>幻讀</li></ul><h3 id="2-Read-Committed："><a href="#2-Read-Committed：" class="headerlink" title="2. Read Committed："></a>2. Read Committed：</h3><p>這個隔離層級只允許讀取其他 transaction commit 過的資料，可以解決髒讀的問題，<br>不過如果一個 transaction 的兩個 SELECT 語法間有另一個交易 commit 了新資料，<br>會造成第一次讀取與第二次讀取結果不一致的問題，也就是上面介紹過的不可重複讀。<br>這種隔離層級可能產生：</p><ul><li>不可重複讀</li><li>幻讀</li></ul><h3 id="3-Repeatable-Read"><a href="#3-Repeatable-Read" class="headerlink" title="3. Repeatable Read"></a>3. Repeatable Read</h3><p>同一個 transaction 內，除非自己修改，否則多次 SELECT 的結果都會相同，解決了不可重複讀的問題。<br>這種隔離層級可能產生：</p><ul><li>幻讀</li></ul><h3 id="4-Serializable"><a href="#4-Serializable" class="headerlink" title="4. Serializable"></a>4. Serializable</h3><p>在一開始提過，是一個用效能換取一致性的隔離層級，<br>讓所有 transaction 序列化執行，避免併發可能會造成的問題。<br>可解決問題但效能低落。</p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Software Knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【熊本弁】學習 Girl Band Cry 1 話出現的方言</title>
    <link href="/2024/05/19/%E3%80%90%E7%86%8A%E6%9C%AC%E5%BC%81%E3%80%91%E5%AD%B8%E7%BF%92-Girl-Band-Cry-1-%E8%A9%B1%E5%87%BA%E7%8F%BE%E7%9A%84%E6%96%B9%E8%A8%80/"/>
    <url>/2024/05/19/%E3%80%90%E7%86%8A%E6%9C%AC%E5%BC%81%E3%80%91%E5%AD%B8%E7%BF%92-Girl-Band-Cry-1-%E8%A9%B1%E5%87%BA%E7%8F%BE%E7%9A%84%E6%96%B9%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末就是補番時刻，這一季動畫真是琳瑯滿目，做為一名老宅宅，近年來越來越多深入人心的樂團番誕生，從孤獨搖滾到MyGO，這季還有Girl Band Cry這部，第一話做得很好，有興趣請大家一定要看看。這次要討論的是動畫第一話中出現的熊本弁，讓各位可以簡單上手熊本弁。</p><span id="more"></span><h2 id="什麼人適合閱讀這篇文章？"><a href="#什麼人適合閱讀這篇文章？" class="headerlink" title="什麼人適合閱讀這篇文章？"></a>什麼人適合閱讀這篇文章？</h2><ul><li>至少學過五十音，懂一點日文文法的</li><li>對樂團番、或動漫有興趣</li><li>在等明年阿北母雞卡出，想要換個胃口的人</li></ul><h3 id="わいさー"><a href="#わいさー" class="headerlink" title="わいさー"></a>わいさー</h3><p>「わいさー」在熊本弁中是感嘆詞，基本上沒有太多的意義在內，通常在表示驚訝的場合中被使用。相似的用法有</p><ul><li>わいさーし</li><li>わんさーし</li><li>わいさーぎ</li><li>わいさぎー</li></ul><p>用法皆相似，可以參考看看。</p><h3 id="なんしよっと"><a href="#なんしよっと" class="headerlink" title="なんしよっと"></a>なんしよっと</h3><p>「なんしよっと」換常用的語法就是 なにしてるの，也就是 你在做什麼？ 的意思，根據場合可能會產生 你在做什麼啊 的生氣、責備意思，請多留意。另外，似乎在福岡方言中也有一樣的用法在。</p><h3 id="ばい"><a href="#ばい" class="headerlink" title="ばい"></a>ばい</h3><p>「ばい」在全文中是”電話かけてきたばい”，也就是有打電話給你了喔，這樣，沒什麼好說的，可以理解為「よ」的意思。</p><h3 id="来んって"><a href="#来んって" class="headerlink" title="来んって"></a>来んって</h3><p>這個比較不屬於方言，應該說沒有辦法特定為哪個地區的方言，各地的方言都有出現，有興趣的朋友可以告訴我其他地區是否也有同樣的狀況。<br>「来んって」 &#x3D;&#x3D; 来なくて  不來的意思</p><h3 id="わかっとう"><a href="#わかっとう" class="headerlink" title="わかっとう"></a>わかっとう</h3><p>這個也是疑似在多地都出現過的方言，福岡比較常見。<br>「わかっとう」 可以理解為 分かってる　就是我明白的意思。</p><h3 id="けん"><a href="#けん" class="headerlink" title="けん"></a>けん</h3><p>這個也在各地都有出現，可以將けん理解為語助詞，～だから的意思。<br>例句：明日行くけん</p><h3 id="うるさか"><a href="#うるさか" class="headerlink" title="うるさか"></a>うるさか</h3><p>這個應該不用解釋了，就是うるさい的熊本弁。</p><h3 id="～と？"><a href="#～と？" class="headerlink" title="～と？"></a>～と？</h3><p>熊本弁有時會在句尾加入と，就是日文～なの的意思<br>例句：いけると？</p><h3 id="～なかと"><a href="#～なかと" class="headerlink" title="～なかと"></a>～なかと</h3><p>九州地方的方言，なかと 可以理解為 ない，比方說なかとよ　＞　ないんですよ</p><p>以上，提供參考，熊本方言雖然有很多與九州、福岡地區混在一起，但還是很有趣呢。不說了，我要去看第2話了。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ol><li><a href="https://rkk.jp/gamadase/k_detail.php?id=20070126021119">https://rkk.jp/gamadase/k_detail.php?id=20070126021119</a></li><li><a href="https://keepergiken.jp/keepre/4191/">https://keepergiken.jp/keepre/4191/</a></li><li><a href="https://ja.wikipedia.org/wiki/%E7%86%8A%E6%9C%AC%E5%BC%81">https://ja.wikipedia.org/wiki/%E7%86%8A%E6%9C%AC%E5%BC%81</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>日文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>熊本弁</tag>
      
      <tag>ガールズバンドクライ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什麼是TDD？如何實作？</title>
    <link href="/2024/05/18/%E4%BB%80%E9%BA%BC%E6%98%AFTDD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C%EF%BC%9F/"/>
    <url>/2024/05/18/%E4%BB%80%E9%BA%BC%E6%98%AFTDD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AF%A6%E4%BD%9C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="什麼是TDD？"><a href="#什麼是TDD？" class="headerlink" title="什麼是TDD？"></a>什麼是TDD？</h3><p>TDD，全名測試驅動開發(Test Driven Development)是一種軟體開發的方法論，顧名思義這種開發方式以測試驅動。使用TDD進行開發的流程如下：</p><span id="more"></span><ol><li>紅燈</li><li>綠燈</li><li>重構</li></ol><h4 id="紅燈階段"><a href="#紅燈階段" class="headerlink" title="紅燈階段"></a>紅燈階段</h4><p>這個階段必須要撰寫出一個必定會失敗的程式碼</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>TDD</tag>
      
      <tag>Methology</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Stream用法、MapStruct、Lombok語法</title>
    <link href="/2024/05/01/Java-Stream%E7%94%A8%E6%B3%95%E3%80%81MapStruct%E3%80%81Lombok%E8%AA%9E%E6%B3%95/"/>
    <url>/2024/05/01/Java-Stream%E7%94%A8%E6%B3%95%E3%80%81MapStruct%E3%80%81Lombok%E8%AA%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Java 8 加入Stream語法，提供了很多針對陣列物件的便利功能，以下介紹一些常見的用法。</p><span id="more"></span><h3 id="Java-Stream-常見用法"><a href="#Java-Stream-常見用法" class="headerlink" title="Java Stream 常見用法"></a>Java Stream 常見用法</h3><p>Java Stream 主要功能如下</p><ol><li>Filter 透過設定的條件過濾元素</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 找出非Empty數量<br>long memberCount = gameDevMember<br><span class="hljs-string">.stream</span><span class="hljs-params">()</span><br><span class="hljs-string">.filter</span><span class="hljs-params">(string -&gt; !string.isEmpty()</span>)<br><span class="hljs-string">.count</span><span class="hljs-params">()</span>;<br><br><span class="hljs-string">//</span> 找出非重複的第一位成員<br>String firstMember = gameDevMember<br><span class="hljs-string">.stream</span><span class="hljs-params">()</span><br><span class="hljs-string">.filter</span><span class="hljs-params">(string -&gt; !string.isEmpty()</span>)<br><span class="hljs-string">.distinct</span><span class="hljs-params">()</span><br><span class="hljs-string">.findFirst</span><span class="hljs-params">()</span><br><span class="hljs-string">.get</span><span class="hljs-params">()</span>;<br><br><span class="hljs-string">//</span> 找出 陣列中以AL1S開頭的任何一個，若沒有符合的回傳<span class="hljs-string">&quot;IS NOT EXIST&quot;</span><br>String findQueen = gameDevMember<br><span class="hljs-string">.stream</span><span class="hljs-params">()</span><br><span class="hljs-string">.filter</span><span class="hljs-params">(string -&gt; string.startsWith(&quot;AL1S&quot;)</span>)<br><span class="hljs-string">.distinct</span><span class="hljs-params">()</span><br><span class="hljs-string">.findAny</span><span class="hljs-params">()</span><br><span class="hljs-string">.orElse</span><span class="hljs-params">(&quot;IS NOT EXIST&quot;)</span>;<br><br><span class="hljs-string">//</span> 找出前三位成員<br>String findThreeMember = gameDevMember<br><span class="hljs-string">.stream</span><span class="hljs-params">()</span><br><span class="hljs-string">.filter</span><span class="hljs-params">(string -&gt; !string.isEmpty()</span>)<br><span class="hljs-string">.distinct</span><span class="hljs-params">()</span><br><span class="hljs-string">.limit</span><span class="hljs-params">(3)</span><br><span class="hljs-string">.collect</span><span class="hljs-params">(Collectors.joining()</span>);<br><br></code></pre></td></tr></table></figure><ol start="2"><li>Map 映射每个元素到對應的結果</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">List&lt;Food&gt; foodObj = Arrays.<span class="hljs-keyword">asList</span>(<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;酸辣湯&quot;</span>),<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;餛飩湯&quot;</span>),<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;肉羹湯&quot;</span>),<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;牛肉湯&quot;</span>),<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;貢丸湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;下水湯&quot;</span>));<br><br><span class="hljs-comment">// 取得物件的字串</span><br>List&lt;String&gt; foodList = foodObj.stream().map( food -&gt; food.getFoodName()).<span class="hljs-keyword">toList</span>();<br>System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;食物有&quot;</span>+foodList);<br></code></pre></td></tr></table></figure><ol start="3"><li>forEach 迭代Stream中的每個元素 ( 同樣可以修改 但是不會回傳)</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>List&lt;Food&gt; foodObj = Arrays.<span class="hljs-keyword">asList</span>(<br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;酸辣湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;餛飩湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;肉羹湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;牛肉湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;貢丸湯&quot;</span>), <br>    <span class="hljs-keyword">new</span> Food(<span class="hljs-string">&quot;下水湯&quot;</span>));<br><br>List&lt;String&gt; foodList = foodObj.stream()<br>.map( food -&gt; food.getFoodName())<br>.<span class="hljs-keyword">toList</span>();<br>System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;食物有&quot;</span>+foodList);<br><br><span class="hljs-comment">// 將所有FoodName 加上 NT$</span><br>foodObj<br>.stream()<br>.forEach(food -&gt; &#123;<br>food.foodName = <span class="hljs-string">&quot;NT$&quot;</span>+food.getFoodName();<br>&#125;);<br><br></code></pre></td></tr></table></figure><ol start="4"><li>reduce (元素匯總成單一結果。)</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">List&lt;<span class="hljs-keyword">Integer</span>&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">//將列表元素加總</span><br><span class="hljs-keyword">Integer</span> <span class="hljs-keyword">sum</span> = integers.stream().reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b);<br></code></pre></td></tr></table></figure><h3 id="MapStruct-用法，MapStruct可以將兩個類別互相轉換"><a href="#MapStruct-用法，MapStruct可以將兩個類別互相轉換" class="headerlink" title="MapStruct 用法，MapStruct可以將兩個類別互相轉換"></a>MapStruct 用法，MapStruct可以將兩個類別互相轉換</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserPo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br>    <span class="hljs-keyword">private</span> Date gmtCreate;<br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> buyerId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> age;<br>    <span class="hljs-keyword">private</span> String userNick;<br>    <span class="hljs-keyword">private</span> String userVerified;<br>&#125;<br><br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;<br>    <span class="hljs-keyword">private</span> Date gmtCreate;<br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> buyerId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> age;<br>    <span class="hljs-keyword">private</span> String userNick1;<br>    <span class="hljs-keyword">private</span> String userVerified;<br>&#125;<br><br><span class="hljs-comment">// 轉換器</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPersonMapper</span> &#123;<br>    IPersonMapper INSTANCT = Mappers.getMapper(IPersonMapper.<span class="hljs-keyword">class</span>);<br>    <span class="hljs-meta">@Mapping(target = <span class="hljs-string">&quot;userNick1&quot;</span>, source = <span class="hljs-string">&quot;userNick&quot;</span>)</span> <span class="hljs-comment">// 如果名稱不同無法對應 就使用 這個做Mapping</span><br>    <span class="hljs-meta">@Mapping(target = <span class="hljs-string">&quot;age&quot;</span>, source = <span class="hljs-string">&quot;age&quot;</span>, numberFormat = <span class="hljs-string">&quot;#0.00&quot;</span>)</span><br><br>    UserEntity poToentity(UserPo userPo);<br>&#125;<br><br><span class="hljs-comment">// 測試PO 與 Entity 轉換</span><br><span class="hljs-keyword">public</span> static void testNormal() &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----------testNormal-----start------&quot;</span>);<br>    UserPo userPo = UserPo.builder()<br>            .id(<span class="hljs-number">1L</span>)<br>            .gmtCreate(new Date())<br>           .buyerId(<span class="hljs-number">666L</span>)<br>           .userNick(<span class="hljs-string">&quot;測試mapstruct&quot;</span>)<br>           .userVerified(<span class="hljs-string">&quot;ok&quot;</span>)<br>           .age(<span class="hljs-number">18L</span>)<br>           .build();<br><br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;USERPO = &quot;</span> + userPo);<br>    UserEntity userEntity = IPersonMapper.INSTANCT.poToentity(userPo);<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;ENTITY = &quot;</span> + userEntity);<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;-----------testNormal-----ent------&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="Lombok-的Annonation"><a href="#Lombok-的Annonation" class="headerlink" title="@Lombok 的Annonation"></a>@Lombok 的Annonation</h3><ul><li>@Data 注解：<br>@Data 是 Lombok 提供的最常用的注解之一，它结合了 @ToString、@EqualsAndHashCode、@Getter、@Setter 以及 @RequiredArgsConstructor 的功能。它会自动生成这些方法，并为类的每个非静态字段创建 Getter 和 Setter 方法，还会生成 toString 方法和 equals、hashCode 方法。</li><li>@Builder 注解：<br>@Builder 是 Lombok 提供的注解，用于实现建造者模式。它生成一个嵌套的静态内部类 Builder，使得创建对象时可以链式调用，更加清晰和易读。使用 @Builder 注解时，您可以通过生成器模式设置实例的字段。</li><li>@AllArgsConstructor 注解：<br>@AllArgsConstructor 是 Lombok 提供的注解，用于生成一个包含所有参数的构造函数。它会为类的每个字段生成构造函数参数，方便创建对象时传入所有字段的值。</li><li>@NoArgsConstructor 注解：<br>@NoArgsConstructor 是 Lombok 提供的注解，用于生成一个无参数的默认构造函数。它可以在创建对象时使用，特别是当您在使用 @Builder 注解时，因为默认情况下，@Builder 注解需要一个无参构造函数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring AOP 基本概念與使用</title>
    <link href="/2024/05/01/Spring-AOP-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/01/Spring-AOP-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>到目前為止，在程式開發的發展上已經誕生了許多風格，如物件導向程式設計(Object-Oriented-Programming)、</p><span id="more"></span><p>Functional-Programming FP，這些方法都有好有壞，但都有共同的目的，就是簡化重複的程式碼，物件導向程式語言使用物件的封裝、繼承特性去約束程式碼，而FP則是專注在整個流程上，透過將功能建立為一個個微小的Function，進行開發。FP的好處是，通常可讀性可以提升不少。此外因為Function小，各功能也很好共用。<br>但今天要介紹的並不是這兩者，而是另外一種風格，被稱為切面導向程式設計(Aspect-Oriented-Programming)。<br>AOP的主要訴求是，將整個程式流程視為一個Flow，假設我有兩隻API，分別提供了付款、退貨兩功能。<br>付款的流程如下：驗證 &gt; 交易 &gt; 回傳結果<br>退貨的流程如下：驗證 &gt; 退貨 &gt; 回傳結果<br>而AOP核心精神就是將兩者相同的「驗證」部分提取出來作為一個切面(Aspect)，讓付款與退貨的API可以集中在真正重要的商業邏輯。也就是所謂的「關注點分離」的概念。<br>常見的Annotation如下：</p><ul><li>@Aspect - 將類別宣告為一個切面，切面方法放在裡面。</li><li>@Pointcut - 切入點。定義切入位置，通常使用execution切點表達式表達。</li><li>@Before 前置通知，常在切入方法執行前執行。若此方法回報異常，則不會執行方法。而是執行@After與@AfterThrowing</li><li>@After 後置方法 - 再切入方法執行後執行</li><li>@AfterReturn - 在方法正常結束return後執行</li><li>@AfterThrowing - 拋出異常後執行，若無異常則不會執行</li><li>@Around - 環繞通知，可以視為@Before+@After+@AfterThrowing+@AfterReturn</li><li>@Order - 指定切入執行順序</li></ul><h3 id="Spring-AOP-為何不生效？原因？"><a href="#Spring-AOP-為何不生效？原因？" class="headerlink" title="Spring AOP 為何不生效？原因？"></a>Spring AOP 為何不生效？原因？</h3><p><strong>A:</strong> 當切面在類別上運作時，我們使用的類別實際上是由Spring替我們生成了一個代理對象，故切面必須依賴於類別的呼叫。簡單來說 a.getMessage() 可以套用 AOP 但 getMessage() 是不行的！<br>解決方法：</p><ol><li><p>注入類別，使用self</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Component<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestBean</span> &#123;<br><br>    @Autowired<br>    <span class="hljs-keyword">private</span> TestBean self;  <span class="hljs-comment">// 这个装配的对象是代理对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        self.hi(); <span class="hljs-comment">// 這樣就會成功</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>啟用exposeProxy</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@EnableAspectJAutoProxy(exposeProxy=<span class="hljs-literal">true</span>)<br>@Component<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestBean</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        TestBean self = (TestBean) AopContext.currentProxy();  <span class="hljs-comment">// 获取当前代理</span><br>        self.hi();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>以下是一個範例的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrangeAOP</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(value = &quot;execution(* com.example.demo.controller..*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;前置通知&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;后置通知&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@AfterReturning(pointcut=&quot;pointcut()&quot;,returning = &quot;result&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">result</span><span class="hljs-params">(JoinPoint joinPoint,Object result)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;返回通知:&quot;</span>+result);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span>&#123;<br><br>    <span class="hljs-meta">@GettingMapping(&quot;/)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIndex</span><span class="hljs-params">()</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;Index&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is Index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>印出訊息的順序應該是 </p><p>前置通知 &gt; This is index &gt; 后置通知 &gt; 返回通知+result</p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在SpringBoot 寫測試 @Mock,@MockBean,MvcResult</title>
    <link href="/2024/05/01/%E5%9C%A8SpringBoot-%E5%AF%AB%E6%B8%AC%E8%A9%A6-Mock-MockBean/"/>
    <url>/2024/05/01/%E5%9C%A8SpringBoot-%E5%AF%AB%E6%B8%AC%E8%A9%A6-Mock-MockBean/</url>
    
    <content type="html"><![CDATA[<p>在Spring開發完後，我們需要測試自己撰寫的API有沒有問題。除了在SpringBoot專案預設的SpringBootTest中針對單個方法進行單位測試外，有時也會有需要去Mock，就是假造一個物件的需求。<br>假設今天程式比較複雜，需根據DB回傳的資料做判斷，而DB剛好沒有這樣的資料時，與其更動DB以符合測試，不如假造DB的內容，單測試API。換句話說，因為成本太高，所以利用假造的方式來撰寫符合需要規模的程式碼。</p><h3 id="Mockito框架"><a href="#Mockito框架" class="headerlink" title="Mockito框架"></a>Mockito框架</h3><p>Mockito是一個Mock框架，同時適用單元測試與整合測試。以下介紹常見的用法：</p><span id="more"></span><ol><li>@MockBean 可以用來假造Repository，也就是假造資料庫回傳的資料，因為是假造一整個物件，所以比較適合在整合測試中使用。舉例來說，像是以下用法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MockBean</span><br><span class="hljs-keyword">private</span> StudentRepository stuRepo;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">studentMock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    stu.setStudentId(<span class="hljs-string">&quot;001&quot;</span>);<br>    stu.setStudentName(<span class="hljs-string">&quot;Joe&quot;</span>); <br>    stu.setStudentCreateTime(LocalDateTime.now()); <br>    <span class="hljs-comment">// 假造一個Student物件</span><br><br>    Mockito.<span class="hljs-keyword">when</span>(studentRepo.getAbsentStudent(Mockito.anyString())).thenReturn(stu);<br>    <span class="hljs-comment">// 當 想要取得請假學生的資料時，就回傳假造的Student物件</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>想要假造方法或是變數，假設我有一個物件MainService。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> MainService <span class="hljs-title function_">MockConfig</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">MainService</span> <span class="hljs-variable">mainService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainService</span>();<br><span class="hljs-type">MainService</span> <span class="hljs-variable">mainService_mock</span> <span class="hljs-operator">=</span> Mockito.spy(mainService); <br>       <span class="hljs-comment">// 假造一個Mock物件</span><br><br>       Mockito.doReturn(<span class="hljs-literal">null</span>).<span class="hljs-keyword">when</span>(mainService_mock).SendRequest(Mockito.anyObject(),Mockito.anyString());<br>       <span class="hljs-comment">// 使MainService中的SendRequest()回傳Null</span><br><br>       Mockito.doNothing().<span class="hljs-keyword">when</span>(mainService_mock).validate(Mockito.anyObject()); <span class="hljs-comment">// 先不做欄位檢查</span><br><span class="hljs-comment">// 使MainService中的validate()方法跳過不執行(僅限方法沒有回傳值的狀況 void)</span><br><br>       ReflectionTestUtils.setField(mainService_mock, <span class="hljs-string">&quot;domain&quot;</span>, <span class="hljs-string">&quot;https://www.google.com.tw/&quot;</span>); <br>       <span class="hljs-comment">// 仿造MainService中的@Value</span><br><br>       ReflectionTestUtils.setField(mainService_mock, <span class="hljs-string">&quot;apiKey&quot;</span>, <span class="hljs-string">&quot;a4d1206bf951479fbcbe2e4bb6475d41&quot;</span>); <span class="hljs-comment">// 仿造 @Value</span><br><span class="hljs-comment">// 仿造MainService中的@Value</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="SpringMvc-單元測試"><a href="#SpringMvc-單元測試" class="headerlink" title="SpringMvc 單元測試"></a>SpringMvc 單元測試</h3><p>如果想要做部分整合測試，可以使用MvcResult去測試一個Rest API</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">HttpHeaders httpHeaders = <span class="hljs-built_in">new</span> HttpHeaders();<br>httpHeaders.<span class="hljs-keyword">add</span>(&quot;Content-Type&quot;, &quot;application/json&quot;);<br>httpHeaders.<span class="hljs-keyword">add</span>(&quot;Version&quot;, &quot;1.0.1&quot;);<br>httpHeaders.<span class="hljs-keyword">add</span>(&quot;ClientIp&quot;, &quot;1.1.1.1&quot;);<br><br>RequestBuilder requestBuilder =<br>        MockMvcRequestBuilders<br>                .<span class="hljs-keyword">get</span>(&quot;/api/transaction&quot;)<br>                .headers(httpHeaders)<br>                .param(&quot;type&quot;, &quot;Credit&quot;)<br>                .param(&quot;sum&quot;, &quot;10000&quot;);<br>// 要被測試的API需要建立一個ReqeustBuilder<br><br>MvcResult result = mockMvc.<span class="hljs-keyword">perform</span>(requestBuilder)<br>        .andDo(print())<br>        .andExpect(jsonPath(&quot;$.code&quot;).<span class="hljs-keyword">value</span>(&quot;0&quot;))<br>        .andExpect(jsonPath(&quot;$.message&quot;).<span class="hljs-keyword">value</span>(&quot;SUCCESS&quot;))<br>        .andReturn();<br>// 測試，回傳會印出一個標準化的規格。若不符合andExpect()的條件就會回報AssertionError<br><br><br></code></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Optional介紹與使用方法</title>
    <link href="/2024/04/24/Java-Optional%E4%BB%8B%E7%B4%B9%E8%88%87%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2024/04/24/Java-Optional%E4%BB%8B%E7%B4%B9%E8%88%87%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Optional是Java 8推出時加入的新功能，Optional被發明出來的初衷是為了解決Java常見的NullPointException。</p><span id="more"></span><p>為沒寫過Java的人科普一下，NullPointException大多數的發生原因都是針對value為Null進行操作而導致的例外狀況，Optional為此出現。</p><h4 id="Java-8-Optional-使用方式"><a href="#Java-8-Optional-使用方式" class="headerlink" title="Java 8 Optional 使用方式"></a>Java 8 Optional 使用方式</h4><p>使用方式很簡單，可以理解為將值外部再包了一層類別，比方說以下程式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Optional</span>&lt;Student&gt; student = <span class="hljs-keyword">Optional</span>.ofNullable(studentRepo.getAllStudent())<br></code></pre></td></tr></table></figure><p>Student類別的外部包了一個Optional類別，可以想像為程式外部又包了一個try catch的處理。</p><h4 id="Optioal常用的方法如下："><a href="#Optioal常用的方法如下：" class="headerlink" title="Optioal常用的方法如下："></a>Optioal常用的方法如下：</h4><ul><li>isPresent() <strong>判斷是否為Null，是則回傳True，否則回傳False</strong></li><li>get() <strong>取得Optional內的值，需要先使用isPresent()確認是否為Null</strong></li><li>Optional.of() <strong>建立Optional的方法，若為Null會直接報錯</strong></li><li>Optional.ofNullable() <strong>建立Optional的方法，可以放入Null與非Null物件</strong></li><li>ifPresent() <strong>如果值為非Null就執行某方法，沒有回傳值</strong></li><li>orElse() <strong>如果值為Null就用參數代替</strong></li><li>orElseGet() <strong>如果值為Null就執行該方法，與orElse()相差在可接受傳入參數不同</strong></li><li>orElseThrow() <strong>如果值為Null就拋出某些Exception</strong></li></ul><h4 id="以下介紹一些常用的方法"><a href="#以下介紹一些常用的方法" class="headerlink" title="以下介紹一些常用的方法"></a>以下介紹一些常用的方法</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Optional&lt;String&gt; opt = Optional.ofNullable(InputName);<br><span class="hljs-keyword">if</span>(opt.isPresent())&#123; // 判斷 是否為<span class="hljs-keyword">Null</span><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;String = &quot; + opt.<span class="hljs-keyword">get</span>()); // 非<span class="hljs-keyword">Null</span>才取值<br>&#125;<br><br>opt.ifPresent(<span class="hljs-type">name</span> -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>)); // 同一個意思，只是寫得比較簡潔<br><br>String <span class="hljs-type">name</span> = Optional.ofNullable(InputName).orElse(&quot;John&quot;); //若inputName 是 <span class="hljs-keyword">null</span> 回傳&quot;John&quot;<br><br>opNull.orElseGet(() -&gt; &quot;John&quot;); // 同個意思 只是orElseGet() 接受的是方法<br><br><span class="hljs-type">name</span> = Optional.ofNullable(insertName).orElseThrow(IllegalArgumentException::<span class="hljs-built_in">new</span>); // <span class="hljs-keyword">null</span>　就拋出IllegalArgumentException<br></code></pre></td></tr></table></figure><h4 id="更多實際應用"><a href="#更多實際應用" class="headerlink" title="更多實際應用"></a>更多實際應用</h4><p>使用Optional還有一個好處，就是可以套用Java 8 的API</p><ol><li>判斷是否為2016年</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Optional&lt;Integer&gt; yearOptional <span class="hljs-operator">=</span> Optional.of(year)<span class="hljs-comment">;</span><br>boolean is2016 <span class="hljs-operator">=</span> yearOptional<br>                    .filter(y -&gt; y <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">2016</span>)<br>                    .isPresent()<span class="hljs-comment">; // 判斷值是否為2016年</span><br></code></pre></td></tr></table></figure><ol start="2"><li>判斷物件價格範圍是否介於15~20之間</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可以使用 function進行值的檢測判斷</span><br>Modem modem2 = new Modem(<span class="hljs-number">13.10d</span>);<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Result = &quot;</span> + priceIsInRange2(modem2));<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Modem</span> &#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-built_in">Double</span> price;<br><br>      <span class="hljs-keyword">public</span> Modem(<span class="hljs-built_in">Double</span> price) &#123;<br>          <span class="hljs-keyword">this</span>.price = price;<br>      &#125;<br>      <span class="hljs-comment">// standard getters and setters</span><br><br>      <span class="hljs-keyword">public</span> void setPrice(<span class="hljs-built_in">Double</span> price) &#123;<br>          <span class="hljs-keyword">this</span>.price = price;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-built_in">Double</span> getPrice() &#123;<br>          <span class="hljs-keyword">return</span> price;<br>      &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> boolean priceIsInRange2(Modem modem2) &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(modem2)<br>            .map(Modem::getPrice).<br>            filter(p -&gt; p &gt;= <span class="hljs-number">10</span>).<br>            filter(p -&gt; p &lt;= <span class="hljs-number">15</span>).<br>            isPresent();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>先處理過再判斷。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">String password = <span class="hljs-string">&quot; password &quot;</span>;<br><span class="hljs-type">Optional</span>&lt;String&gt; passOpt = <span class="hljs-type">Optional</span>.of(password);<br>boolean correctPassword = passOpt<br>.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">pass</span> -&gt; <span class="hljs-keyword">pass</span>.equals(<span class="hljs-string">&quot;password&quot;</span>))<br>.isPresent();<br>assertFalse(correctPassword);<br><br>correctPassword = passOpt<br>.<span class="hljs-built_in">map</span>(String::trim)<br>.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">pass</span> -&gt; <span class="hljs-keyword">pass</span>.equals(<span class="hljs-string">&quot;password&quot;</span>))<br>.isPresent();<br>assertTrue(correctPassword);<br></code></pre></td></tr></table></figure><ol start="4"><li>取得陣列長度，null為0</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">companyNames</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">asList</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;paypal&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;oracle&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;microsoft&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;apple&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">Optional</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;&gt;</span> <span class="hljs-variable">listOptional</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">Optional</span><span class="hljs-operator">.</span><span class="hljs-variable">ofNullable</span><span class="hljs-punctuation">(</span><span class="hljs-variable">companyNames</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-variable">listOptional</span><span class="hljs-operator">.</span><span class="hljs-variable">map</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">List</span><span class="hljs-string">::size</span><span class="hljs-punctuation">)</span><span class="hljs-operator">.</span><span class="hljs-variable">orElse</span><span class="hljs-punctuation">(</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">out</span><span class="hljs-operator">.</span><span class="hljs-variable">println</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;SIZE = &quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">size</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>map 與 flatmap 的差異 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 假設我們有一個包含字串的列表</span><br>List&lt;String&gt; words = Arrays.<span class="hljs-keyword">asList</span>(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Stream&quot;</span>, <span class="hljs-string">&quot;API&quot;</span>);<br><br><span class="hljs-comment">// 使用map操作，將每個字串轉換為它的長度</span><br>List&lt;Integer&gt; wordLengths = words.stream()<br>        .map(String::length)<br>        .<span class="hljs-keyword">collect</span>(Collectors.<span class="hljs-keyword">toList</span>());<br>System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;使用 map 操作得到的長度列表: &quot;</span> + wordLengths);<br><br><span class="hljs-comment">// 使用flatMap操作，將每個字串拆分為單個字符並平坦化為單獨的流</span><br>List&lt;Character&gt; characters = words.stream()<br>        .flatMap(word -&gt; word.chars().mapToObj(c -&gt; (<span class="hljs-keyword">char</span>) c))<br>        .<span class="hljs-keyword">collect</span>(Collectors.<span class="hljs-keyword">toList</span>());<br>System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;使用 flatMap 操作得到的字符列表: &quot;</span> + characters);<br><br><span class="hljs-regexp">/ /</span>使用 map 操作得到的長度列表: [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">// 使用 flatMap 操作得到的字符列表: [J, a, v, a, S, t, r, e, a, m, A, P, I]</span><br> <br></code></pre></td></tr></table></figure></li><li>參考用法<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//  取得第一個非null的值，Optional::get 是為了取得&lt;Stream&lt;String&gt;&gt;</span><br><span class="hljs-comment">//  方法會全數執行</span><br><span class="hljs-built_in">String</span> found = Stream.of(getEmpty(), getHello(), getBye())<br>        .filter(Optional<span class="hljs-type">::isPresent</span>)<br>        .<span class="hljs-built_in">map</span>(Optional<span class="hljs-type">::get</span>)<br>        .findFirst()<br>        .get();<br><br><span class="hljs-comment">//  同樣意思，但方法不會全數執行</span><br>Optional&lt;<span class="hljs-built_in">String</span>&gt; found2 =<br>      Stream.&lt;Supplier&lt;Optional&lt;<span class="hljs-built_in">String</span>&gt;&gt;&gt;of(this<span class="hljs-type">::getEmpty</span>, this<span class="hljs-type">::getHello</span>, this<span class="hljs-type">::getBye</span>)<br>              .<span class="hljs-built_in">map</span>(Supplier<span class="hljs-type">::get</span>)<br>              .filter(Optional<span class="hljs-type">::isPresent</span>)<br>              .<span class="hljs-built_in">map</span>(Optional<span class="hljs-type">::get</span>)<br>              .findFirst();<br><br><span class="hljs-comment">// 若function想要帶上參數 需使用lambda</span><br>Optional&lt;<span class="hljs-built_in">String</span>&gt; found3 = Stream.&lt;Supplier&lt;Optional&lt;<span class="hljs-built_in">String</span>&gt;&gt;&gt;of(<br>              () -&gt; createOptional(<span class="hljs-string">&quot;empty&quot;</span>),<br>              () -&gt; createOptional(<span class="hljs-string">&quot;hello&quot;</span>)<br>      )<br>      .<span class="hljs-built_in">map</span>(Supplier<span class="hljs-type">::get</span>)<br>      .filter(Optional<span class="hljs-type">::isPresent</span>)<br>      .<span class="hljs-built_in">map</span>(Optional<span class="hljs-type">::get</span>)<br>      .findFirst();<br><br><br><span class="hljs-comment">//        判斷是否全數為null</span><br><span class="hljs-built_in">String</span> found4 = Stream.&lt;Supplier&lt;Optional&lt;<span class="hljs-built_in">String</span>&gt;&gt;&gt;of(<br>                () -&gt; createOptional(<span class="hljs-string">&quot;empty&quot;</span>),<br>                () -&gt; createOptional(<span class="hljs-string">&quot;E&quot;</span>)<br>        )<br>        .<span class="hljs-built_in">map</span>(Supplier<span class="hljs-type">::get</span>)<br>        .filter(Optional<span class="hljs-type">::isPresent</span>)<br>        .<span class="hljs-built_in">map</span>(Optional<span class="hljs-type">::get</span>)<br>        .findFirst()<br>        .orElseGet(() -&gt; <span class="hljs-string">&quot;default&quot;</span>);<br><br>assertEquals(<span class="hljs-string">&quot;E&quot;</span>,found4);<br><br><span class="hljs-keyword">private</span> Optional&lt;<span class="hljs-built_in">String</span>&gt; getEmpty() &#123;<br>        <span class="hljs-keyword">return</span> Optional.empty();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Optional&lt;<span class="hljs-built_in">String</span>&gt; getHello() &#123;<br>        <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Optional&lt;<span class="hljs-built_in">String</span>&gt; getBye() &#123;<br>        <span class="hljs-keyword">return</span> Optional.of(<span class="hljs-string">&quot;bye&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Optional&lt;<span class="hljs-built_in">String</span>&gt; createOptional(<span class="hljs-built_in">String</span> input) &#123;<br>        <span class="hljs-keyword">if</span> (input == <span class="hljs-built_in">null</span> || <span class="hljs-string">&quot;&quot;</span>.<span class="hljs-keyword">equals</span>(input) || <span class="hljs-string">&quot;empty&quot;</span>.<span class="hljs-keyword">equals</span>(input)) &#123;<br>            <span class="hljs-keyword">return</span> Optional.empty();<br>        &#125;<br>        <span class="hljs-keyword">return</span> Optional.of(input);<br>    &#125;<br><br></code></pre></td></tr></table></figure></li><li>map與flatmap<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> static String testOptionalFlatMap(Student student) &#123;<br><br><span class="hljs-comment">// 這段是使用Optional 檢測 Null</span><br>        <span class="hljs-keyword">var</span> score = student.getScore();<br>        <span class="hljs-keyword">if</span>(score.isPresent()) &#123;<br>            <span class="hljs-keyword">var</span> word = score.<span class="hljs-keyword">get</span>().getWord();<br>            <span class="hljs-keyword">if</span>(word .isPresent()) &#123;<br>                <span class="hljs-keyword">return</span> word.<span class="hljs-keyword">get</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NA&quot;</span>;<br><br><span class="hljs-comment">// 這段是使用Optional Flatmap 檢測 Null</span><br>        <span class="hljs-keyword">return</span> student.getScore()<br>                .flatMap(Score::getWord)<br>                .orElse(<span class="hljs-string">&quot;n.a.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>以上就是常見的基本Optional用法，也許不需要全部都會，只需要基本了解就很夠用了也說不定。</li></ol><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Swagger撰寫你的 Rest API document 吧!(適用Java 17)</title>
    <link href="/2024/04/22/%E7%B0%A1%E5%96%AE%E4%BD%BF%E7%94%A8Swagger%E5%8A%9F%E8%83%BD-%E9%81%A9%E7%94%A8Java-17/"/>
    <url>/2024/04/22/%E7%B0%A1%E5%96%AE%E4%BD%BF%E7%94%A8Swagger%E5%8A%9F%E8%83%BD-%E9%81%A9%E7%94%A8Java-17/</url>
    
    <content type="html"><![CDATA[<p>作為一個後端工程師，除了基本的API開發，如何撰寫出讓人好理解的文件至關重要。一份好的文件不僅可以幫助RD了解API，也能提供給PM等部門去了解自己的產品。</p><span id="more"></span>Swagger就是因此而生，Swagger的特色是利用Annonation撰寫文件，另外透過OpenAPI，將撰寫的內容轉成靜態網頁，文件只需要提供靜態網頁就可以讓前端人員、PM去參考API的格式與規範，相當方便。<p>本文以Java 17舉例。</p><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><p>在Maven的pom.xml檔案中添加以下依賴，並reload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>接著補上API(已經有API的這部分可以不看)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/api&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemberController</span> &#123;<br>    <span class="hljs-meta">@PutMapping(<span class="hljs-string">&quot;/member&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String login(<span class="hljs-meta">@RequestBody</span> HashMap reqMap) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Start login~&quot;</span>);<br>        String response = memberService.login(reqMap);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Response = &quot;</span> + response);<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接著訪問以下路徑<br><a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a><br>就可以看到一個靜態網頁，裡面應該有所有Project的API，簡單的建立就完成了。<br>OpenAPI的特色是可以建立一個網頁，讓你瀏覽專案中所有在偵測範圍內的API。</p><p>你可以試著為API添加一些資訊，像是針對系統的名稱、描述或是開發者的資料等等。像這樣</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>@<span class="hljs-keyword">Configuration</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> OpenAPIConfiguration &#123;<br><br>   @Bean<br>   <span class="hljs-built_in">public</span> OpenAPI defineOpenApi() &#123;<br>       <span class="hljs-keyword">Server</span> <span class="hljs-keyword">server</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Server</span>();<br>       <span class="hljs-keyword">server</span>.setUrl(&quot;http://localhost:8080&quot;);<br>       <span class="hljs-keyword">server</span>.setDescription(&quot;Development&quot;);<br><br>       Contact myContact = <span class="hljs-built_in">new</span> Contact();<br>       myContact.setName(&quot;Jane Doe&quot;);<br>       myContact.setEmail(&quot;your.email@gmail.com&quot;);<br><br>       <span class="hljs-keyword">Info</span> information = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Info</span>()<br>               .title(&quot;Employee Management System API&quot;)<br>               .version(&quot;1.0&quot;)<br>               .description(&quot;This API exposes endpoints to manage employees.&quot;)<br>               .contact(myContact);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> OpenAPI().<span class="hljs-keyword">info</span>(information).servers(List.<span class="hljs-keyword">of</span>(<span class="hljs-keyword">server</span>));<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果想要為個別的API添加描述，可以參考以下程式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Tag(name = <span class="hljs-string">&quot;get&quot;</span>, description = <span class="hljs-string">&quot;GET methods of Employee APIs&quot;</span>)</span><br><span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/employees&quot;</span>)</span><br><span class="hljs-keyword">public</span> List&lt;Employee&gt; findAllEmployees() &#123;<br>   <span class="hljs-keyword">return</span> repository.findAll();<br>&#125;<br><br><span class="hljs-meta">@Tag(name = <span class="hljs-string">&quot;get&quot;</span>, description = <span class="hljs-string">&quot;GET methods of Employee APIs&quot;</span>)</span><br><span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/employees/&#123;employeeId&#125;&quot;</span>)</span><br><span class="hljs-keyword">public</span> Employee getEmployee(<span class="hljs-meta">@PathVariable</span> int employeeId) &#123;<br>   Employee employee = repository.findById(employeeId)<br>           .orElseThrow(() -&gt; new RuntimeException(<span class="hljs-string">&quot;Employee id not found - &quot;</span> + employeeId));<br>   <span class="hljs-keyword">return</span> employee;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Tag中的name代表了分類，description代表針對這個分類的描述。</p><p>如果要建立Response的文件規範的話，可以參考以下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@ApiResponses(&#123;<br>       @ApiResponse(responseCode = <span class="hljs-string">&quot;200&quot;</span>, content = &#123; @Content(mediaType = <span class="hljs-string">&quot;application/json&quot;</span>,<br>               schema = @Schema(implementation = Employee.<span class="hljs-keyword">class</span>)) &#125;),<br>       @ApiResponse(responseCode = <span class="hljs-string">&quot;404&quot;</span>, description = <span class="hljs-string">&quot;Employee not found&quot;</span>,<br>               content = @Content) &#125;)<br>@DeleteMapping(<span class="hljs-string">&quot;/employees/&#123;employeeId&#125;&quot;</span>)<br>public <span class="hljs-built_in">String</span> deleteEmployee(@PathVariable int employeeId) &#123;<br>   Employee employee = repository.findById(employeeId)<br>           .orElseThrow(<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Employee id not found - &quot;</span> + employeeId));<br>   repository.<span class="hljs-keyword">delete</span>(employee);<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Deleted employee with id: &quot;</span> + employeeId;<br>&#125;<br></code></pre></td></tr></table></figure><p>@ApiResponse是一個回傳格式，可以撰寫不同HTTP狀態碼的回傳內容，以及更多描述。<br>有了以上功能，你應該就可以為你的API寫出足夠描述的文件了。</p><p><img src="/images/swagger-demo.png" alt="这是图片"></p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ol><li><a href="https://medium.com/@berktorun.dev/swagger-like-a-pro-with-spring-boot-3-and-java-17-49eed0ce1d2f">https://medium.com/@berktorun.dev/swagger-like-a-pro-with-spring-boot-3-and-java-17-49eed0ce1d2f</a></li><li><a href="https://bell-sw.com/blog/documenting-rest-api-with-swagger-in-spring-boot-3/E">https://bell-sw.com/blog/documenting-rest-api-with-swagger-in-spring-boot-3/E</a></li></ol><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring JPA(JDK 17)的一些疑難雜症</title>
    <link href="/2024/04/20/Spring-JPA-JDK-17-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/"/>
    <url>/2024/04/20/Spring-JPA-JDK-17-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%9B%A3%E9%9B%9C%E7%97%87/</url>
    
    <content type="html"><![CDATA[<h3 id="問題一"><a href="#問題一" class="headerlink" title="問題一"></a>問題一</h3><p>今天在自己做Project時，啟動Project時老是出現Spring JPA 冒出的錯誤訊息:not a managed type class…</p><span id="more"></span><p>遇到時當下我有點困惑，因為之前做時從來沒看過，所以在這邊做個紀錄：<br>錯誤的地方如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.payment_system.orm;<br><br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">&quot;payment_member_info&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMemberInfo</span> </span>&#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_member_id&quot;</span>)<br>    <span class="hljs-keyword">private</span> Long pmiMeberId;<br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_member_name&quot;</span>,nullable = <span class="hljs-literal">false</span>,length = <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> pmsMemberName;<br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_member_phone&quot;</span>,nullable = <span class="hljs-literal">false</span>,length = <span class="hljs-number">30</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> pmiMemberPhone;<br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_member_email&quot;</span>,nullable = <span class="hljs-literal">false</span>,length = <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> pmiMemberEmail;<br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_member_pwd&quot;</span>,nullable = <span class="hljs-literal">false</span>,length = <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> pmiMemberpwd;<br>    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">&quot;pmi_lastlogin_time&quot;</span>,nullable = <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">private</span> LocalDateTime pmiLastloginTime;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>這個錯誤發生的原因來自Spring的JDK版本問題，在新版的SpringBoot與JDK中，把JavaX給替換成了Jakarta，所以只要是SpringBoot 6+ 與 JDK 17+，都是使用jakarta persist api，只要換成jakarta就解決這個問題了。</p><h3 id="問題二"><a href="#問題二" class="headerlink" title="問題二"></a>問題二</h3><p>在新建立專案時遇到錯誤</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Failed <span class="hljs-built_in">to</span> configure <span class="hljs-keyword">a</span> DataSource: <span class="hljs-string">&#x27;url&#x27;</span> attribute is <span class="hljs-keyword">not</span> specified <span class="hljs-keyword">and</span> no embedded datasource could be configured.<br><br>Reason: Failed <span class="hljs-built_in">to</span> determine <span class="hljs-keyword">a</span> suitable driver class<br><br><br>Action:<br><br>Consider <span class="hljs-keyword">the</span> following:<br>If you want <span class="hljs-keyword">an</span> embedded database (H2, HSQL <span class="hljs-keyword">or</span> Derby), please <span class="hljs-built_in">put</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">on</span> <span class="hljs-title">the</span> <span class="hljs-title">classpath</span>.<br>If you have database settings <span class="hljs-built_in">to</span> be loaded <span class="hljs-built_in">from</span> <span class="hljs-keyword">a</span> particular profile you may need <span class="hljs-built_in">to</span> activate <span class="hljs-keyword">it</span> (no profiles are currently active).<br><br><br>Process finished <span class="hljs-keyword">with</span> exit code <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>這很明顯的就是少了設定資料庫的poperties，所以如果遇到的話要檢查application.poperties是否存在以下config：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.datasource.url</span>=jdbc:sqlserver://localhost:<span class="hljs-number">1433</span><span class="hljs-comment">;databaseName=payment;encrypt=false;</span><br><span class="hljs-attr">spring.datasource.username</span>=sa<br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-number">17</span>E513579<br><span class="hljs-attr">spring.datasource.driver-class-name</span>=com.microsoft.sqlserver.jdbc.SQLServerDriver<br><br></code></pre></td></tr></table></figure><p>從上至下分別是：連線資料庫的url、連線資料庫的帳號、密碼、以及資料庫驅動程式，根據你使用不同的資料庫要添加的稍有不同，以下以SQL Server作為舉例。</p><h3 id="問題三"><a href="#問題三" class="headerlink" title="問題三"></a>問題三</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&quot;encrypt&quot; 屬性設定為 &quot;true&quot; 且 &quot;trustServerCertificate&quot; 屬性設為 &quot;false&quot;，但驅動程式無法使用安全通訊端層 (SSL) 加密建立 <span class="hljs-keyword">SQL</span> <span class="hljs-keyword">Server</span> 的安全連線: 錯誤: PKIX <span class="hljs-type">path</span> building failed: sun.<span class="hljs-keyword">security</span>.provider.certpath.SunCertPathBuilderException: unable <span class="hljs-keyword">to</span> find <span class="hljs-keyword">valid</span> certification <span class="hljs-type">path</span> <span class="hljs-keyword">to</span> requested target。 ClientConnectionId:<span class="hljs-number">7633</span>a811-f5ed<span class="hljs-number">-4644</span>-b413<span class="hljs-number">-770e31275</span>a44<br></code></pre></td></tr></table></figure><p>如果在連線時出現以下問題，代表資料庫沒有設定SSL加密的，方法有兩種，解法有調整資料庫SSL加密，以及在application.poperties設定取消加密兩種方法。如果後者可以參考以下程式。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.datasource.url</span>=jdbc:sqlserver://localhost:<span class="hljs-number">1433</span><span class="hljs-comment">;databaseName=payment;encrypt=false;</span><br></code></pre></td></tr></table></figure><p>以上</p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ol><li><a href="https://stackoverflow.com/questions/28664064/spring-boot-not-a-managed-type">https://stackoverflow.com/questions/28664064/spring-boot-not-a-managed-type</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>關於我拿到日本公司的內定卻決定拒絕的那件事</title>
    <link href="/2024/04/19/%E9%97%9C%E6%96%BC%E6%88%91%E6%8B%BF%E5%88%B0%E6%97%A5%E6%9C%AC%E5%85%AC%E5%8F%B8%E7%9A%84%E5%85%A7%E5%AE%9A%E5%8D%BB%E6%B1%BA%E5%AE%9A%E6%8B%92%E7%B5%95%E7%9A%84%E9%82%A3%E4%BB%B6%E4%BA%8B/"/>
    <url>/2024/04/19/%E9%97%9C%E6%96%BC%E6%88%91%E6%8B%BF%E5%88%B0%E6%97%A5%E6%9C%AC%E5%85%AC%E5%8F%B8%E7%9A%84%E5%85%A7%E5%AE%9A%E5%8D%BB%E6%B1%BA%E5%AE%9A%E6%8B%92%E7%B5%95%E7%9A%84%E9%82%A3%E4%BB%B6%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="你有沒有曾經想過，只要搭著電車、就可以在淺草拍照？-你有沒有想過，只要搭一會兒新幹線，就可以在京都尋訪各地日本美景？"><a href="#你有沒有曾經想過，只要搭著電車、就可以在淺草拍照？-你有沒有想過，只要搭一會兒新幹線，就可以在京都尋訪各地日本美景？" class="headerlink" title="你有沒有曾經想過，只要搭著電車、就可以在淺草拍照？ 你有沒有想過，只要搭一會兒新幹線，就可以在京都尋訪各地日本美景？"></a>你有沒有曾經想過，只要搭著電車、就可以在淺草拍照？ 你有沒有想過，只要搭一會兒新幹線，就可以在京都尋訪各地日本美景？</h4><p><strong>我有</strong></p><p>這邊算是一篇生活的筆記紀錄，主要是最近發生了太多事情，一時之間不曉得怎麼讓自己去習慣這樣的變化，所以我決定訴諸文字，透過過去陪伴了我數年的文字來表達出我內心一隅的期盼、忍讓與惋惜。</p><p>我從小就很喜歡日本文化，名字中也包含了日文(旻)，這讓我自小就覺得自己是個適合日本的人，我小時候看的動畫從航海王，線上愛奇藝的死神，到我正式入宅看的Fate&#x2F;Zero、當紅戀愛喜劇我的妹妹哪有那麼可愛、不朽經典的幸運星等等，代表性的動畫不計其數。不同於許多同學，喜歡動畫都在國中、高中階段，我的熱情從未退卻。<br>高中開始聽Galgame OP，開始使用Twitter追蹤喜歡的畫師，接觸可能連日本人都不熟悉的同人誌與同人音樂，還有偷偷瞞著家裡買Galgame豪華特典版，更別說家裡的牆壁早就被我掛滿海報、掛軸、還有畫師親簽的複製原畫。這些年來我從來沒有後悔入宅過，一次都沒有。</p><p>除此之外，我也不是白宅的，我在高中，連一句日文都不會說時，就開始利用Youtube去翻譯動畫、遊戲的預告，因為我希望有著跟我同樣對動畫充滿熱情的人，不會因為語言而停止追逐。<br>在大學時，我正式開始學習日文、或許是宅得無可救藥的緣故，我只考了兩次日文檢定，就拿到了日文檢定最高的JLPT N1。當下拿到時我真的很開心。<br>回顧我學生時期的軌跡，我以自己的熱情為傲，並堅信自己的熱情終有一天會引導我前往更好的生活，也就是住在日本。</p><h4 id="那時我還不知道自己有多天真"><a href="#那時我還不知道自己有多天真" class="headerlink" title="那時我還不知道自己有多天真**"></a>那時我還不知道自己有多天真**</h4><p>大學畢業後的我，成為一名軟體工程師，每天上班Coding，下班後過著快樂宅的生活，然而一枚Gmail吸引了我的目光。</p><p><strong>「日本 樂天 招募台灣工程師」</strong></p><p>這封信就好像一滴墨漬在白紙上暈開般，我忽然間想起自己應該要開始嘗試自己一直以來都想要嘗試的事了。我試著投遞了職缺，但最終因為能力不足而被刷掉。<br>但我沒有氣餒。「不就是能力嗎？我去培養不就好了。」<br>於是我開始對軟體知識認真向學，從只會Coding到可以設計出一個還可以的系統。可以說是<br>日本是我一直以來前進的契機，因為想要，所以必須得努力不可。</p><p>今年，過了一年的我，帶著一年軟體開發的經驗去投遞日本職缺，我使用Linkedin上找尋海外赴日的顧問，請他幫我找適合我的職缺。<br>接著就是一連串的忙碌日子，從第一次跟日本人說話，到面試練習、職務經歷、志望動機、自我PR與自我介紹，我把我所有能做的事情都做了。</p><p>而最後我拿到的職缺是「派遣IT 軟體工程師」</p><p>很滑稽吧，努力到盡頭我得到的居然是派遣IT的工作，在國內的我雖然也只是在名不經傳的小新創企業，但好歹也是一份正職工作，但我要去日本的話，居然只能透過派遣IT的形式過去嗎？</p><p>我琢磨一直以來帶領自己成長與前進的力量，忍不住產生了懷疑。「このまま、本当にいいのか？(這樣下去真的好嗎)」我期望著日本的生活，但卻要因此犧牲目前在台灣的生活、失去穩定的工作，以及成長性。就只是為了前往日本，這樣真的是最佳解嗎？</p><p>我帶著這份困惑，向工作的老闆提出了我想要離開這份工作前往日本的事，老闆表示同意也鼓勵我去趁著自己年輕時追逐自己的夢想。</p><p>然而，心中的那份疑惑終於已某種形式爆發出來了，心中理性的自己告訴自己住手，為了日本拋棄一切根本是愚蠢至極，若是失敗了自己將毫無退路，而另外一道聲音則告訴自己，這是自己的志願，為了日本追逐至今的自己，如今卻要讓機會從手中滑落嗎？</p><p><strong>「祝福，在我始料未及的情況下，逆轉成了詛咒。」</strong></p><p>這份掙扎與痛苦讓我苦苦思慮了相當久的一段時間，有好幾天我早上五點半起床，在家中陽台呆愣著看著窗外，浮現一抹魚肚白的天際。期望著有誰能給我解答，但回應我的只有戶外野狗的吠叫。</p><p>最後，我咬著牙，拋棄了一直以來支持我的理想，也就是日本的生活。我是理想的叛徒，像是小丑一般在Offer面談的前一天拒絕了入職邀約，儘管合理卻對我來說不合理，我看見顧問發來無數詢問的訊息，把手機丟向一旁，身體深深埋入了被窩之中。</p><p>又是一天的五點鐘起床，我望著窗外的天際，心裡也慢慢浮現了一線曙光，為我長久以來的掙扎與苦痛畫下了休止符。</p><p>失去了日本、失去了工作，如今的我還剩下什麼？我沒有答案。</p><p><strong>這是不是正確的？</strong> 這個問題我連想都不敢想，我的意志不夠堅定，所以不能再讓它傷害更多的人了，我咬著指甲，將這份苦澀的情緒，伴隨早餐的咖啡一嚥而下。</p>]]></content>
    
    
    <categories>
      
      <category>生活紀錄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本求職</tag>
      
      <tag>面試</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何建立自己的Github部落格 使用Hexo+Github Page</title>
    <link href="/2024/04/19/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84Github%E9%83%A8%E8%90%BD%E6%A0%BC-%E4%BD%BF%E7%94%A8Hexo-Github-Page/"/>
    <url>/2024/04/19/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84Github%E9%83%A8%E8%90%BD%E6%A0%BC-%E4%BD%BF%E7%94%A8Hexo-Github-Page/</url>
    
    <content type="html"><![CDATA[<p>網路上目前已經有很多這類的教學了，所以這篇比較像是自己的學習紀錄。</p><span id="more"></span><h3 id="Hexo是什麼？"><a href="#Hexo是什麼？" class="headerlink" title="Hexo是什麼？"></a>Hexo是什麼？</h3><p>Hexo是基於Node.js開發的網誌框架，特色主要如下：</p><ul><li>一鍵部署</li><li>簡單操作</li><li>支援MarkDown語法</li><li>多種模板可參考，更多模板可以參考<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li></ul><h3 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h3><ol><li><p>安裝Node.js，Hexo需要透過npm安裝。(<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>)</p></li><li><p>安裝Git，用來將檔案發佈到Github Page。(<a href="https://git-scm.com/">https://git-scm.com/</a>)</p></li><li><p>安裝Node.js完成後開啟cmd，輸入<strong>npm version</strong>確保node.js可以成功顯示內容，若Node.js安裝成功，這部分應該會顯示一堆套件的訊息。</p></li><li><p>安裝Hexo，在cmd輸入以下指令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure></li><li><p>安裝好後輸入 hexo version，查看hexo版本，如果有顯示版本名稱就代表安裝成功了。</p></li><li><p>初始化Hexo，在你想要的路徑下輸入以下指令來建立</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ hexo <span class="hljs-keyword">init</span> &lt;資料夾名稱&gt;<br></code></pre></td></tr></table></figure></li><li><p>建立好後將目錄切進去</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">cd <span class="hljs-tag">&lt;<span class="hljs-name">資料夾名稱</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>安裝npm套件，<strong>這部分重要，不要忘記</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure></li><li><p>產生靜態檔案，本地啟動看看</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br>$ hexo server<br></code></pre></td></tr></table></figure></li><li><p>Hexo預設路徑<a href="http://localhost:4000/">http://localhost:4000/</a></p></li><li><p>開啟你的Github帳號，沒有就註冊一個。</p></li><li><p>New一個Repository，並把專案命名為&lt;名字&gt;.github.io，這部分是固定的，不可以自定義。</p></li><li><p>建立好repository後，先把你的專案網址clone起來。</p></li><li><p>在cmd輸入以下指令安裝git相關套件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>調整Deployment。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;你剛剛clone的路徑&gt;</span><br><span class="hljs-symbol">  branch:</span> <span class="hljs-params">&lt;你專案的branch名稱，通常是master&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>部署它</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure></li><li><p>你應該會在Github Action看到 pages build and deployment 的訊息，請耐心等他跑完，應該一分鐘內就會執行完成。你應該可以在https:&#x2F;&#x2F;名稱.github.io的路徑下找到它</p></li><li><p>之後你的每次修改後都應該要</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo clean    <span class="hljs-comment">// 清除之前建立的靜態檔案</span><br>$ hexo <span class="hljs-keyword">generate</span>     <span class="hljs-comment">// 建立靜態頁面</span><br>$ hexo deploy     <span class="hljs-comment">// 部署至 GitHub</span><br></code></pre></td></tr></table></figure></li></ol><p>以上就是安裝教學。接下來說說要怎麼新增文章。</p><ol><li>在cmd輸入以下指令<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;你的文章標題&quot;</span><br></code></pre></td></tr></table></figure></li><li>新增之後，你應該可以在source路徑下找到你自己剛剛建立的文章</li><li>使用Markdown語法輸入你想寫的內容</li><li>重複上一篇步驟18的動作，你就成功部署新的文章了</li></ol><h4 id="以上。"><a href="#以上。" class="headerlink" title="以上。"></a>以上。</h4><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ol><li><a href="https://hexo.io/zh-tw/docs/writing">https://hexo.io/zh-tw/docs/writing</a></li><li><a href="https://hackmd.io/@Heidi-Liu/note-hexo-github">https://hackmd.io/@Heidi-Liu/note-hexo-github</a></li><li><a href="https://hackmd.io/@Heidi-Liu/hexo-theme">https://hackmd.io/@Heidi-Liu/hexo-theme</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10242172">https://ithelp.ithome.com.tw/articles/10242172</a></li><li><a href="https://hexo.io/zh-tw/docs/github-pages">https://hexo.io/zh-tw/docs/github-pages</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>對你的API進行測試吧 - Java Mockito API</title>
    <link href="/2024/03/02/%E5%B0%8D%E4%BD%A0%E7%9A%84API%E9%80%B2%E8%A1%8C%E6%B8%AC%E8%A9%A6%E5%90%A7-Java-Mockito-API/"/>
    <url>/2024/03/02/%E5%B0%8D%E4%BD%A0%E7%9A%84API%E9%80%B2%E8%A1%8C%E6%B8%AC%E8%A9%A6%E5%90%A7-Java-Mockito-API/</url>
    
    <content type="html"><![CDATA[<p>在開發SpringBoot應用程式的途中，一般來說會建議盡量要寫測試(但也有例外，比如說我現在待的這間)，其中測試又有分為單元測試、整合測試、端對端測試等等。<br>但本文並不是要說明這三者測試之間的差別，而是介紹測試用的Mock框架。所以想要了解那三者之間的差別的人，可以參考：</p><p>一般來說，想要在SpringBoot中撰寫測試時，就會在預設的@SpringBootTest中撰寫測試程式碼。以下是一個測試的範例：</p><p>RoutingHealth是一個存放於資料庫的物件，該物件可以決定通路(聯邦銀行)是否被鎖定，系統假設設定了鎖定的條件，而我要測試鎖定的狀況，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@MockBean</span><br>   <span class="hljs-keyword">private</span> RoutingHealthRepository rhRepo;<br>   <span class="hljs-comment">// 這是Mockito使用的假造一個bean，使用假造的代表裡面很乾淨，</span><br>   <span class="hljs-comment">//不會有什麼Spring的配置，poperties等都沒有</span><br>   <br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelDuringLockTime</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:30:48.183&quot;</span>; <span class="hljs-comment">// 交易時間</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:25:48.183&quot;</span>; <span class="hljs-comment">// 上次UBOT被鎖定時間</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>; <span class="hljs-comment">// 健康度分流功能</span><br>       MockDBObject(outChannel,lastTimeWasLock,healthFlag); <span class="hljs-comment">// 偽造DB物件</span><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertFalse(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已開啟，交易時間30分鐘內 block success!&quot;</span>);<br>   &#125;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelOverLockTime</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:56:48.183&quot;</span>; <span class="hljs-comment">// 時間設定超過前次鎖定時間加30分鐘</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:25:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br>       MockDBObject(outChannel,lastTimeWasLock,healthFlag);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertTrue(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已開啟，交易時間超過30分鐘 pass success!&quot;</span>);<br>   &#125;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelClosed</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:30:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2023-11-24T16:25:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;N&quot;</span>; <span class="hljs-comment">// 關閉健康度分流</span><br>       MockDBObject(outChannel,lastTimeWasLock,healthFlag);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertTrue(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已關閉，交易時間30分鐘內 pass success!&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelUBTestBefore</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// UB未鎖定，</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-15T14:00:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-18T16:00:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>; <span class="hljs-comment">// 啟用健康度分流</span><br>       MockDBObjectUBTest(outChannel,lastTimeWasLock,healthFlag);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertTrue(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已啟用，交易時間早於鎖定時間 pass success!&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelUBTestAfter</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// UB未鎖定，</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-18T17:00:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-18T16:00:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>; <span class="hljs-comment">// 啟用健康度分流</span><br>       MockDBObjectUBTest(outChannel,lastTimeWasLock,healthFlag);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertTrue(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已啟用，交易時間晚於鎖定時間30分鐘後 pass success!&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">HealthTunnelUBTestDuring</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// UB未鎖定，</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UBOT&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">reqTime</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-18T16:00:49.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastTimeWasLock</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-03-18T16:00:48.183&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">healthFlag</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>; <span class="hljs-comment">// 啟用健康度分流</span><br>       MockDBObjectUBTest(outChannel,lastTimeWasLock,healthFlag);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isPass</span> <span class="hljs-operator">=</span> routingHealthService.getRoutingHealthByOutChannel(outChannel,reqTime);<br>       Assert.assertFalse(isPass);<br>       System.out.println(<span class="hljs-string">&quot;鎖定狀態下，健康度分流已啟用，交易時間於鎖定時間30分鐘內 ban success!&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MockDBObjectUBTest</span><span class="hljs-params">(String outChannel,String lastTimeWasLock,String healthFlag)</span> &#123;<br>       <span class="hljs-type">RoutingHealth</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoutingHealth</span>();<br>       rh.setRhType(outChannel);<br>       rh.setRhIsActive(<span class="hljs-string">&quot;N&quot;</span>); <span class="hljs-comment">// 假設聯邦Gateway是被鎖住的</span><br>       rh.setRhLockTime(LocalDateTime.parse(lastTimeWasLock)); <span class="hljs-comment">// 聯邦Gateway上次被鎖定的時間點</span><br>       Mockito.<span class="hljs-keyword">when</span>(coreFacade.getSystemSetting(SSCode.LOCK_MINUTES)).thenReturn(<span class="hljs-string">&quot;30&quot;</span>);<br>       Mockito.<span class="hljs-keyword">when</span>(coreFacade.getSystemSetting(SSCode.ROUTING_HEALTH_FLAG)).thenReturn(healthFlag); <span class="hljs-comment">// 健康度分流是否開啟</span><br>       Mockito.<span class="hljs-keyword">when</span>(rhRepo.getRoutingHealthByRhTypeAndRhLockTimeBetween(outChannel)).thenReturn(rh);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MockDBObject</span><span class="hljs-params">(String outChannel,String lastTimeWasLock,String healthFlag)</span> &#123;<br>       <span class="hljs-type">RoutingHealth</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoutingHealth</span>();<br>       rh.setRhType(outChannel);<br>       rh.setRhIsActive(<span class="hljs-string">&quot;N&quot;</span>); <span class="hljs-comment">// 假設聯邦Gateway是被鎖住的</span><br>       rh.setRhLockTime(LocalDateTime.parse(lastTimeWasLock)); <span class="hljs-comment">// 聯邦Gateway上次被鎖定的時間點</span><br>       Mockito.<span class="hljs-keyword">when</span>(coreFacade.getSystemSetting(SSCode.LOCK_MINUTES)).thenReturn(<span class="hljs-string">&quot;30&quot;</span>);<br>       Mockito.<span class="hljs-keyword">when</span>(coreFacade.getSystemSetting(SSCode.ROUTING_HEALTH_FLAG)).thenReturn(healthFlag); <span class="hljs-comment">// 健康度分流是否開啟</span><br>       Mockito.<span class="hljs-keyword">when</span>(rhRepo.getRoutingHealthByRhTypeAndRhLockTimeBetween(outChannel)).thenReturn(rh);<br>   &#125;<br>   <br>   <span class="hljs-comment">// poperties 的假造</span><br> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRefundPoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">MainService</span> <span class="hljs-variable">mainService</span> <span class="hljs-operator">=</span> MockConfig();<br><br><span class="hljs-type">HashMap</span> <span class="hljs-variable">reqJson</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>reqJson.put(<span class="hljs-string">&quot;pmMemberNo&quot;</span>,<span class="hljs-string">&quot;GID76683851296887&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;pmPointAmt&quot;</span>,<span class="hljs-string">&quot;50000&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;pointId&quot;</span>,<span class="hljs-string">&quot;ResIsFatF2-4&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;pmSellerName&quot;</span>,<span class="hljs-string">&quot;testMerchantLaLaLa&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;allowInsufficient&quot;</span>,<span class="hljs-string">&quot;Y&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;merchantNo&quot;</span>,<span class="hljs-string">&quot;0904000001&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;refundId&quot;</span>,<span class="hljs-string">&quot;ResIsChubby01&quot;</span>);<br>reqJson.put(<span class="hljs-string">&quot;mchId&quot;</span>,<span class="hljs-string">&quot;ACpay&quot;</span>);<br><br><span class="hljs-type">Fundmentals</span> <span class="hljs-variable">fundmentals</span> <span class="hljs-operator">=</span> Fundmentals.builder()<br>.tradeType(TradeType.CANCEL)<br>.apiKey(<span class="hljs-string">&quot;xyz123&quot;</span>)<br>.accessUrl(<span class="hljs-string">&quot;https://icash-apim.icashsys.com.tw/Point-UAT/v1/RefundPoint&quot;</span>).build();<br><span class="hljs-type">String</span> <span class="hljs-variable">respJSON</span> <span class="hljs-operator">=</span> mainService.mainprocedure(reqJson,fundmentals);<br>HashMap&lt;String,String&gt; result = objectMapper.readValue(respJSON, HashMap.class);<br>Assert.assertEquals(<span class="hljs-string">&quot;3003&quot;</span>,result.get(<span class="hljs-string">&quot;resultCode&quot;</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> MainService <span class="hljs-title function_">MockConfig</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">MainService</span> <span class="hljs-variable">mainService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MainService</span>();<br><span class="hljs-type">MainService</span> <span class="hljs-variable">mainService_mock</span> <span class="hljs-operator">=</span> Mockito.spy(mainService);<br>Mockito.doReturn(<span class="hljs-literal">null</span>).<span class="hljs-keyword">when</span>(mainService_mock).SendRequest(Mockito.anyObject(),Mockito.anyString()); <span class="hljs-comment">// 先不發到OP</span><br>Mockito.doNothing().<span class="hljs-keyword">when</span>(mainService_mock).validate(Mockito.anyObject()); <span class="hljs-comment">// 先不做欄位檢查</span><br>ReflectionTestUtils.setField(mainService_mock, <span class="hljs-string">&quot;queryDomain&quot;</span>, <span class="hljs-string">&quot;https://icash-apim.icashsys.com.tw/Point-UAT/v1/QueryPoint&quot;</span>); <span class="hljs-comment">// 仿造 @Value</span><br>ReflectionTestUtils.setField(mainService_mock, <span class="hljs-string">&quot;apiKey&quot;</span>, <span class="hljs-string">&quot;xyz123&quot;</span>); <span class="hljs-comment">// 仿造 @Value</span><br><span class="hljs-keyword">return</span> mainService_mock;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MVCResult-測試-端對端測試"><a href="#MVCResult-測試-端對端測試" class="headerlink" title="MVCResult 測試 端對端測試"></a>MVCResult 測試 端對端測試</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">httpHeaders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>httpHeaders.add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>httpHeaders.add(<span class="hljs-string">&quot;Version&quot;</span>, <span class="hljs-string">&quot;1.0.1&quot;</span>);<br>httpHeaders.add(<span class="hljs-string">&quot;ClientIp&quot;</span>, <span class="hljs-string">&quot;1.1.1.1&quot;</span>);<br><br><span class="hljs-type">RequestBuilder</span> <span class="hljs-variable">requestBuilder</span> <span class="hljs-operator">=</span><br>        MockMvcRequestBuilders<br>                .get(<span class="hljs-string">&quot;/api/getPointExpectAmt&quot;</span>)<br>                .headers(httpHeaders)<br>                .param(<span class="hljs-string">&quot;pmslType&quot;</span>, <span class="hljs-string">&quot;AM&quot;</span>)<br>                .param(<span class="hljs-string">&quot;purchaseAmt&quot;</span>, <span class="hljs-string">&quot;10000&quot;</span>);<br><br><span class="hljs-type">MvcResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> mockMvc.perform(requestBuilder)<br>        .andDo(print())<br>        .andExpect(jsonPath(<span class="hljs-string">&quot;$.code&quot;</span>).value(<span class="hljs-string">&quot;0&quot;</span>))<br>        .andExpect(jsonPath(<span class="hljs-string">&quot;$.message&quot;</span>).value(<span class="hljs-string">&quot;SUCCESS&quot;</span>))<br>        .andReturn();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Mockito</tag>
      
      <tag>UnitTest</tag>
      
      <tag>IntegrationTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC to Hibernate to JPA</title>
    <link href="/2022/10/12/JDBC-to-Hibernate-to-JPA/"/>
    <url>/2022/10/12/JDBC-to-Hibernate-to-JPA/</url>
    
    <content type="html"><![CDATA[<p>雖然我們前面已經快速地介紹了基本的三層式架構，(Controller、Service與Repository)，但我今天想要再詳細一點地介紹當中的Repository。Repository掌管與資料庫之間互動的細節。</p><p>Spring與資料庫溝通的方式有很多種，你也許聽過JDBC、Spring JPA、Hibernate ORM 等等，今天就會一一介紹他們。</p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>Spring Framework 本身提供了jdbcTemplate讓開發者可以以執行SQL的形式向資料庫溝通，要使用前，首先你會需要引入相關的依賴。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果是maven</span><br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;mysql&lt;/groupId&gt;<br>        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>        &lt;scope&gt;runtime&lt;/scope&gt;<br>    &lt;/dependency&gt;<br>    <br><span class="hljs-comment">// 如果是gradle</span><br><br>implementation <span class="hljs-string">&#x27;org.springframework:spring-jdbc:6.1.12&#x27;</span><br><br></code></pre></td></tr></table></figure><p>引入之後，就可以開始開發JDBC的應用程式。注意，為了避免有人忘記，我要提醒一下下，除了引入依賴外，SpringBoot的application.properties也必須要添加對應的設定，比方說如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">spring.datasource.url=jdbc:mysql://localhost:3306/school</span><br><span class="hljs-string">spring.datasource.username=root</span><br><span class="hljs-string">spring.datasource.password=password</span><br><span class="hljs-string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>從上到下分別是，資料庫的位址、資料庫的帳號與密碼、以及資料庫的datasource驅動程式。實際上，根據你使用的資料庫資訊會有些微差異</p><p>jdbcTemplate封裝了JDBC，並提供了一系列的實作，假設我想要建立一筆學生資料，JDBC會長這樣子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO students (name, age, gender, class) VALUES (?, ?, ?, ?)&quot;</span>;<br>jdbcTemplate.update(sql, student.getName(), student.getAge(), student.getGender(), student.getStudentClass());<br></code></pre></td></tr></table></figure><p>假設我們想要查詢單筆學生的資料、或是單一個值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM students WHERE id = ?&quot;</span>;<br>jdbcTemplate.queryForObject(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;id&#125;, (rs, rowNum) -&gt; &#123;<br><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setId(rs.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>    student.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>    student.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>    student.setGender(rs.getString(<span class="hljs-string">&quot;gender&quot;</span>));<br>    student.setStudentClass(rs.getString(<span class="hljs-string">&quot;class&quot;</span>));<br>    <span class="hljs-keyword">return</span> student;<br>&#125;);<br>    <br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO students (name, age, gender, class) VALUES (?, ?, ?, ?)&quot;</span>;<br><span class="hljs-keyword">return</span> jdbcTemplate.update(sql, student.getName(), student.getAge(), student.getGender(), student.getStudentClass());<br></code></pre></td></tr></table></figure><p>這樣的方法，你會發現，其實就只是Java上面下SQL Statement而已，而且物件必須要被重新處理，因此後面為了克服這一點，才有ORM的出現。</p><p>ORM──全名為ObjectRelatedModel，就是以Java的物件(Object)直接對應至資料庫的表格(Model)，省去繁複的物件比對功能。Java來說，Hibernate是最常見的ORM應用。主要有以下好處</p><p>● 生產力提升（Productivity）：減少撰寫資料存取元件程式碼，聚焦在商業邏輯。</p><p>● 容易維護（Maintainability）：程式碼較少，語法上來說比純SQL更容易維護。</p><p>● 效能調校（Performance）：節省SQL語法除錯時間，多花時間調校SQL邏輯效能。</p><p>● 資料庫廠商的獨立性（Vendor independence）：免除受限於特定廠商，開發者可於輕量資料庫上開發程式，部署時再安裝至正式的大型資料庫。</p><p>在Hibernate的定義中，與資料庫的一次對話被定義為一個Session，在一個Session中可以執行多個CRUD等等操作，舉例來說，一段Hibernate的程式碼會像這樣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stduent</span>(); <br>student.setName(<span class="hljs-string">&quot;Johnson&quot;</span>); <br>student.setAge(<span class="hljs-number">18</span>); <br><br><span class="hljs-comment">// 開啟Session，相當於開啟JDBC的Connection</span><br><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> HibernateUtil.getSessionFactory().openSession(); <br><span class="hljs-comment">// Transaction表示一組會話操作</span><br>Transaction tx= session.beginTransaction(); <br><span class="hljs-comment">// 將物件映射至資料庫表格中儲存</span><br>session.save(user);<br>tx.commit(); <br>session.close(); <br></code></pre></td></tr></table></figure><p>所以，Hibernate中一個與資料庫的溝通基本流程是這樣的：</p><ol><li>Hibernate對SQL建立一個對話(連線) Session。</li><li>在Session中建立一個Transaction。</li><li>在Transaction中執行對SQL的操作 ( CRUD )</li><li>將改動儲存 .save() 或是 .execute()</li><li>事務提交  tx.commit() ( 也會同步觸發對資料與資料庫之間的同步 .flush() )</li><li>結束這次對話，session.close()</li></ol><p>Hibernate成功實現了以Java物件操作資料庫物件的可能性，但ORM 現在更多人使用的是SpringJPA。</p><p>Spring Data JPA 封裝了 JDBC 與 Hibernate ORM，並使用方法名稱來Mapping資料庫。所以讓程式碼更加的簡單。就好像之前的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CrudRepository</span>&lt;Student, Long&gt; &#123;<br>    Student <span class="hljs-title function_">findByName</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在這個方法中，你完全不必要撰寫SQL語法，就能夠透過方法名稱去取得資料庫中對應的資料，比方說用姓名找出學生資料等等。</p><p>以上就是今天的介紹，感謝各位。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Hibernate</tag>
      
      <tag>Spring Data JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
